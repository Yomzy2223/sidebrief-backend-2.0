
/**
 * Client
**/

import * as runtime from './runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions

export type PrismaPromise<T> = $Public.PrismaPromise<T>


export type StaffPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Staff"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    firstName: string
    lastName: string
    email: string
    password: string
    phone: string
    verified: boolean
    picture: string | null
    resetToken: string | null
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["staff"]>
  composites: {}
}

/**
 * Model Staff
 * 
 */
export type Staff = runtime.Types.DefaultSelection<StaffPayload>
export type CollaboratorPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Collaborator"
  objects: {
    collaboratorDocument: CollaboratorDocumentPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    firstName: string
    lastName: string
    email: string
    password: string
    phone: string
    picture: string | null
    verified: boolean
    isPartner: boolean
    resetToken: string | null
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["collaborator"]>
  composites: {}
}

/**
 * Model Collaborator
 * 
 */
export type Collaborator = runtime.Types.DefaultSelection<CollaboratorPayload>
export type CollaboratorDocumentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "CollaboratorDocument"
  objects: {
    collaborator: CollaboratorPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    type: string
    description: string
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
    collaboratorId: string
  }, ExtArgs["result"]["collaboratorDocument"]>
  composites: {}
}

/**
 * Model CollaboratorDocument
 * 
 */
export type CollaboratorDocument = runtime.Types.DefaultSelection<CollaboratorDocumentPayload>
export type RewardPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Reward"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    url: string
    descrition: string
    image: string
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["reward"]>
  composites: {}
}

/**
 * Model Reward
 * 
 */
export type Reward = runtime.Types.DefaultSelection<RewardPayload>
export type CountryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Country"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    iso: string
    currency: string
    code: string
    flagUrl: string
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["country"]>
  composites: {}
}

/**
 * Model Country
 * 
 */
export type Country = runtime.Types.DefaultSelection<CountryPayload>
export type BankPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Bank"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    code: string
    url: string
    image: string
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["bank"]>
  composites: {}
}

/**
 * Model Bank
 * 
 */
export type Bank = runtime.Types.DefaultSelection<BankPayload>
export type NotificationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Notification"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    title: string
    body: string
    readStatus: boolean
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["notification"]>
  composites: {}
}

/**
 * Model Notification
 * 
 */
export type Notification = runtime.Types.DefaultSelection<NotificationPayload>
export type AccountPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Account"
  objects: {
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    userId: string
    type: string
    provider: string
    scope: string
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["account"]>
  composites: {}
}

/**
 * Model Account
 * 
 */
export type Account = runtime.Types.DefaultSelection<AccountPayload>
export type UserPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "User"
  objects: {
    teamMember: TeamMemberPayload<ExtArgs>[]
    account: AccountPayload<ExtArgs>[]
    productRequest: ProductRequestPayload<ExtArgs>[]
    document: UserDocumentPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    fullName: string
    username: string | null
    email: string
    password: string | null
    googleId: string | null
    phone: string | null
    picture: string | null
    isVerified: boolean
    referral: string | null
    country: string | null
    resetToken: string | null
    isPartner: boolean
    isStaff: boolean
    isPhoneRegistered: boolean
    isPhoneVerified: boolean
    isIdentificationRegistered: boolean
    isIdentificationVerified: boolean
    partnerPermission: string[]
    staffPermission: string[]
    userPermission: string[]
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["user"]>
  composites: {}
}

/**
 * Model User
 * 
 */
export type User = runtime.Types.DefaultSelection<UserPayload>
export type UserDocumentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "UserDocument"
  objects: {
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    name: string | null
    type: string | null
    link: string | null
    size: string | null
    belongsTo: string | null
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
    userId: string
  }, ExtArgs["result"]["userDocument"]>
  composites: {}
}

/**
 * Model UserDocument
 * 
 */
export type UserDocument = runtime.Types.DefaultSelection<UserDocumentPayload>
export type ServicePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Service"
  objects: {
    products: ProductPayload<ExtArgs>[]
    form: ServiceFormPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    description: string
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["service"]>
  composites: {}
}

/**
 * Model Service
 * 
 */
export type Service = runtime.Types.DefaultSelection<ServicePayload>
export type ServiceFormPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ServiceForm"
  objects: {
    service: ServicePayload<ExtArgs>
    subForm: ServiceSubFormPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    title: string | null
    description: string | null
    type: string | null
    compulsory: boolean
    createdAt: Date
    updatedAt: Date
    isDeprecated: boolean
    serviceId: string
  }, ExtArgs["result"]["serviceForm"]>
  composites: {}
}

/**
 * Model ServiceForm
 * 
 */
export type ServiceForm = runtime.Types.DefaultSelection<ServiceFormPayload>
export type ServiceSubFormPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ServiceSubForm"
  objects: {
    form: ServiceFormPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    question: string | null
    type: string | null
    options: string[]
    fileName: string | null
    fileType: string | null
    fileLink: string | null
    fileSize: string | null
    dependentField: string | null
    dependentOptions: string[]
    documentType: string | null
    allowOther: boolean
    compulsory: boolean
    createdAt: Date
    updatedAt: Date
    isDeprecated: boolean
    formId: string
  }, ExtArgs["result"]["serviceSubForm"]>
  composites: {}
}

/**
 * Model ServiceSubForm
 * 
 */
export type ServiceSubForm = runtime.Types.DefaultSelection<ServiceSubFormPayload>
export type ProductPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Product"
  objects: {
    service: ServicePayload<ExtArgs>
    request: ProductRequestPayload<ExtArgs>[]
    form: ProductFormPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    description: string
    country: string
    currency: string
    amount: number
    timeline: string
    feature: string[]
    canAlsoDo: string[]
    hasShares: boolean
    hasAgent: boolean
    hasOwner: boolean
    hasController: boolean
    controllerIsCalled: string | null
    OwnerIsCalled: string | null
    agentIsCalled: string | null
    createdAt: Date
    updatedAt: Date
    isDeprecated: boolean
    serviceId: string
  }, ExtArgs["result"]["product"]>
  composites: {}
}

/**
 * Model Product
 * 
 */
export type Product = runtime.Types.DefaultSelection<ProductPayload>
export type ProductFormPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ProductForm"
  objects: {
    product: ProductPayload<ExtArgs>
    productSubForm: ProductSubFormPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    title: string | null
    type: string | null
    description: string | null
    compulsory: boolean
    createdAt: Date
    isDeprecated: boolean
    updatedAt: Date
    productId: string
  }, ExtArgs["result"]["productForm"]>
  composites: {}
}

/**
 * Model ProductForm
 * 
 */
export type ProductForm = runtime.Types.DefaultSelection<ProductFormPayload>
export type ProductSubFormPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ProductSubForm"
  objects: {
    form: ProductFormPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    question: string | null
    options: string[]
    type: string | null
    allowOther: boolean
    dependentField: string | null
    dependentOptions: string[]
    fileName: string | null
    fileType: string | null
    fileLink: string | null
    fileSize: string | null
    documentType: string | null
    compulsory: boolean
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
    formId: string
  }, ExtArgs["result"]["productSubForm"]>
  composites: {}
}

/**
 * Model ProductSubForm
 * 
 */
export type ProductSubForm = runtime.Types.DefaultSelection<ProductSubFormPayload>
export type ProductRequestPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ProductRequest"
  objects: {
    Team: TeamPayload<ExtArgs>[]
    product: ProductPayload<ExtArgs> | null
    user: UserPayload<ExtArgs>
    Payment: PaymentPayload<ExtArgs>[]
    requestQA: ProductRequestQAPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    email: string | null
    address: string | null
    paid: boolean
    completed: boolean
    status: string
    currentState: ProductActivityStage
    createdAt: Date
    isDeprecated: boolean
    updatedAt: Date
    productId: string | null
    userId: string
  }, ExtArgs["result"]["productRequest"]>
  composites: {}
}

/**
 * Model ProductRequest
 * 
 */
export type ProductRequest = runtime.Types.DefaultSelection<ProductRequestPayload>
export type ProductRequestQAPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ProductRequestQA"
  objects: {
    request: ProductRequestPayload<ExtArgs>
    subForm: ProductRequestQASubFormPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    title: string | null
    description: string | null
    type: string | null
    compulsory: boolean
    isGeneral: boolean
    createdAt: Date
    updatedAt: Date
    isDeprecated: boolean
    requestId: string
  }, ExtArgs["result"]["productRequestQA"]>
  composites: {}
}

/**
 * Model ProductRequestQA
 * 
 */
export type ProductRequestQA = runtime.Types.DefaultSelection<ProductRequestQAPayload>
export type ProductRequestQASubFormPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ProductRequestQASubForm"
  objects: {
    requestQA: ProductRequestQAPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    question: string | null
    answer: string[]
    type: string | null
    fileName: string | null
    fileType: string | null
    fileLink: string | null
    fileSize: string | null
    compulsory: boolean
    isDeprecated: boolean
    requestQAId: string
  }, ExtArgs["result"]["productRequestQASubForm"]>
  composites: {}
}

/**
 * Model ProductRequestQASubForm
 * 
 */
export type ProductRequestQASubForm = runtime.Types.DefaultSelection<ProductRequestQASubFormPayload>
export type ClaimPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Claim"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    value: string
    userId: string
    createdAt: Date
    updatedAt: Date
    isDeprecated: boolean
  }, ExtArgs["result"]["claim"]>
  composites: {}
}

/**
 * Model Claim
 * 
 */
export type Claim = runtime.Types.DefaultSelection<ClaimPayload>
export type TeamPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Team"
  objects: {
    productRequest: ProductRequestPayload<ExtArgs>
    invitation: InvitationPayload<ExtArgs>[]
    teamMember: TeamMemberPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    slug: string
    userId: string
    createdAt: Date
    updatedAt: Date
    isDeprecated: boolean
    productRequestId: string
  }, ExtArgs["result"]["team"]>
  composites: {}
}

/**
 * Model Team
 * 
 */
export type Team = runtime.Types.DefaultSelection<TeamPayload>
export type TeamMemberPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "TeamMember"
  objects: {
    team: TeamPayload<ExtArgs>
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    isLaunchMember: boolean
    isLaunchController: boolean
    isLaunchOwner: boolean
    launchOwnership: number
    teamId: string
    userId: string
    createdAt: Date
    updatedAt: Date
    isDeprecated: boolean
  }, ExtArgs["result"]["teamMember"]>
  composites: {}
}

/**
 * Model TeamMember
 * 
 */
export type TeamMember = runtime.Types.DefaultSelection<TeamMemberPayload>
export type InvitationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Invitation"
  objects: {
    team: TeamPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    teamId: string
    email: string
    token: string
    expireIn: Date
    invitedBy: string
    createdAt: Date
    updatedAt: Date
    isDeprecated: boolean
  }, ExtArgs["result"]["invitation"]>
  composites: {}
}

/**
 * Model Invitation
 * 
 */
export type Invitation = runtime.Types.DefaultSelection<InvitationPayload>
export type PaymentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Payment"
  objects: {
    productRequests: ProductRequestPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    provider: string
    transactionId: string
    status: string
    email: string
    createdAt: Date
    updatedAt: Date
    isDeprecated: boolean
    productRequestId: string
  }, ExtArgs["result"]["payment"]>
  composites: {}
}

/**
 * Model Payment
 * 
 */
export type Payment = runtime.Types.DefaultSelection<PaymentPayload>
export type ParterPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Parter"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    isVerified: boolean
    verificationDocument: string[]
    serviceScore: number
    paymentsMade: number
    paymentsDue: number
    paymentDetails: string[]
    countrySupported: string[]
    serviceSupported: string[]
    servicesAssigned: string[]
    servicesCompleted: string[]
    servicesDeclined: string[]
    createdAt: Date
    updatedAt: Date
    isDeprecated: boolean
  }, ExtArgs["result"]["parter"]>
  composites: {}
}

/**
 * Model Parter
 * 
 */
export type Parter = runtime.Types.DefaultSelection<ParterPayload>

/**
 * Enums
 */

export const ProductActivityStage: {
  START: 'START',
  PAYMENT: 'PAYMENT',
  PROPRIETOR: 'PROPRIETOR',
  REVIEW: 'REVIEW'
};

export type ProductActivityStage = (typeof ProductActivityStage)[keyof typeof ProductActivityStage]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Staff
 * const staff = await prisma.staff.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Staff
   * const staff = await prisma.staff.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.staff`: Exposes CRUD operations for the **Staff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Staff
    * const staff = await prisma.staff.findMany()
    * ```
    */
  get staff(): Prisma.StaffDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.collaborator`: Exposes CRUD operations for the **Collaborator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Collaborators
    * const collaborators = await prisma.collaborator.findMany()
    * ```
    */
  get collaborator(): Prisma.CollaboratorDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.collaboratorDocument`: Exposes CRUD operations for the **CollaboratorDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CollaboratorDocuments
    * const collaboratorDocuments = await prisma.collaboratorDocument.findMany()
    * ```
    */
  get collaboratorDocument(): Prisma.CollaboratorDocumentDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.reward`: Exposes CRUD operations for the **Reward** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rewards
    * const rewards = await prisma.reward.findMany()
    * ```
    */
  get reward(): Prisma.RewardDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.country`: Exposes CRUD operations for the **Country** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.country.findMany()
    * ```
    */
  get country(): Prisma.CountryDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.bank`: Exposes CRUD operations for the **Bank** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Banks
    * const banks = await prisma.bank.findMany()
    * ```
    */
  get bank(): Prisma.BankDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.userDocument`: Exposes CRUD operations for the **UserDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserDocuments
    * const userDocuments = await prisma.userDocument.findMany()
    * ```
    */
  get userDocument(): Prisma.UserDocumentDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.serviceForm`: Exposes CRUD operations for the **ServiceForm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceForms
    * const serviceForms = await prisma.serviceForm.findMany()
    * ```
    */
  get serviceForm(): Prisma.ServiceFormDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.serviceSubForm`: Exposes CRUD operations for the **ServiceSubForm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceSubForms
    * const serviceSubForms = await prisma.serviceSubForm.findMany()
    * ```
    */
  get serviceSubForm(): Prisma.ServiceSubFormDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.productForm`: Exposes CRUD operations for the **ProductForm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductForms
    * const productForms = await prisma.productForm.findMany()
    * ```
    */
  get productForm(): Prisma.ProductFormDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.productSubForm`: Exposes CRUD operations for the **ProductSubForm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductSubForms
    * const productSubForms = await prisma.productSubForm.findMany()
    * ```
    */
  get productSubForm(): Prisma.ProductSubFormDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.productRequest`: Exposes CRUD operations for the **ProductRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductRequests
    * const productRequests = await prisma.productRequest.findMany()
    * ```
    */
  get productRequest(): Prisma.ProductRequestDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.productRequestQA`: Exposes CRUD operations for the **ProductRequestQA** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductRequestQAS
    * const productRequestQAS = await prisma.productRequestQA.findMany()
    * ```
    */
  get productRequestQA(): Prisma.ProductRequestQADelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.productRequestQASubForm`: Exposes CRUD operations for the **ProductRequestQASubForm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductRequestQASubForms
    * const productRequestQASubForms = await prisma.productRequestQASubForm.findMany()
    * ```
    */
  get productRequestQASubForm(): Prisma.ProductRequestQASubFormDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.claim`: Exposes CRUD operations for the **Claim** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Claims
    * const claims = await prisma.claim.findMany()
    * ```
    */
  get claim(): Prisma.ClaimDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.teamMember`: Exposes CRUD operations for the **TeamMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamMembers
    * const teamMembers = await prisma.teamMember.findMany()
    * ```
    */
  get teamMember(): Prisma.TeamMemberDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.invitation`: Exposes CRUD operations for the **Invitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invitations
    * const invitations = await prisma.invitation.findMany()
    * ```
    */
  get invitation(): Prisma.InvitationDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.parter`: Exposes CRUD operations for the **Parter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parters
    * const parters = await prisma.parter.findMany()
    * ```
    */
  get parter(): Prisma.ParterDelegate<GlobalReject, ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export type Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export type Args<T, F extends $Public.Operation> = $Public.Args<T, F>
  export type Payload<T, F extends $Public.Operation> = $Public.Payload<T, F>
  export type Result<T, A, F extends $Public.Operation> = $Public.Result<T, A, F>
  export type Exact<T, W> = $Public.Exact<T, W>

  /**
   * Prisma Client JS version: 4.16.2
   * Query Engine version: 4bc8b6e1b66cb932731fb1bdbbc550d1e010de81
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Staff: 'Staff',
    Collaborator: 'Collaborator',
    CollaboratorDocument: 'CollaboratorDocument',
    Reward: 'Reward',
    Country: 'Country',
    Bank: 'Bank',
    Notification: 'Notification',
    Account: 'Account',
    User: 'User',
    UserDocument: 'UserDocument',
    Service: 'Service',
    ServiceForm: 'ServiceForm',
    ServiceSubForm: 'ServiceSubForm',
    Product: 'Product',
    ProductForm: 'ProductForm',
    ProductSubForm: 'ProductSubForm',
    ProductRequest: 'ProductRequest',
    ProductRequestQA: 'ProductRequestQA',
    ProductRequestQASubForm: 'ProductRequestQASubForm',
    Claim: 'Claim',
    Team: 'Team',
    TeamMember: 'TeamMember',
    Invitation: 'Invitation',
    Payment: 'Payment',
    Parter: 'Parter'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'staff' | 'collaborator' | 'collaboratorDocument' | 'reward' | 'country' | 'bank' | 'notification' | 'account' | 'user' | 'userDocument' | 'service' | 'serviceForm' | 'serviceSubForm' | 'product' | 'productForm' | 'productSubForm' | 'productRequest' | 'productRequestQA' | 'productRequestQASubForm' | 'claim' | 'team' | 'teamMember' | 'invitation' | 'payment' | 'parter'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Staff: {
        payload: StaffPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.StaffFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StaffFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffPayload>
          }
          findFirst: {
            args: Prisma.StaffFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StaffFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffPayload>
          }
          findMany: {
            args: Prisma.StaffFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffPayload>[]
          }
          create: {
            args: Prisma.StaffCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffPayload>
          }
          createMany: {
            args: Prisma.StaffCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StaffDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffPayload>
          }
          update: {
            args: Prisma.StaffUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffPayload>
          }
          deleteMany: {
            args: Prisma.StaffDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StaffUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StaffUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffPayload>
          }
          aggregate: {
            args: Prisma.StaffAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStaff>
          }
          groupBy: {
            args: Prisma.StaffGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StaffGroupByOutputType>[]
          }
          count: {
            args: Prisma.StaffCountArgs<ExtArgs>,
            result: $Utils.Optional<StaffCountAggregateOutputType> | number
          }
        }
      }
      Collaborator: {
        payload: CollaboratorPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.CollaboratorFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CollaboratorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CollaboratorFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CollaboratorPayload>
          }
          findFirst: {
            args: Prisma.CollaboratorFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CollaboratorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CollaboratorFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CollaboratorPayload>
          }
          findMany: {
            args: Prisma.CollaboratorFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CollaboratorPayload>[]
          }
          create: {
            args: Prisma.CollaboratorCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CollaboratorPayload>
          }
          createMany: {
            args: Prisma.CollaboratorCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CollaboratorDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CollaboratorPayload>
          }
          update: {
            args: Prisma.CollaboratorUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CollaboratorPayload>
          }
          deleteMany: {
            args: Prisma.CollaboratorDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CollaboratorUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CollaboratorUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CollaboratorPayload>
          }
          aggregate: {
            args: Prisma.CollaboratorAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCollaborator>
          }
          groupBy: {
            args: Prisma.CollaboratorGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CollaboratorGroupByOutputType>[]
          }
          count: {
            args: Prisma.CollaboratorCountArgs<ExtArgs>,
            result: $Utils.Optional<CollaboratorCountAggregateOutputType> | number
          }
        }
      }
      CollaboratorDocument: {
        payload: CollaboratorDocumentPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.CollaboratorDocumentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CollaboratorDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CollaboratorDocumentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CollaboratorDocumentPayload>
          }
          findFirst: {
            args: Prisma.CollaboratorDocumentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CollaboratorDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CollaboratorDocumentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CollaboratorDocumentPayload>
          }
          findMany: {
            args: Prisma.CollaboratorDocumentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CollaboratorDocumentPayload>[]
          }
          create: {
            args: Prisma.CollaboratorDocumentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CollaboratorDocumentPayload>
          }
          createMany: {
            args: Prisma.CollaboratorDocumentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CollaboratorDocumentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CollaboratorDocumentPayload>
          }
          update: {
            args: Prisma.CollaboratorDocumentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CollaboratorDocumentPayload>
          }
          deleteMany: {
            args: Prisma.CollaboratorDocumentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CollaboratorDocumentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CollaboratorDocumentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CollaboratorDocumentPayload>
          }
          aggregate: {
            args: Prisma.CollaboratorDocumentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCollaboratorDocument>
          }
          groupBy: {
            args: Prisma.CollaboratorDocumentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CollaboratorDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CollaboratorDocumentCountArgs<ExtArgs>,
            result: $Utils.Optional<CollaboratorDocumentCountAggregateOutputType> | number
          }
        }
      }
      Reward: {
        payload: RewardPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.RewardFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RewardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RewardFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RewardPayload>
          }
          findFirst: {
            args: Prisma.RewardFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RewardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RewardFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RewardPayload>
          }
          findMany: {
            args: Prisma.RewardFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RewardPayload>[]
          }
          create: {
            args: Prisma.RewardCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RewardPayload>
          }
          createMany: {
            args: Prisma.RewardCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RewardDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RewardPayload>
          }
          update: {
            args: Prisma.RewardUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RewardPayload>
          }
          deleteMany: {
            args: Prisma.RewardDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RewardUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RewardUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RewardPayload>
          }
          aggregate: {
            args: Prisma.RewardAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReward>
          }
          groupBy: {
            args: Prisma.RewardGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RewardGroupByOutputType>[]
          }
          count: {
            args: Prisma.RewardCountArgs<ExtArgs>,
            result: $Utils.Optional<RewardCountAggregateOutputType> | number
          }
        }
      }
      Country: {
        payload: CountryPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.CountryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CountryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CountryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CountryPayload>
          }
          findFirst: {
            args: Prisma.CountryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CountryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CountryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CountryPayload>
          }
          findMany: {
            args: Prisma.CountryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CountryPayload>[]
          }
          create: {
            args: Prisma.CountryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CountryPayload>
          }
          createMany: {
            args: Prisma.CountryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CountryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CountryPayload>
          }
          update: {
            args: Prisma.CountryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CountryPayload>
          }
          deleteMany: {
            args: Prisma.CountryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CountryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CountryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CountryPayload>
          }
          aggregate: {
            args: Prisma.CountryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCountry>
          }
          groupBy: {
            args: Prisma.CountryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CountryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CountryCountArgs<ExtArgs>,
            result: $Utils.Optional<CountryCountAggregateOutputType> | number
          }
        }
      }
      Bank: {
        payload: BankPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.BankFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BankPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BankFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BankPayload>
          }
          findFirst: {
            args: Prisma.BankFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BankPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BankFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BankPayload>
          }
          findMany: {
            args: Prisma.BankFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BankPayload>[]
          }
          create: {
            args: Prisma.BankCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BankPayload>
          }
          createMany: {
            args: Prisma.BankCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BankDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BankPayload>
          }
          update: {
            args: Prisma.BankUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BankPayload>
          }
          deleteMany: {
            args: Prisma.BankDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BankUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BankUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BankPayload>
          }
          aggregate: {
            args: Prisma.BankAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBank>
          }
          groupBy: {
            args: Prisma.BankGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BankGroupByOutputType>[]
          }
          count: {
            args: Prisma.BankCountArgs<ExtArgs>,
            result: $Utils.Optional<BankCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: NotificationPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>,
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: AccountPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>,
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: UserPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserDocument: {
        payload: UserDocumentPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.UserDocumentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserDocumentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserDocumentPayload>
          }
          findFirst: {
            args: Prisma.UserDocumentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserDocumentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserDocumentPayload>
          }
          findMany: {
            args: Prisma.UserDocumentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserDocumentPayload>[]
          }
          create: {
            args: Prisma.UserDocumentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserDocumentPayload>
          }
          createMany: {
            args: Prisma.UserDocumentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDocumentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserDocumentPayload>
          }
          update: {
            args: Prisma.UserDocumentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserDocumentPayload>
          }
          deleteMany: {
            args: Prisma.UserDocumentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserDocumentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserDocumentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserDocumentPayload>
          }
          aggregate: {
            args: Prisma.UserDocumentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserDocument>
          }
          groupBy: {
            args: Prisma.UserDocumentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserDocumentCountArgs<ExtArgs>,
            result: $Utils.Optional<UserDocumentCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: ServicePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>,
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      ServiceForm: {
        payload: ServiceFormPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ServiceFormFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceFormPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFormFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceFormPayload>
          }
          findFirst: {
            args: Prisma.ServiceFormFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceFormPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFormFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceFormPayload>
          }
          findMany: {
            args: Prisma.ServiceFormFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceFormPayload>[]
          }
          create: {
            args: Prisma.ServiceFormCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceFormPayload>
          }
          createMany: {
            args: Prisma.ServiceFormCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ServiceFormDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceFormPayload>
          }
          update: {
            args: Prisma.ServiceFormUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceFormPayload>
          }
          deleteMany: {
            args: Prisma.ServiceFormDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceFormUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ServiceFormUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceFormPayload>
          }
          aggregate: {
            args: Prisma.ServiceFormAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateServiceForm>
          }
          groupBy: {
            args: Prisma.ServiceFormGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ServiceFormGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceFormCountArgs<ExtArgs>,
            result: $Utils.Optional<ServiceFormCountAggregateOutputType> | number
          }
        }
      }
      ServiceSubForm: {
        payload: ServiceSubFormPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ServiceSubFormFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceSubFormPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceSubFormFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceSubFormPayload>
          }
          findFirst: {
            args: Prisma.ServiceSubFormFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceSubFormPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceSubFormFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceSubFormPayload>
          }
          findMany: {
            args: Prisma.ServiceSubFormFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceSubFormPayload>[]
          }
          create: {
            args: Prisma.ServiceSubFormCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceSubFormPayload>
          }
          createMany: {
            args: Prisma.ServiceSubFormCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ServiceSubFormDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceSubFormPayload>
          }
          update: {
            args: Prisma.ServiceSubFormUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceSubFormPayload>
          }
          deleteMany: {
            args: Prisma.ServiceSubFormDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceSubFormUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ServiceSubFormUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceSubFormPayload>
          }
          aggregate: {
            args: Prisma.ServiceSubFormAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateServiceSubForm>
          }
          groupBy: {
            args: Prisma.ServiceSubFormGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ServiceSubFormGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceSubFormCountArgs<ExtArgs>,
            result: $Utils.Optional<ServiceSubFormCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: ProductPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      ProductForm: {
        payload: ProductFormPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ProductFormFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductFormPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFormFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductFormPayload>
          }
          findFirst: {
            args: Prisma.ProductFormFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductFormPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFormFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductFormPayload>
          }
          findMany: {
            args: Prisma.ProductFormFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductFormPayload>[]
          }
          create: {
            args: Prisma.ProductFormCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductFormPayload>
          }
          createMany: {
            args: Prisma.ProductFormCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProductFormDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductFormPayload>
          }
          update: {
            args: Prisma.ProductFormUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductFormPayload>
          }
          deleteMany: {
            args: Prisma.ProductFormDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProductFormUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProductFormUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductFormPayload>
          }
          aggregate: {
            args: Prisma.ProductFormAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProductForm>
          }
          groupBy: {
            args: Prisma.ProductFormGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductFormGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductFormCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductFormCountAggregateOutputType> | number
          }
        }
      }
      ProductSubForm: {
        payload: ProductSubFormPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ProductSubFormFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductSubFormPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductSubFormFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductSubFormPayload>
          }
          findFirst: {
            args: Prisma.ProductSubFormFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductSubFormPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductSubFormFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductSubFormPayload>
          }
          findMany: {
            args: Prisma.ProductSubFormFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductSubFormPayload>[]
          }
          create: {
            args: Prisma.ProductSubFormCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductSubFormPayload>
          }
          createMany: {
            args: Prisma.ProductSubFormCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProductSubFormDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductSubFormPayload>
          }
          update: {
            args: Prisma.ProductSubFormUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductSubFormPayload>
          }
          deleteMany: {
            args: Prisma.ProductSubFormDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProductSubFormUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProductSubFormUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductSubFormPayload>
          }
          aggregate: {
            args: Prisma.ProductSubFormAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProductSubForm>
          }
          groupBy: {
            args: Prisma.ProductSubFormGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductSubFormGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductSubFormCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductSubFormCountAggregateOutputType> | number
          }
        }
      }
      ProductRequest: {
        payload: ProductRequestPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ProductRequestFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductRequestFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductRequestPayload>
          }
          findFirst: {
            args: Prisma.ProductRequestFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductRequestFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductRequestPayload>
          }
          findMany: {
            args: Prisma.ProductRequestFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductRequestPayload>[]
          }
          create: {
            args: Prisma.ProductRequestCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductRequestPayload>
          }
          createMany: {
            args: Prisma.ProductRequestCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProductRequestDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductRequestPayload>
          }
          update: {
            args: Prisma.ProductRequestUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductRequestPayload>
          }
          deleteMany: {
            args: Prisma.ProductRequestDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProductRequestUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProductRequestUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductRequestPayload>
          }
          aggregate: {
            args: Prisma.ProductRequestAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProductRequest>
          }
          groupBy: {
            args: Prisma.ProductRequestGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductRequestCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductRequestCountAggregateOutputType> | number
          }
        }
      }
      ProductRequestQA: {
        payload: ProductRequestQAPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ProductRequestQAFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductRequestQAPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductRequestQAFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductRequestQAPayload>
          }
          findFirst: {
            args: Prisma.ProductRequestQAFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductRequestQAPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductRequestQAFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductRequestQAPayload>
          }
          findMany: {
            args: Prisma.ProductRequestQAFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductRequestQAPayload>[]
          }
          create: {
            args: Prisma.ProductRequestQACreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductRequestQAPayload>
          }
          createMany: {
            args: Prisma.ProductRequestQACreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProductRequestQADeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductRequestQAPayload>
          }
          update: {
            args: Prisma.ProductRequestQAUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductRequestQAPayload>
          }
          deleteMany: {
            args: Prisma.ProductRequestQADeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProductRequestQAUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProductRequestQAUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductRequestQAPayload>
          }
          aggregate: {
            args: Prisma.ProductRequestQAAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProductRequestQA>
          }
          groupBy: {
            args: Prisma.ProductRequestQAGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductRequestQAGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductRequestQACountArgs<ExtArgs>,
            result: $Utils.Optional<ProductRequestQACountAggregateOutputType> | number
          }
        }
      }
      ProductRequestQASubForm: {
        payload: ProductRequestQASubFormPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ProductRequestQASubFormFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductRequestQASubFormPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductRequestQASubFormFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductRequestQASubFormPayload>
          }
          findFirst: {
            args: Prisma.ProductRequestQASubFormFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductRequestQASubFormPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductRequestQASubFormFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductRequestQASubFormPayload>
          }
          findMany: {
            args: Prisma.ProductRequestQASubFormFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductRequestQASubFormPayload>[]
          }
          create: {
            args: Prisma.ProductRequestQASubFormCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductRequestQASubFormPayload>
          }
          createMany: {
            args: Prisma.ProductRequestQASubFormCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProductRequestQASubFormDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductRequestQASubFormPayload>
          }
          update: {
            args: Prisma.ProductRequestQASubFormUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductRequestQASubFormPayload>
          }
          deleteMany: {
            args: Prisma.ProductRequestQASubFormDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProductRequestQASubFormUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProductRequestQASubFormUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductRequestQASubFormPayload>
          }
          aggregate: {
            args: Prisma.ProductRequestQASubFormAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProductRequestQASubForm>
          }
          groupBy: {
            args: Prisma.ProductRequestQASubFormGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductRequestQASubFormGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductRequestQASubFormCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductRequestQASubFormCountAggregateOutputType> | number
          }
        }
      }
      Claim: {
        payload: ClaimPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ClaimFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ClaimPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClaimFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ClaimPayload>
          }
          findFirst: {
            args: Prisma.ClaimFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ClaimPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClaimFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ClaimPayload>
          }
          findMany: {
            args: Prisma.ClaimFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ClaimPayload>[]
          }
          create: {
            args: Prisma.ClaimCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ClaimPayload>
          }
          createMany: {
            args: Prisma.ClaimCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ClaimDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ClaimPayload>
          }
          update: {
            args: Prisma.ClaimUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ClaimPayload>
          }
          deleteMany: {
            args: Prisma.ClaimDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ClaimUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ClaimUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ClaimPayload>
          }
          aggregate: {
            args: Prisma.ClaimAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClaim>
          }
          groupBy: {
            args: Prisma.ClaimGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClaimGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClaimCountArgs<ExtArgs>,
            result: $Utils.Optional<ClaimCountAggregateOutputType> | number
          }
        }
      }
      Team: {
        payload: TeamPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TeamPayload>
          }
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TeamPayload>
          }
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TeamPayload>[]
          }
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TeamPayload>
          }
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TeamPayload>
          }
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TeamPayload>
          }
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TeamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>,
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      TeamMember: {
        payload: TeamMemberPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.TeamMemberFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TeamMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamMemberFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TeamMemberPayload>
          }
          findFirst: {
            args: Prisma.TeamMemberFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TeamMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamMemberFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TeamMemberPayload>
          }
          findMany: {
            args: Prisma.TeamMemberFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TeamMemberPayload>[]
          }
          create: {
            args: Prisma.TeamMemberCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TeamMemberPayload>
          }
          createMany: {
            args: Prisma.TeamMemberCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TeamMemberDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TeamMemberPayload>
          }
          update: {
            args: Prisma.TeamMemberUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TeamMemberPayload>
          }
          deleteMany: {
            args: Prisma.TeamMemberDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TeamMemberUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TeamMemberUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TeamMemberPayload>
          }
          aggregate: {
            args: Prisma.TeamMemberAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTeamMember>
          }
          groupBy: {
            args: Prisma.TeamMemberGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TeamMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamMemberCountArgs<ExtArgs>,
            result: $Utils.Optional<TeamMemberCountAggregateOutputType> | number
          }
        }
      }
      Invitation: {
        payload: InvitationPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.InvitationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvitationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvitationPayload>
          }
          findFirst: {
            args: Prisma.InvitationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvitationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvitationPayload>
          }
          findMany: {
            args: Prisma.InvitationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvitationPayload>[]
          }
          create: {
            args: Prisma.InvitationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvitationPayload>
          }
          createMany: {
            args: Prisma.InvitationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InvitationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvitationPayload>
          }
          update: {
            args: Prisma.InvitationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvitationPayload>
          }
          deleteMany: {
            args: Prisma.InvitationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InvitationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InvitationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvitationPayload>
          }
          aggregate: {
            args: Prisma.InvitationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInvitation>
          }
          groupBy: {
            args: Prisma.InvitationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvitationCountArgs<ExtArgs>,
            result: $Utils.Optional<InvitationCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: PaymentPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>,
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Parter: {
        payload: ParterPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ParterFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ParterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParterFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ParterPayload>
          }
          findFirst: {
            args: Prisma.ParterFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ParterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParterFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ParterPayload>
          }
          findMany: {
            args: Prisma.ParterFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ParterPayload>[]
          }
          create: {
            args: Prisma.ParterCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ParterPayload>
          }
          createMany: {
            args: Prisma.ParterCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ParterDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ParterPayload>
          }
          update: {
            args: Prisma.ParterUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ParterPayload>
          }
          deleteMany: {
            args: Prisma.ParterDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ParterUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ParterUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ParterPayload>
          }
          aggregate: {
            args: Prisma.ParterAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateParter>
          }
          groupBy: {
            args: Prisma.ParterGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ParterGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParterCountArgs<ExtArgs>,
            result: $Utils.Optional<ParterCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CollaboratorCountOutputType
   */


  export type CollaboratorCountOutputType = {
    collaboratorDocument: number
  }

  export type CollaboratorCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    collaboratorDocument?: boolean | CollaboratorCountOutputTypeCountCollaboratorDocumentArgs
  }

  // Custom InputTypes

  /**
   * CollaboratorCountOutputType without action
   */
  export type CollaboratorCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollaboratorCountOutputType
     */
    select?: CollaboratorCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CollaboratorCountOutputType without action
   */
  export type CollaboratorCountOutputTypeCountCollaboratorDocumentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CollaboratorDocumentWhereInput
  }



  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    teamMember: number
    account: number
    productRequest: number
    document: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    teamMember?: boolean | UserCountOutputTypeCountTeamMemberArgs
    account?: boolean | UserCountOutputTypeCountAccountArgs
    productRequest?: boolean | UserCountOutputTypeCountProductRequestArgs
    document?: boolean | UserCountOutputTypeCountDocumentArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamMemberArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProductRequestArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductRequestWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDocumentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserDocumentWhereInput
  }



  /**
   * Count Type ServiceCountOutputType
   */


  export type ServiceCountOutputType = {
    products: number
    form: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    products?: boolean | ServiceCountOutputTypeCountProductsArgs
    form?: boolean | ServiceCountOutputTypeCountFormArgs
  }

  // Custom InputTypes

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountFormArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ServiceFormWhereInput
  }



  /**
   * Count Type ServiceFormCountOutputType
   */


  export type ServiceFormCountOutputType = {
    subForm: number
  }

  export type ServiceFormCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    subForm?: boolean | ServiceFormCountOutputTypeCountSubFormArgs
  }

  // Custom InputTypes

  /**
   * ServiceFormCountOutputType without action
   */
  export type ServiceFormCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceFormCountOutputType
     */
    select?: ServiceFormCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ServiceFormCountOutputType without action
   */
  export type ServiceFormCountOutputTypeCountSubFormArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ServiceSubFormWhereInput
  }



  /**
   * Count Type ProductCountOutputType
   */


  export type ProductCountOutputType = {
    request: number
    form: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    request?: boolean | ProductCountOutputTypeCountRequestArgs
    form?: boolean | ProductCountOutputTypeCountFormArgs
  }

  // Custom InputTypes

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountRequestArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductRequestWhereInput
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountFormArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductFormWhereInput
  }



  /**
   * Count Type ProductFormCountOutputType
   */


  export type ProductFormCountOutputType = {
    productSubForm: number
  }

  export type ProductFormCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    productSubForm?: boolean | ProductFormCountOutputTypeCountProductSubFormArgs
  }

  // Custom InputTypes

  /**
   * ProductFormCountOutputType without action
   */
  export type ProductFormCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFormCountOutputType
     */
    select?: ProductFormCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProductFormCountOutputType without action
   */
  export type ProductFormCountOutputTypeCountProductSubFormArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductSubFormWhereInput
  }



  /**
   * Count Type ProductRequestCountOutputType
   */


  export type ProductRequestCountOutputType = {
    Team: number
    Payment: number
    requestQA: number
  }

  export type ProductRequestCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Team?: boolean | ProductRequestCountOutputTypeCountTeamArgs
    Payment?: boolean | ProductRequestCountOutputTypeCountPaymentArgs
    requestQA?: boolean | ProductRequestCountOutputTypeCountRequestQAArgs
  }

  // Custom InputTypes

  /**
   * ProductRequestCountOutputType without action
   */
  export type ProductRequestCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRequestCountOutputType
     */
    select?: ProductRequestCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProductRequestCountOutputType without action
   */
  export type ProductRequestCountOutputTypeCountTeamArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
  }


  /**
   * ProductRequestCountOutputType without action
   */
  export type ProductRequestCountOutputTypeCountPaymentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * ProductRequestCountOutputType without action
   */
  export type ProductRequestCountOutputTypeCountRequestQAArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductRequestQAWhereInput
  }



  /**
   * Count Type ProductRequestQACountOutputType
   */


  export type ProductRequestQACountOutputType = {
    subForm: number
  }

  export type ProductRequestQACountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    subForm?: boolean | ProductRequestQACountOutputTypeCountSubFormArgs
  }

  // Custom InputTypes

  /**
   * ProductRequestQACountOutputType without action
   */
  export type ProductRequestQACountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRequestQACountOutputType
     */
    select?: ProductRequestQACountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProductRequestQACountOutputType without action
   */
  export type ProductRequestQACountOutputTypeCountSubFormArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductRequestQASubFormWhereInput
  }



  /**
   * Count Type TeamCountOutputType
   */


  export type TeamCountOutputType = {
    invitation: number
    teamMember: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    invitation?: boolean | TeamCountOutputTypeCountInvitationArgs
    teamMember?: boolean | TeamCountOutputTypeCountTeamMemberArgs
  }

  // Custom InputTypes

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountInvitationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: InvitationWhereInput
  }


  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountTeamMemberArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
  }



  /**
   * Models
   */

  /**
   * Model Staff
   */


  export type AggregateStaff = {
    _count: StaffCountAggregateOutputType | null
    _min: StaffMinAggregateOutputType | null
    _max: StaffMaxAggregateOutputType | null
  }

  export type StaffMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    password: string | null
    phone: string | null
    verified: boolean | null
    picture: string | null
    resetToken: string | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    password: string | null
    phone: string | null
    verified: boolean | null
    picture: string | null
    resetToken: string | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    email: number
    password: number
    phone: number
    verified: number
    picture: number
    resetToken: number
    isDeprecated: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StaffMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    phone?: true
    verified?: true
    picture?: true
    resetToken?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    phone?: true
    verified?: true
    picture?: true
    resetToken?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    phone?: true
    verified?: true
    picture?: true
    resetToken?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StaffAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Staff to aggregate.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: Enumerable<StaffOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Staff
    **/
    _count?: true | StaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaffMaxAggregateInputType
  }

  export type GetStaffAggregateType<T extends StaffAggregateArgs> = {
        [P in keyof T & keyof AggregateStaff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaff[P]>
      : GetScalarType<T[P], AggregateStaff[P]>
  }




  export type StaffGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: StaffWhereInput
    orderBy?: Enumerable<StaffOrderByWithAggregationInput>
    by: StaffScalarFieldEnum[]
    having?: StaffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaffCountAggregateInputType | true
    _min?: StaffMinAggregateInputType
    _max?: StaffMaxAggregateInputType
  }


  export type StaffGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    email: string
    password: string
    phone: string
    verified: boolean
    picture: string | null
    resetToken: string | null
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
    _count: StaffCountAggregateOutputType | null
    _min: StaffMinAggregateOutputType | null
    _max: StaffMaxAggregateOutputType | null
  }

  type GetStaffGroupByPayload<T extends StaffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<StaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaffGroupByOutputType[P]>
            : GetScalarType<T[P], StaffGroupByOutputType[P]>
        }
      >
    >


  export type StaffSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    verified?: boolean
    picture?: boolean
    resetToken?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["staff"]>

  export type StaffSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    verified?: boolean
    picture?: boolean
    resetToken?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  type StaffGetPayload<S extends boolean | null | undefined | StaffArgs> = $Types.GetResult<StaffPayload, S>

  type StaffCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<StaffFindManyArgs, 'select' | 'include'> & {
      select?: StaffCountAggregateInputType | true
    }

  export interface StaffDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Staff'], meta: { name: 'Staff' } }
    /**
     * Find zero or one Staff that matches the filter.
     * @param {StaffFindUniqueArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StaffFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StaffFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Staff'> extends True ? Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Staff that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StaffFindUniqueOrThrowArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StaffFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StaffFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Staff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindFirstArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StaffFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StaffFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Staff'> extends True ? Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Staff that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindFirstOrThrowArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StaffFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StaffFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Staff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Staff
     * const staff = await prisma.staff.findMany()
     * 
     * // Get first 10 Staff
     * const staff = await prisma.staff.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const staffWithIdOnly = await prisma.staff.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StaffFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StaffFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<StaffPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Staff.
     * @param {StaffCreateArgs} args - Arguments to create a Staff.
     * @example
     * // Create one Staff
     * const Staff = await prisma.staff.create({
     *   data: {
     *     // ... data to create a Staff
     *   }
     * })
     * 
    **/
    create<T extends StaffCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StaffCreateArgs<ExtArgs>>
    ): Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Staff.
     *     @param {StaffCreateManyArgs} args - Arguments to create many Staff.
     *     @example
     *     // Create many Staff
     *     const staff = await prisma.staff.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StaffCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StaffCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Staff.
     * @param {StaffDeleteArgs} args - Arguments to delete one Staff.
     * @example
     * // Delete one Staff
     * const Staff = await prisma.staff.delete({
     *   where: {
     *     // ... filter to delete one Staff
     *   }
     * })
     * 
    **/
    delete<T extends StaffDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StaffDeleteArgs<ExtArgs>>
    ): Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Staff.
     * @param {StaffUpdateArgs} args - Arguments to update one Staff.
     * @example
     * // Update one Staff
     * const staff = await prisma.staff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StaffUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StaffUpdateArgs<ExtArgs>>
    ): Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Staff.
     * @param {StaffDeleteManyArgs} args - Arguments to filter Staff to delete.
     * @example
     * // Delete a few Staff
     * const { count } = await prisma.staff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StaffDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StaffDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Staff
     * const staff = await prisma.staff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StaffUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StaffUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Staff.
     * @param {StaffUpsertArgs} args - Arguments to update or create a Staff.
     * @example
     * // Update or create a Staff
     * const staff = await prisma.staff.upsert({
     *   create: {
     *     // ... data to create a Staff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Staff we want to update
     *   }
     * })
    **/
    upsert<T extends StaffUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StaffUpsertArgs<ExtArgs>>
    ): Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffCountArgs} args - Arguments to filter Staff to count.
     * @example
     * // Count the number of Staff
     * const count = await prisma.staff.count({
     *   where: {
     *     // ... the filter for the Staff we want to count
     *   }
     * })
    **/
    count<T extends StaffCountArgs>(
      args?: Subset<T, StaffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaffAggregateArgs>(args: Subset<T, StaffAggregateArgs>): Prisma.PrismaPromise<GetStaffAggregateType<T>>

    /**
     * Group by Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaffGroupByArgs['orderBy'] }
        : { orderBy?: StaffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StaffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Staff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StaffClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Staff base type for findUnique actions
   */
  export type StaffFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff findUnique
   */
  export interface StaffFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends StaffFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Staff findUniqueOrThrow
   */
  export type StaffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where: StaffWhereUniqueInput
  }


  /**
   * Staff base type for findFirst actions
   */
  export type StaffFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: Enumerable<StaffOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Staff.
     */
    distinct?: Enumerable<StaffScalarFieldEnum>
  }

  /**
   * Staff findFirst
   */
  export interface StaffFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends StaffFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Staff findFirstOrThrow
   */
  export type StaffFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: Enumerable<StaffOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Staff.
     */
    distinct?: Enumerable<StaffScalarFieldEnum>
  }


  /**
   * Staff findMany
   */
  export type StaffFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: Enumerable<StaffOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    distinct?: Enumerable<StaffScalarFieldEnum>
  }


  /**
   * Staff create
   */
  export type StaffCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * The data needed to create a Staff.
     */
    data: XOR<StaffCreateInput, StaffUncheckedCreateInput>
  }


  /**
   * Staff createMany
   */
  export type StaffCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Staff.
     */
    data: Enumerable<StaffCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Staff update
   */
  export type StaffUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * The data needed to update a Staff.
     */
    data: XOR<StaffUpdateInput, StaffUncheckedUpdateInput>
    /**
     * Choose, which Staff to update.
     */
    where: StaffWhereUniqueInput
  }


  /**
   * Staff updateMany
   */
  export type StaffUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Staff.
     */
    data: XOR<StaffUpdateManyMutationInput, StaffUncheckedUpdateManyInput>
    /**
     * Filter which Staff to update
     */
    where?: StaffWhereInput
  }


  /**
   * Staff upsert
   */
  export type StaffUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * The filter to search for the Staff to update in case it exists.
     */
    where: StaffWhereUniqueInput
    /**
     * In case the Staff found by the `where` argument doesn't exist, create a new Staff with this data.
     */
    create: XOR<StaffCreateInput, StaffUncheckedCreateInput>
    /**
     * In case the Staff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StaffUpdateInput, StaffUncheckedUpdateInput>
  }


  /**
   * Staff delete
   */
  export type StaffDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Filter which Staff to delete.
     */
    where: StaffWhereUniqueInput
  }


  /**
   * Staff deleteMany
   */
  export type StaffDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Staff to delete
     */
    where?: StaffWhereInput
  }


  /**
   * Staff without action
   */
  export type StaffArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
  }



  /**
   * Model Collaborator
   */


  export type AggregateCollaborator = {
    _count: CollaboratorCountAggregateOutputType | null
    _min: CollaboratorMinAggregateOutputType | null
    _max: CollaboratorMaxAggregateOutputType | null
  }

  export type CollaboratorMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    password: string | null
    phone: string | null
    picture: string | null
    verified: boolean | null
    isPartner: boolean | null
    resetToken: string | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CollaboratorMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    password: string | null
    phone: string | null
    picture: string | null
    verified: boolean | null
    isPartner: boolean | null
    resetToken: string | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CollaboratorCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    email: number
    password: number
    phone: number
    picture: number
    verified: number
    isPartner: number
    resetToken: number
    isDeprecated: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CollaboratorMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    phone?: true
    picture?: true
    verified?: true
    isPartner?: true
    resetToken?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CollaboratorMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    phone?: true
    picture?: true
    verified?: true
    isPartner?: true
    resetToken?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CollaboratorCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    phone?: true
    picture?: true
    verified?: true
    isPartner?: true
    resetToken?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CollaboratorAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Collaborator to aggregate.
     */
    where?: CollaboratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Collaborators to fetch.
     */
    orderBy?: Enumerable<CollaboratorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CollaboratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Collaborators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Collaborators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Collaborators
    **/
    _count?: true | CollaboratorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CollaboratorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CollaboratorMaxAggregateInputType
  }

  export type GetCollaboratorAggregateType<T extends CollaboratorAggregateArgs> = {
        [P in keyof T & keyof AggregateCollaborator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollaborator[P]>
      : GetScalarType<T[P], AggregateCollaborator[P]>
  }




  export type CollaboratorGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CollaboratorWhereInput
    orderBy?: Enumerable<CollaboratorOrderByWithAggregationInput>
    by: CollaboratorScalarFieldEnum[]
    having?: CollaboratorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CollaboratorCountAggregateInputType | true
    _min?: CollaboratorMinAggregateInputType
    _max?: CollaboratorMaxAggregateInputType
  }


  export type CollaboratorGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    email: string
    password: string
    phone: string
    picture: string | null
    verified: boolean
    isPartner: boolean
    resetToken: string | null
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
    _count: CollaboratorCountAggregateOutputType | null
    _min: CollaboratorMinAggregateOutputType | null
    _max: CollaboratorMaxAggregateOutputType | null
  }

  type GetCollaboratorGroupByPayload<T extends CollaboratorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CollaboratorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CollaboratorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CollaboratorGroupByOutputType[P]>
            : GetScalarType<T[P], CollaboratorGroupByOutputType[P]>
        }
      >
    >


  export type CollaboratorSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    picture?: boolean
    verified?: boolean
    isPartner?: boolean
    resetToken?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    collaboratorDocument?: boolean | Collaborator$collaboratorDocumentArgs<ExtArgs>
    _count?: boolean | CollaboratorCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["collaborator"]>

  export type CollaboratorSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    picture?: boolean
    verified?: boolean
    isPartner?: boolean
    resetToken?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CollaboratorInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    collaboratorDocument?: boolean | Collaborator$collaboratorDocumentArgs<ExtArgs>
    _count?: boolean | CollaboratorCountOutputTypeArgs<ExtArgs>
  }


  type CollaboratorGetPayload<S extends boolean | null | undefined | CollaboratorArgs> = $Types.GetResult<CollaboratorPayload, S>

  type CollaboratorCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CollaboratorFindManyArgs, 'select' | 'include'> & {
      select?: CollaboratorCountAggregateInputType | true
    }

  export interface CollaboratorDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Collaborator'], meta: { name: 'Collaborator' } }
    /**
     * Find zero or one Collaborator that matches the filter.
     * @param {CollaboratorFindUniqueArgs} args - Arguments to find a Collaborator
     * @example
     * // Get one Collaborator
     * const collaborator = await prisma.collaborator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CollaboratorFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CollaboratorFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Collaborator'> extends True ? Prisma__CollaboratorClient<$Types.GetResult<CollaboratorPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__CollaboratorClient<$Types.GetResult<CollaboratorPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Collaborator that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CollaboratorFindUniqueOrThrowArgs} args - Arguments to find a Collaborator
     * @example
     * // Get one Collaborator
     * const collaborator = await prisma.collaborator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CollaboratorFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CollaboratorFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CollaboratorClient<$Types.GetResult<CollaboratorPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Collaborator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaboratorFindFirstArgs} args - Arguments to find a Collaborator
     * @example
     * // Get one Collaborator
     * const collaborator = await prisma.collaborator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CollaboratorFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CollaboratorFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Collaborator'> extends True ? Prisma__CollaboratorClient<$Types.GetResult<CollaboratorPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__CollaboratorClient<$Types.GetResult<CollaboratorPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Collaborator that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaboratorFindFirstOrThrowArgs} args - Arguments to find a Collaborator
     * @example
     * // Get one Collaborator
     * const collaborator = await prisma.collaborator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CollaboratorFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CollaboratorFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CollaboratorClient<$Types.GetResult<CollaboratorPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Collaborators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaboratorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Collaborators
     * const collaborators = await prisma.collaborator.findMany()
     * 
     * // Get first 10 Collaborators
     * const collaborators = await prisma.collaborator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collaboratorWithIdOnly = await prisma.collaborator.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CollaboratorFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CollaboratorFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<CollaboratorPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Collaborator.
     * @param {CollaboratorCreateArgs} args - Arguments to create a Collaborator.
     * @example
     * // Create one Collaborator
     * const Collaborator = await prisma.collaborator.create({
     *   data: {
     *     // ... data to create a Collaborator
     *   }
     * })
     * 
    **/
    create<T extends CollaboratorCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CollaboratorCreateArgs<ExtArgs>>
    ): Prisma__CollaboratorClient<$Types.GetResult<CollaboratorPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Collaborators.
     *     @param {CollaboratorCreateManyArgs} args - Arguments to create many Collaborators.
     *     @example
     *     // Create many Collaborators
     *     const collaborator = await prisma.collaborator.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CollaboratorCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CollaboratorCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Collaborator.
     * @param {CollaboratorDeleteArgs} args - Arguments to delete one Collaborator.
     * @example
     * // Delete one Collaborator
     * const Collaborator = await prisma.collaborator.delete({
     *   where: {
     *     // ... filter to delete one Collaborator
     *   }
     * })
     * 
    **/
    delete<T extends CollaboratorDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CollaboratorDeleteArgs<ExtArgs>>
    ): Prisma__CollaboratorClient<$Types.GetResult<CollaboratorPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Collaborator.
     * @param {CollaboratorUpdateArgs} args - Arguments to update one Collaborator.
     * @example
     * // Update one Collaborator
     * const collaborator = await prisma.collaborator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CollaboratorUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CollaboratorUpdateArgs<ExtArgs>>
    ): Prisma__CollaboratorClient<$Types.GetResult<CollaboratorPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Collaborators.
     * @param {CollaboratorDeleteManyArgs} args - Arguments to filter Collaborators to delete.
     * @example
     * // Delete a few Collaborators
     * const { count } = await prisma.collaborator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CollaboratorDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CollaboratorDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Collaborators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaboratorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Collaborators
     * const collaborator = await prisma.collaborator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CollaboratorUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CollaboratorUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Collaborator.
     * @param {CollaboratorUpsertArgs} args - Arguments to update or create a Collaborator.
     * @example
     * // Update or create a Collaborator
     * const collaborator = await prisma.collaborator.upsert({
     *   create: {
     *     // ... data to create a Collaborator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Collaborator we want to update
     *   }
     * })
    **/
    upsert<T extends CollaboratorUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CollaboratorUpsertArgs<ExtArgs>>
    ): Prisma__CollaboratorClient<$Types.GetResult<CollaboratorPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Collaborators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaboratorCountArgs} args - Arguments to filter Collaborators to count.
     * @example
     * // Count the number of Collaborators
     * const count = await prisma.collaborator.count({
     *   where: {
     *     // ... the filter for the Collaborators we want to count
     *   }
     * })
    **/
    count<T extends CollaboratorCountArgs>(
      args?: Subset<T, CollaboratorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CollaboratorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Collaborator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaboratorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CollaboratorAggregateArgs>(args: Subset<T, CollaboratorAggregateArgs>): Prisma.PrismaPromise<GetCollaboratorAggregateType<T>>

    /**
     * Group by Collaborator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaboratorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CollaboratorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CollaboratorGroupByArgs['orderBy'] }
        : { orderBy?: CollaboratorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CollaboratorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollaboratorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Collaborator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CollaboratorClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    collaboratorDocument<T extends Collaborator$collaboratorDocumentArgs<ExtArgs> = {}>(args?: Subset<T, Collaborator$collaboratorDocumentArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<CollaboratorDocumentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Collaborator base type for findUnique actions
   */
  export type CollaboratorFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collaborator
     */
    select?: CollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which Collaborator to fetch.
     */
    where: CollaboratorWhereUniqueInput
  }

  /**
   * Collaborator findUnique
   */
  export interface CollaboratorFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CollaboratorFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Collaborator findUniqueOrThrow
   */
  export type CollaboratorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collaborator
     */
    select?: CollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which Collaborator to fetch.
     */
    where: CollaboratorWhereUniqueInput
  }


  /**
   * Collaborator base type for findFirst actions
   */
  export type CollaboratorFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collaborator
     */
    select?: CollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which Collaborator to fetch.
     */
    where?: CollaboratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Collaborators to fetch.
     */
    orderBy?: Enumerable<CollaboratorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Collaborators.
     */
    cursor?: CollaboratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Collaborators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Collaborators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Collaborators.
     */
    distinct?: Enumerable<CollaboratorScalarFieldEnum>
  }

  /**
   * Collaborator findFirst
   */
  export interface CollaboratorFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CollaboratorFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Collaborator findFirstOrThrow
   */
  export type CollaboratorFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collaborator
     */
    select?: CollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which Collaborator to fetch.
     */
    where?: CollaboratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Collaborators to fetch.
     */
    orderBy?: Enumerable<CollaboratorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Collaborators.
     */
    cursor?: CollaboratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Collaborators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Collaborators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Collaborators.
     */
    distinct?: Enumerable<CollaboratorScalarFieldEnum>
  }


  /**
   * Collaborator findMany
   */
  export type CollaboratorFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collaborator
     */
    select?: CollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which Collaborators to fetch.
     */
    where?: CollaboratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Collaborators to fetch.
     */
    orderBy?: Enumerable<CollaboratorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Collaborators.
     */
    cursor?: CollaboratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Collaborators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Collaborators.
     */
    skip?: number
    distinct?: Enumerable<CollaboratorScalarFieldEnum>
  }


  /**
   * Collaborator create
   */
  export type CollaboratorCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collaborator
     */
    select?: CollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorInclude<ExtArgs> | null
    /**
     * The data needed to create a Collaborator.
     */
    data: XOR<CollaboratorCreateInput, CollaboratorUncheckedCreateInput>
  }


  /**
   * Collaborator createMany
   */
  export type CollaboratorCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Collaborators.
     */
    data: Enumerable<CollaboratorCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Collaborator update
   */
  export type CollaboratorUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collaborator
     */
    select?: CollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorInclude<ExtArgs> | null
    /**
     * The data needed to update a Collaborator.
     */
    data: XOR<CollaboratorUpdateInput, CollaboratorUncheckedUpdateInput>
    /**
     * Choose, which Collaborator to update.
     */
    where: CollaboratorWhereUniqueInput
  }


  /**
   * Collaborator updateMany
   */
  export type CollaboratorUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Collaborators.
     */
    data: XOR<CollaboratorUpdateManyMutationInput, CollaboratorUncheckedUpdateManyInput>
    /**
     * Filter which Collaborators to update
     */
    where?: CollaboratorWhereInput
  }


  /**
   * Collaborator upsert
   */
  export type CollaboratorUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collaborator
     */
    select?: CollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorInclude<ExtArgs> | null
    /**
     * The filter to search for the Collaborator to update in case it exists.
     */
    where: CollaboratorWhereUniqueInput
    /**
     * In case the Collaborator found by the `where` argument doesn't exist, create a new Collaborator with this data.
     */
    create: XOR<CollaboratorCreateInput, CollaboratorUncheckedCreateInput>
    /**
     * In case the Collaborator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CollaboratorUpdateInput, CollaboratorUncheckedUpdateInput>
  }


  /**
   * Collaborator delete
   */
  export type CollaboratorDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collaborator
     */
    select?: CollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorInclude<ExtArgs> | null
    /**
     * Filter which Collaborator to delete.
     */
    where: CollaboratorWhereUniqueInput
  }


  /**
   * Collaborator deleteMany
   */
  export type CollaboratorDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Collaborators to delete
     */
    where?: CollaboratorWhereInput
  }


  /**
   * Collaborator.collaboratorDocument
   */
  export type Collaborator$collaboratorDocumentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollaboratorDocument
     */
    select?: CollaboratorDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorDocumentInclude<ExtArgs> | null
    where?: CollaboratorDocumentWhereInput
    orderBy?: Enumerable<CollaboratorDocumentOrderByWithRelationInput>
    cursor?: CollaboratorDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CollaboratorDocumentScalarFieldEnum>
  }


  /**
   * Collaborator without action
   */
  export type CollaboratorArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collaborator
     */
    select?: CollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorInclude<ExtArgs> | null
  }



  /**
   * Model CollaboratorDocument
   */


  export type AggregateCollaboratorDocument = {
    _count: CollaboratorDocumentCountAggregateOutputType | null
    _min: CollaboratorDocumentMinAggregateOutputType | null
    _max: CollaboratorDocumentMaxAggregateOutputType | null
  }

  export type CollaboratorDocumentMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    description: string | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    collaboratorId: string | null
  }

  export type CollaboratorDocumentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    description: string | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    collaboratorId: string | null
  }

  export type CollaboratorDocumentCountAggregateOutputType = {
    id: number
    name: number
    type: number
    description: number
    isDeprecated: number
    createdAt: number
    updatedAt: number
    collaboratorId: number
    _all: number
  }


  export type CollaboratorDocumentMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
    collaboratorId?: true
  }

  export type CollaboratorDocumentMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
    collaboratorId?: true
  }

  export type CollaboratorDocumentCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
    collaboratorId?: true
    _all?: true
  }

  export type CollaboratorDocumentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CollaboratorDocument to aggregate.
     */
    where?: CollaboratorDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollaboratorDocuments to fetch.
     */
    orderBy?: Enumerable<CollaboratorDocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CollaboratorDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollaboratorDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollaboratorDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CollaboratorDocuments
    **/
    _count?: true | CollaboratorDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CollaboratorDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CollaboratorDocumentMaxAggregateInputType
  }

  export type GetCollaboratorDocumentAggregateType<T extends CollaboratorDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateCollaboratorDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollaboratorDocument[P]>
      : GetScalarType<T[P], AggregateCollaboratorDocument[P]>
  }




  export type CollaboratorDocumentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CollaboratorDocumentWhereInput
    orderBy?: Enumerable<CollaboratorDocumentOrderByWithAggregationInput>
    by: CollaboratorDocumentScalarFieldEnum[]
    having?: CollaboratorDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CollaboratorDocumentCountAggregateInputType | true
    _min?: CollaboratorDocumentMinAggregateInputType
    _max?: CollaboratorDocumentMaxAggregateInputType
  }


  export type CollaboratorDocumentGroupByOutputType = {
    id: string
    name: string
    type: string
    description: string
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
    collaboratorId: string
    _count: CollaboratorDocumentCountAggregateOutputType | null
    _min: CollaboratorDocumentMinAggregateOutputType | null
    _max: CollaboratorDocumentMaxAggregateOutputType | null
  }

  type GetCollaboratorDocumentGroupByPayload<T extends CollaboratorDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CollaboratorDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CollaboratorDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CollaboratorDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], CollaboratorDocumentGroupByOutputType[P]>
        }
      >
    >


  export type CollaboratorDocumentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    collaboratorId?: boolean
    collaborator?: boolean | CollaboratorArgs<ExtArgs>
  }, ExtArgs["result"]["collaboratorDocument"]>

  export type CollaboratorDocumentSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    collaboratorId?: boolean
  }

  export type CollaboratorDocumentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    collaborator?: boolean | CollaboratorArgs<ExtArgs>
  }


  type CollaboratorDocumentGetPayload<S extends boolean | null | undefined | CollaboratorDocumentArgs> = $Types.GetResult<CollaboratorDocumentPayload, S>

  type CollaboratorDocumentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CollaboratorDocumentFindManyArgs, 'select' | 'include'> & {
      select?: CollaboratorDocumentCountAggregateInputType | true
    }

  export interface CollaboratorDocumentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CollaboratorDocument'], meta: { name: 'CollaboratorDocument' } }
    /**
     * Find zero or one CollaboratorDocument that matches the filter.
     * @param {CollaboratorDocumentFindUniqueArgs} args - Arguments to find a CollaboratorDocument
     * @example
     * // Get one CollaboratorDocument
     * const collaboratorDocument = await prisma.collaboratorDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CollaboratorDocumentFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CollaboratorDocumentFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CollaboratorDocument'> extends True ? Prisma__CollaboratorDocumentClient<$Types.GetResult<CollaboratorDocumentPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__CollaboratorDocumentClient<$Types.GetResult<CollaboratorDocumentPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one CollaboratorDocument that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CollaboratorDocumentFindUniqueOrThrowArgs} args - Arguments to find a CollaboratorDocument
     * @example
     * // Get one CollaboratorDocument
     * const collaboratorDocument = await prisma.collaboratorDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CollaboratorDocumentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CollaboratorDocumentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CollaboratorDocumentClient<$Types.GetResult<CollaboratorDocumentPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first CollaboratorDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaboratorDocumentFindFirstArgs} args - Arguments to find a CollaboratorDocument
     * @example
     * // Get one CollaboratorDocument
     * const collaboratorDocument = await prisma.collaboratorDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CollaboratorDocumentFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CollaboratorDocumentFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CollaboratorDocument'> extends True ? Prisma__CollaboratorDocumentClient<$Types.GetResult<CollaboratorDocumentPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__CollaboratorDocumentClient<$Types.GetResult<CollaboratorDocumentPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first CollaboratorDocument that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaboratorDocumentFindFirstOrThrowArgs} args - Arguments to find a CollaboratorDocument
     * @example
     * // Get one CollaboratorDocument
     * const collaboratorDocument = await prisma.collaboratorDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CollaboratorDocumentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CollaboratorDocumentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CollaboratorDocumentClient<$Types.GetResult<CollaboratorDocumentPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more CollaboratorDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaboratorDocumentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CollaboratorDocuments
     * const collaboratorDocuments = await prisma.collaboratorDocument.findMany()
     * 
     * // Get first 10 CollaboratorDocuments
     * const collaboratorDocuments = await prisma.collaboratorDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collaboratorDocumentWithIdOnly = await prisma.collaboratorDocument.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CollaboratorDocumentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CollaboratorDocumentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<CollaboratorDocumentPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a CollaboratorDocument.
     * @param {CollaboratorDocumentCreateArgs} args - Arguments to create a CollaboratorDocument.
     * @example
     * // Create one CollaboratorDocument
     * const CollaboratorDocument = await prisma.collaboratorDocument.create({
     *   data: {
     *     // ... data to create a CollaboratorDocument
     *   }
     * })
     * 
    **/
    create<T extends CollaboratorDocumentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CollaboratorDocumentCreateArgs<ExtArgs>>
    ): Prisma__CollaboratorDocumentClient<$Types.GetResult<CollaboratorDocumentPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many CollaboratorDocuments.
     *     @param {CollaboratorDocumentCreateManyArgs} args - Arguments to create many CollaboratorDocuments.
     *     @example
     *     // Create many CollaboratorDocuments
     *     const collaboratorDocument = await prisma.collaboratorDocument.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CollaboratorDocumentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CollaboratorDocumentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CollaboratorDocument.
     * @param {CollaboratorDocumentDeleteArgs} args - Arguments to delete one CollaboratorDocument.
     * @example
     * // Delete one CollaboratorDocument
     * const CollaboratorDocument = await prisma.collaboratorDocument.delete({
     *   where: {
     *     // ... filter to delete one CollaboratorDocument
     *   }
     * })
     * 
    **/
    delete<T extends CollaboratorDocumentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CollaboratorDocumentDeleteArgs<ExtArgs>>
    ): Prisma__CollaboratorDocumentClient<$Types.GetResult<CollaboratorDocumentPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one CollaboratorDocument.
     * @param {CollaboratorDocumentUpdateArgs} args - Arguments to update one CollaboratorDocument.
     * @example
     * // Update one CollaboratorDocument
     * const collaboratorDocument = await prisma.collaboratorDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CollaboratorDocumentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CollaboratorDocumentUpdateArgs<ExtArgs>>
    ): Prisma__CollaboratorDocumentClient<$Types.GetResult<CollaboratorDocumentPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more CollaboratorDocuments.
     * @param {CollaboratorDocumentDeleteManyArgs} args - Arguments to filter CollaboratorDocuments to delete.
     * @example
     * // Delete a few CollaboratorDocuments
     * const { count } = await prisma.collaboratorDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CollaboratorDocumentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CollaboratorDocumentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CollaboratorDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaboratorDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CollaboratorDocuments
     * const collaboratorDocument = await prisma.collaboratorDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CollaboratorDocumentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CollaboratorDocumentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CollaboratorDocument.
     * @param {CollaboratorDocumentUpsertArgs} args - Arguments to update or create a CollaboratorDocument.
     * @example
     * // Update or create a CollaboratorDocument
     * const collaboratorDocument = await prisma.collaboratorDocument.upsert({
     *   create: {
     *     // ... data to create a CollaboratorDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CollaboratorDocument we want to update
     *   }
     * })
    **/
    upsert<T extends CollaboratorDocumentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CollaboratorDocumentUpsertArgs<ExtArgs>>
    ): Prisma__CollaboratorDocumentClient<$Types.GetResult<CollaboratorDocumentPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of CollaboratorDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaboratorDocumentCountArgs} args - Arguments to filter CollaboratorDocuments to count.
     * @example
     * // Count the number of CollaboratorDocuments
     * const count = await prisma.collaboratorDocument.count({
     *   where: {
     *     // ... the filter for the CollaboratorDocuments we want to count
     *   }
     * })
    **/
    count<T extends CollaboratorDocumentCountArgs>(
      args?: Subset<T, CollaboratorDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CollaboratorDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CollaboratorDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaboratorDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CollaboratorDocumentAggregateArgs>(args: Subset<T, CollaboratorDocumentAggregateArgs>): Prisma.PrismaPromise<GetCollaboratorDocumentAggregateType<T>>

    /**
     * Group by CollaboratorDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaboratorDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CollaboratorDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CollaboratorDocumentGroupByArgs['orderBy'] }
        : { orderBy?: CollaboratorDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CollaboratorDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollaboratorDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CollaboratorDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CollaboratorDocumentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    collaborator<T extends CollaboratorArgs<ExtArgs> = {}>(args?: Subset<T, CollaboratorArgs<ExtArgs>>): Prisma__CollaboratorClient<$Types.GetResult<CollaboratorPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CollaboratorDocument base type for findUnique actions
   */
  export type CollaboratorDocumentFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollaboratorDocument
     */
    select?: CollaboratorDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorDocumentInclude<ExtArgs> | null
    /**
     * Filter, which CollaboratorDocument to fetch.
     */
    where: CollaboratorDocumentWhereUniqueInput
  }

  /**
   * CollaboratorDocument findUnique
   */
  export interface CollaboratorDocumentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CollaboratorDocumentFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CollaboratorDocument findUniqueOrThrow
   */
  export type CollaboratorDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollaboratorDocument
     */
    select?: CollaboratorDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorDocumentInclude<ExtArgs> | null
    /**
     * Filter, which CollaboratorDocument to fetch.
     */
    where: CollaboratorDocumentWhereUniqueInput
  }


  /**
   * CollaboratorDocument base type for findFirst actions
   */
  export type CollaboratorDocumentFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollaboratorDocument
     */
    select?: CollaboratorDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorDocumentInclude<ExtArgs> | null
    /**
     * Filter, which CollaboratorDocument to fetch.
     */
    where?: CollaboratorDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollaboratorDocuments to fetch.
     */
    orderBy?: Enumerable<CollaboratorDocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CollaboratorDocuments.
     */
    cursor?: CollaboratorDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollaboratorDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollaboratorDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CollaboratorDocuments.
     */
    distinct?: Enumerable<CollaboratorDocumentScalarFieldEnum>
  }

  /**
   * CollaboratorDocument findFirst
   */
  export interface CollaboratorDocumentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CollaboratorDocumentFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CollaboratorDocument findFirstOrThrow
   */
  export type CollaboratorDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollaboratorDocument
     */
    select?: CollaboratorDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorDocumentInclude<ExtArgs> | null
    /**
     * Filter, which CollaboratorDocument to fetch.
     */
    where?: CollaboratorDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollaboratorDocuments to fetch.
     */
    orderBy?: Enumerable<CollaboratorDocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CollaboratorDocuments.
     */
    cursor?: CollaboratorDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollaboratorDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollaboratorDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CollaboratorDocuments.
     */
    distinct?: Enumerable<CollaboratorDocumentScalarFieldEnum>
  }


  /**
   * CollaboratorDocument findMany
   */
  export type CollaboratorDocumentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollaboratorDocument
     */
    select?: CollaboratorDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorDocumentInclude<ExtArgs> | null
    /**
     * Filter, which CollaboratorDocuments to fetch.
     */
    where?: CollaboratorDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollaboratorDocuments to fetch.
     */
    orderBy?: Enumerable<CollaboratorDocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CollaboratorDocuments.
     */
    cursor?: CollaboratorDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollaboratorDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollaboratorDocuments.
     */
    skip?: number
    distinct?: Enumerable<CollaboratorDocumentScalarFieldEnum>
  }


  /**
   * CollaboratorDocument create
   */
  export type CollaboratorDocumentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollaboratorDocument
     */
    select?: CollaboratorDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a CollaboratorDocument.
     */
    data: XOR<CollaboratorDocumentCreateInput, CollaboratorDocumentUncheckedCreateInput>
  }


  /**
   * CollaboratorDocument createMany
   */
  export type CollaboratorDocumentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CollaboratorDocuments.
     */
    data: Enumerable<CollaboratorDocumentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CollaboratorDocument update
   */
  export type CollaboratorDocumentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollaboratorDocument
     */
    select?: CollaboratorDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a CollaboratorDocument.
     */
    data: XOR<CollaboratorDocumentUpdateInput, CollaboratorDocumentUncheckedUpdateInput>
    /**
     * Choose, which CollaboratorDocument to update.
     */
    where: CollaboratorDocumentWhereUniqueInput
  }


  /**
   * CollaboratorDocument updateMany
   */
  export type CollaboratorDocumentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CollaboratorDocuments.
     */
    data: XOR<CollaboratorDocumentUpdateManyMutationInput, CollaboratorDocumentUncheckedUpdateManyInput>
    /**
     * Filter which CollaboratorDocuments to update
     */
    where?: CollaboratorDocumentWhereInput
  }


  /**
   * CollaboratorDocument upsert
   */
  export type CollaboratorDocumentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollaboratorDocument
     */
    select?: CollaboratorDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the CollaboratorDocument to update in case it exists.
     */
    where: CollaboratorDocumentWhereUniqueInput
    /**
     * In case the CollaboratorDocument found by the `where` argument doesn't exist, create a new CollaboratorDocument with this data.
     */
    create: XOR<CollaboratorDocumentCreateInput, CollaboratorDocumentUncheckedCreateInput>
    /**
     * In case the CollaboratorDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CollaboratorDocumentUpdateInput, CollaboratorDocumentUncheckedUpdateInput>
  }


  /**
   * CollaboratorDocument delete
   */
  export type CollaboratorDocumentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollaboratorDocument
     */
    select?: CollaboratorDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorDocumentInclude<ExtArgs> | null
    /**
     * Filter which CollaboratorDocument to delete.
     */
    where: CollaboratorDocumentWhereUniqueInput
  }


  /**
   * CollaboratorDocument deleteMany
   */
  export type CollaboratorDocumentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CollaboratorDocuments to delete
     */
    where?: CollaboratorDocumentWhereInput
  }


  /**
   * CollaboratorDocument without action
   */
  export type CollaboratorDocumentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollaboratorDocument
     */
    select?: CollaboratorDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorDocumentInclude<ExtArgs> | null
  }



  /**
   * Model Reward
   */


  export type AggregateReward = {
    _count: RewardCountAggregateOutputType | null
    _min: RewardMinAggregateOutputType | null
    _max: RewardMaxAggregateOutputType | null
  }

  export type RewardMinAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    descrition: string | null
    image: string | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RewardMaxAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    descrition: string | null
    image: string | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RewardCountAggregateOutputType = {
    id: number
    name: number
    url: number
    descrition: number
    image: number
    isDeprecated: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RewardMinAggregateInputType = {
    id?: true
    name?: true
    url?: true
    descrition?: true
    image?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RewardMaxAggregateInputType = {
    id?: true
    name?: true
    url?: true
    descrition?: true
    image?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RewardCountAggregateInputType = {
    id?: true
    name?: true
    url?: true
    descrition?: true
    image?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RewardAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reward to aggregate.
     */
    where?: RewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rewards to fetch.
     */
    orderBy?: Enumerable<RewardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rewards
    **/
    _count?: true | RewardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RewardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RewardMaxAggregateInputType
  }

  export type GetRewardAggregateType<T extends RewardAggregateArgs> = {
        [P in keyof T & keyof AggregateReward]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReward[P]>
      : GetScalarType<T[P], AggregateReward[P]>
  }




  export type RewardGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: RewardWhereInput
    orderBy?: Enumerable<RewardOrderByWithAggregationInput>
    by: RewardScalarFieldEnum[]
    having?: RewardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RewardCountAggregateInputType | true
    _min?: RewardMinAggregateInputType
    _max?: RewardMaxAggregateInputType
  }


  export type RewardGroupByOutputType = {
    id: string
    name: string
    url: string
    descrition: string
    image: string
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
    _count: RewardCountAggregateOutputType | null
    _min: RewardMinAggregateOutputType | null
    _max: RewardMaxAggregateOutputType | null
  }

  type GetRewardGroupByPayload<T extends RewardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RewardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RewardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RewardGroupByOutputType[P]>
            : GetScalarType<T[P], RewardGroupByOutputType[P]>
        }
      >
    >


  export type RewardSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    descrition?: boolean
    image?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["reward"]>

  export type RewardSelectScalar = {
    id?: boolean
    name?: boolean
    url?: boolean
    descrition?: boolean
    image?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  type RewardGetPayload<S extends boolean | null | undefined | RewardArgs> = $Types.GetResult<RewardPayload, S>

  type RewardCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<RewardFindManyArgs, 'select' | 'include'> & {
      select?: RewardCountAggregateInputType | true
    }

  export interface RewardDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reward'], meta: { name: 'Reward' } }
    /**
     * Find zero or one Reward that matches the filter.
     * @param {RewardFindUniqueArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RewardFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RewardFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Reward'> extends True ? Prisma__RewardClient<$Types.GetResult<RewardPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__RewardClient<$Types.GetResult<RewardPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Reward that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RewardFindUniqueOrThrowArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RewardFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RewardFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RewardClient<$Types.GetResult<RewardPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Reward that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardFindFirstArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RewardFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RewardFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Reward'> extends True ? Prisma__RewardClient<$Types.GetResult<RewardPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__RewardClient<$Types.GetResult<RewardPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Reward that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardFindFirstOrThrowArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RewardFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RewardFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RewardClient<$Types.GetResult<RewardPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Rewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rewards
     * const rewards = await prisma.reward.findMany()
     * 
     * // Get first 10 Rewards
     * const rewards = await prisma.reward.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rewardWithIdOnly = await prisma.reward.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RewardFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RewardFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<RewardPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Reward.
     * @param {RewardCreateArgs} args - Arguments to create a Reward.
     * @example
     * // Create one Reward
     * const Reward = await prisma.reward.create({
     *   data: {
     *     // ... data to create a Reward
     *   }
     * })
     * 
    **/
    create<T extends RewardCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RewardCreateArgs<ExtArgs>>
    ): Prisma__RewardClient<$Types.GetResult<RewardPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Rewards.
     *     @param {RewardCreateManyArgs} args - Arguments to create many Rewards.
     *     @example
     *     // Create many Rewards
     *     const reward = await prisma.reward.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RewardCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RewardCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Reward.
     * @param {RewardDeleteArgs} args - Arguments to delete one Reward.
     * @example
     * // Delete one Reward
     * const Reward = await prisma.reward.delete({
     *   where: {
     *     // ... filter to delete one Reward
     *   }
     * })
     * 
    **/
    delete<T extends RewardDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RewardDeleteArgs<ExtArgs>>
    ): Prisma__RewardClient<$Types.GetResult<RewardPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Reward.
     * @param {RewardUpdateArgs} args - Arguments to update one Reward.
     * @example
     * // Update one Reward
     * const reward = await prisma.reward.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RewardUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RewardUpdateArgs<ExtArgs>>
    ): Prisma__RewardClient<$Types.GetResult<RewardPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Rewards.
     * @param {RewardDeleteManyArgs} args - Arguments to filter Rewards to delete.
     * @example
     * // Delete a few Rewards
     * const { count } = await prisma.reward.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RewardDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RewardDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rewards
     * const reward = await prisma.reward.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RewardUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RewardUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reward.
     * @param {RewardUpsertArgs} args - Arguments to update or create a Reward.
     * @example
     * // Update or create a Reward
     * const reward = await prisma.reward.upsert({
     *   create: {
     *     // ... data to create a Reward
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reward we want to update
     *   }
     * })
    **/
    upsert<T extends RewardUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RewardUpsertArgs<ExtArgs>>
    ): Prisma__RewardClient<$Types.GetResult<RewardPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardCountArgs} args - Arguments to filter Rewards to count.
     * @example
     * // Count the number of Rewards
     * const count = await prisma.reward.count({
     *   where: {
     *     // ... the filter for the Rewards we want to count
     *   }
     * })
    **/
    count<T extends RewardCountArgs>(
      args?: Subset<T, RewardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RewardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RewardAggregateArgs>(args: Subset<T, RewardAggregateArgs>): Prisma.PrismaPromise<GetRewardAggregateType<T>>

    /**
     * Group by Reward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RewardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RewardGroupByArgs['orderBy'] }
        : { orderBy?: RewardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RewardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRewardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Reward.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RewardClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Reward base type for findUnique actions
   */
  export type RewardFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Filter, which Reward to fetch.
     */
    where: RewardWhereUniqueInput
  }

  /**
   * Reward findUnique
   */
  export interface RewardFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends RewardFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Reward findUniqueOrThrow
   */
  export type RewardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Filter, which Reward to fetch.
     */
    where: RewardWhereUniqueInput
  }


  /**
   * Reward base type for findFirst actions
   */
  export type RewardFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Filter, which Reward to fetch.
     */
    where?: RewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rewards to fetch.
     */
    orderBy?: Enumerable<RewardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rewards.
     */
    cursor?: RewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rewards.
     */
    distinct?: Enumerable<RewardScalarFieldEnum>
  }

  /**
   * Reward findFirst
   */
  export interface RewardFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends RewardFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Reward findFirstOrThrow
   */
  export type RewardFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Filter, which Reward to fetch.
     */
    where?: RewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rewards to fetch.
     */
    orderBy?: Enumerable<RewardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rewards.
     */
    cursor?: RewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rewards.
     */
    distinct?: Enumerable<RewardScalarFieldEnum>
  }


  /**
   * Reward findMany
   */
  export type RewardFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Filter, which Rewards to fetch.
     */
    where?: RewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rewards to fetch.
     */
    orderBy?: Enumerable<RewardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rewards.
     */
    cursor?: RewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rewards.
     */
    skip?: number
    distinct?: Enumerable<RewardScalarFieldEnum>
  }


  /**
   * Reward create
   */
  export type RewardCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * The data needed to create a Reward.
     */
    data: XOR<RewardCreateInput, RewardUncheckedCreateInput>
  }


  /**
   * Reward createMany
   */
  export type RewardCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rewards.
     */
    data: Enumerable<RewardCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Reward update
   */
  export type RewardUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * The data needed to update a Reward.
     */
    data: XOR<RewardUpdateInput, RewardUncheckedUpdateInput>
    /**
     * Choose, which Reward to update.
     */
    where: RewardWhereUniqueInput
  }


  /**
   * Reward updateMany
   */
  export type RewardUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rewards.
     */
    data: XOR<RewardUpdateManyMutationInput, RewardUncheckedUpdateManyInput>
    /**
     * Filter which Rewards to update
     */
    where?: RewardWhereInput
  }


  /**
   * Reward upsert
   */
  export type RewardUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * The filter to search for the Reward to update in case it exists.
     */
    where: RewardWhereUniqueInput
    /**
     * In case the Reward found by the `where` argument doesn't exist, create a new Reward with this data.
     */
    create: XOR<RewardCreateInput, RewardUncheckedCreateInput>
    /**
     * In case the Reward was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RewardUpdateInput, RewardUncheckedUpdateInput>
  }


  /**
   * Reward delete
   */
  export type RewardDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Filter which Reward to delete.
     */
    where: RewardWhereUniqueInput
  }


  /**
   * Reward deleteMany
   */
  export type RewardDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rewards to delete
     */
    where?: RewardWhereInput
  }


  /**
   * Reward without action
   */
  export type RewardArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
  }



  /**
   * Model Country
   */


  export type AggregateCountry = {
    _count: CountryCountAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  export type CountryMinAggregateOutputType = {
    id: string | null
    name: string | null
    iso: string | null
    currency: string | null
    code: string | null
    flagUrl: string | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CountryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    iso: string | null
    currency: string | null
    code: string | null
    flagUrl: string | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CountryCountAggregateOutputType = {
    id: number
    name: number
    iso: number
    currency: number
    code: number
    flagUrl: number
    isDeprecated: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CountryMinAggregateInputType = {
    id?: true
    name?: true
    iso?: true
    currency?: true
    code?: true
    flagUrl?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CountryMaxAggregateInputType = {
    id?: true
    name?: true
    iso?: true
    currency?: true
    code?: true
    flagUrl?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CountryCountAggregateInputType = {
    id?: true
    name?: true
    iso?: true
    currency?: true
    code?: true
    flagUrl?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CountryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Country to aggregate.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: Enumerable<CountryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Countries
    **/
    _count?: true | CountryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountryMaxAggregateInputType
  }

  export type GetCountryAggregateType<T extends CountryAggregateArgs> = {
        [P in keyof T & keyof AggregateCountry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountry[P]>
      : GetScalarType<T[P], AggregateCountry[P]>
  }




  export type CountryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CountryWhereInput
    orderBy?: Enumerable<CountryOrderByWithAggregationInput>
    by: CountryScalarFieldEnum[]
    having?: CountryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountryCountAggregateInputType | true
    _min?: CountryMinAggregateInputType
    _max?: CountryMaxAggregateInputType
  }


  export type CountryGroupByOutputType = {
    id: string
    name: string
    iso: string
    currency: string
    code: string
    flagUrl: string
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
    _count: CountryCountAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  type GetCountryGroupByPayload<T extends CountryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CountryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountryGroupByOutputType[P]>
            : GetScalarType<T[P], CountryGroupByOutputType[P]>
        }
      >
    >


  export type CountrySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    iso?: boolean
    currency?: boolean
    code?: boolean
    flagUrl?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["country"]>

  export type CountrySelectScalar = {
    id?: boolean
    name?: boolean
    iso?: boolean
    currency?: boolean
    code?: boolean
    flagUrl?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  type CountryGetPayload<S extends boolean | null | undefined | CountryArgs> = $Types.GetResult<CountryPayload, S>

  type CountryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CountryFindManyArgs, 'select' | 'include'> & {
      select?: CountryCountAggregateInputType | true
    }

  export interface CountryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Country'], meta: { name: 'Country' } }
    /**
     * Find zero or one Country that matches the filter.
     * @param {CountryFindUniqueArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CountryFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CountryFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Country'> extends True ? Prisma__CountryClient<$Types.GetResult<CountryPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__CountryClient<$Types.GetResult<CountryPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Country that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CountryFindUniqueOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CountryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CountryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CountryClient<$Types.GetResult<CountryPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Country that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CountryFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CountryFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Country'> extends True ? Prisma__CountryClient<$Types.GetResult<CountryPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__CountryClient<$Types.GetResult<CountryPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Country that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CountryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CountryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CountryClient<$Types.GetResult<CountryPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.country.findMany()
     * 
     * // Get first 10 Countries
     * const countries = await prisma.country.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const countryWithIdOnly = await prisma.country.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CountryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CountryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<CountryPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Country.
     * @param {CountryCreateArgs} args - Arguments to create a Country.
     * @example
     * // Create one Country
     * const Country = await prisma.country.create({
     *   data: {
     *     // ... data to create a Country
     *   }
     * })
     * 
    **/
    create<T extends CountryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CountryCreateArgs<ExtArgs>>
    ): Prisma__CountryClient<$Types.GetResult<CountryPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Countries.
     *     @param {CountryCreateManyArgs} args - Arguments to create many Countries.
     *     @example
     *     // Create many Countries
     *     const country = await prisma.country.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CountryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CountryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Country.
     * @param {CountryDeleteArgs} args - Arguments to delete one Country.
     * @example
     * // Delete one Country
     * const Country = await prisma.country.delete({
     *   where: {
     *     // ... filter to delete one Country
     *   }
     * })
     * 
    **/
    delete<T extends CountryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CountryDeleteArgs<ExtArgs>>
    ): Prisma__CountryClient<$Types.GetResult<CountryPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Country.
     * @param {CountryUpdateArgs} args - Arguments to update one Country.
     * @example
     * // Update one Country
     * const country = await prisma.country.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CountryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CountryUpdateArgs<ExtArgs>>
    ): Prisma__CountryClient<$Types.GetResult<CountryPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Countries.
     * @param {CountryDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.country.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CountryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CountryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CountryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CountryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Country.
     * @param {CountryUpsertArgs} args - Arguments to update or create a Country.
     * @example
     * // Update or create a Country
     * const country = await prisma.country.upsert({
     *   create: {
     *     // ... data to create a Country
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Country we want to update
     *   }
     * })
    **/
    upsert<T extends CountryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CountryUpsertArgs<ExtArgs>>
    ): Prisma__CountryClient<$Types.GetResult<CountryPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.country.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends CountryCountArgs>(
      args?: Subset<T, CountryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountryAggregateArgs>(args: Subset<T, CountryAggregateArgs>): Prisma.PrismaPromise<GetCountryAggregateType<T>>

    /**
     * Group by Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountryGroupByArgs['orderBy'] }
        : { orderBy?: CountryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Country.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CountryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Country base type for findUnique actions
   */
  export type CountryFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findUnique
   */
  export interface CountryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CountryFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Country findUniqueOrThrow
   */
  export type CountryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }


  /**
   * Country base type for findFirst actions
   */
  export type CountryFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: Enumerable<CountryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: Enumerable<CountryScalarFieldEnum>
  }

  /**
   * Country findFirst
   */
  export interface CountryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CountryFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Country findFirstOrThrow
   */
  export type CountryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: Enumerable<CountryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: Enumerable<CountryScalarFieldEnum>
  }


  /**
   * Country findMany
   */
  export type CountryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Filter, which Countries to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: Enumerable<CountryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    distinct?: Enumerable<CountryScalarFieldEnum>
  }


  /**
   * Country create
   */
  export type CountryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * The data needed to create a Country.
     */
    data: XOR<CountryCreateInput, CountryUncheckedCreateInput>
  }


  /**
   * Country createMany
   */
  export type CountryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Countries.
     */
    data: Enumerable<CountryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Country update
   */
  export type CountryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * The data needed to update a Country.
     */
    data: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
    /**
     * Choose, which Country to update.
     */
    where: CountryWhereUniqueInput
  }


  /**
   * Country updateMany
   */
  export type CountryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Countries.
     */
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyInput>
    /**
     * Filter which Countries to update
     */
    where?: CountryWhereInput
  }


  /**
   * Country upsert
   */
  export type CountryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * The filter to search for the Country to update in case it exists.
     */
    where: CountryWhereUniqueInput
    /**
     * In case the Country found by the `where` argument doesn't exist, create a new Country with this data.
     */
    create: XOR<CountryCreateInput, CountryUncheckedCreateInput>
    /**
     * In case the Country was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
  }


  /**
   * Country delete
   */
  export type CountryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Filter which Country to delete.
     */
    where: CountryWhereUniqueInput
  }


  /**
   * Country deleteMany
   */
  export type CountryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Countries to delete
     */
    where?: CountryWhereInput
  }


  /**
   * Country without action
   */
  export type CountryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
  }



  /**
   * Model Bank
   */


  export type AggregateBank = {
    _count: BankCountAggregateOutputType | null
    _min: BankMinAggregateOutputType | null
    _max: BankMaxAggregateOutputType | null
  }

  export type BankMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    url: string | null
    image: string | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    url: string | null
    image: string | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankCountAggregateOutputType = {
    id: number
    name: number
    code: number
    url: number
    image: number
    isDeprecated: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BankMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    url?: true
    image?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    url?: true
    image?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    url?: true
    image?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BankAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bank to aggregate.
     */
    where?: BankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banks to fetch.
     */
    orderBy?: Enumerable<BankOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Banks
    **/
    _count?: true | BankCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BankMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BankMaxAggregateInputType
  }

  export type GetBankAggregateType<T extends BankAggregateArgs> = {
        [P in keyof T & keyof AggregateBank]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBank[P]>
      : GetScalarType<T[P], AggregateBank[P]>
  }




  export type BankGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BankWhereInput
    orderBy?: Enumerable<BankOrderByWithAggregationInput>
    by: BankScalarFieldEnum[]
    having?: BankScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BankCountAggregateInputType | true
    _min?: BankMinAggregateInputType
    _max?: BankMaxAggregateInputType
  }


  export type BankGroupByOutputType = {
    id: string
    name: string
    code: string
    url: string
    image: string
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
    _count: BankCountAggregateOutputType | null
    _min: BankMinAggregateOutputType | null
    _max: BankMaxAggregateOutputType | null
  }

  type GetBankGroupByPayload<T extends BankGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BankGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BankGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BankGroupByOutputType[P]>
            : GetScalarType<T[P], BankGroupByOutputType[P]>
        }
      >
    >


  export type BankSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    url?: boolean
    image?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["bank"]>

  export type BankSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    url?: boolean
    image?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  type BankGetPayload<S extends boolean | null | undefined | BankArgs> = $Types.GetResult<BankPayload, S>

  type BankCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<BankFindManyArgs, 'select' | 'include'> & {
      select?: BankCountAggregateInputType | true
    }

  export interface BankDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bank'], meta: { name: 'Bank' } }
    /**
     * Find zero or one Bank that matches the filter.
     * @param {BankFindUniqueArgs} args - Arguments to find a Bank
     * @example
     * // Get one Bank
     * const bank = await prisma.bank.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BankFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BankFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Bank'> extends True ? Prisma__BankClient<$Types.GetResult<BankPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__BankClient<$Types.GetResult<BankPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Bank that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BankFindUniqueOrThrowArgs} args - Arguments to find a Bank
     * @example
     * // Get one Bank
     * const bank = await prisma.bank.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BankFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BankFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BankClient<$Types.GetResult<BankPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Bank that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankFindFirstArgs} args - Arguments to find a Bank
     * @example
     * // Get one Bank
     * const bank = await prisma.bank.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BankFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BankFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Bank'> extends True ? Prisma__BankClient<$Types.GetResult<BankPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__BankClient<$Types.GetResult<BankPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Bank that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankFindFirstOrThrowArgs} args - Arguments to find a Bank
     * @example
     * // Get one Bank
     * const bank = await prisma.bank.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BankFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BankFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BankClient<$Types.GetResult<BankPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Banks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Banks
     * const banks = await prisma.bank.findMany()
     * 
     * // Get first 10 Banks
     * const banks = await prisma.bank.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bankWithIdOnly = await prisma.bank.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BankFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BankFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<BankPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Bank.
     * @param {BankCreateArgs} args - Arguments to create a Bank.
     * @example
     * // Create one Bank
     * const Bank = await prisma.bank.create({
     *   data: {
     *     // ... data to create a Bank
     *   }
     * })
     * 
    **/
    create<T extends BankCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BankCreateArgs<ExtArgs>>
    ): Prisma__BankClient<$Types.GetResult<BankPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Banks.
     *     @param {BankCreateManyArgs} args - Arguments to create many Banks.
     *     @example
     *     // Create many Banks
     *     const bank = await prisma.bank.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BankCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BankCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bank.
     * @param {BankDeleteArgs} args - Arguments to delete one Bank.
     * @example
     * // Delete one Bank
     * const Bank = await prisma.bank.delete({
     *   where: {
     *     // ... filter to delete one Bank
     *   }
     * })
     * 
    **/
    delete<T extends BankDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BankDeleteArgs<ExtArgs>>
    ): Prisma__BankClient<$Types.GetResult<BankPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Bank.
     * @param {BankUpdateArgs} args - Arguments to update one Bank.
     * @example
     * // Update one Bank
     * const bank = await prisma.bank.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BankUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BankUpdateArgs<ExtArgs>>
    ): Prisma__BankClient<$Types.GetResult<BankPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Banks.
     * @param {BankDeleteManyArgs} args - Arguments to filter Banks to delete.
     * @example
     * // Delete a few Banks
     * const { count } = await prisma.bank.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BankDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BankDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Banks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Banks
     * const bank = await prisma.bank.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BankUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BankUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bank.
     * @param {BankUpsertArgs} args - Arguments to update or create a Bank.
     * @example
     * // Update or create a Bank
     * const bank = await prisma.bank.upsert({
     *   create: {
     *     // ... data to create a Bank
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bank we want to update
     *   }
     * })
    **/
    upsert<T extends BankUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BankUpsertArgs<ExtArgs>>
    ): Prisma__BankClient<$Types.GetResult<BankPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Banks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankCountArgs} args - Arguments to filter Banks to count.
     * @example
     * // Count the number of Banks
     * const count = await prisma.bank.count({
     *   where: {
     *     // ... the filter for the Banks we want to count
     *   }
     * })
    **/
    count<T extends BankCountArgs>(
      args?: Subset<T, BankCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BankCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bank.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BankAggregateArgs>(args: Subset<T, BankAggregateArgs>): Prisma.PrismaPromise<GetBankAggregateType<T>>

    /**
     * Group by Bank.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BankGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BankGroupByArgs['orderBy'] }
        : { orderBy?: BankGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BankGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBankGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Bank.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BankClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Bank base type for findUnique actions
   */
  export type BankFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
    /**
     * Filter, which Bank to fetch.
     */
    where: BankWhereUniqueInput
  }

  /**
   * Bank findUnique
   */
  export interface BankFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BankFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Bank findUniqueOrThrow
   */
  export type BankFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
    /**
     * Filter, which Bank to fetch.
     */
    where: BankWhereUniqueInput
  }


  /**
   * Bank base type for findFirst actions
   */
  export type BankFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
    /**
     * Filter, which Bank to fetch.
     */
    where?: BankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banks to fetch.
     */
    orderBy?: Enumerable<BankOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Banks.
     */
    cursor?: BankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Banks.
     */
    distinct?: Enumerable<BankScalarFieldEnum>
  }

  /**
   * Bank findFirst
   */
  export interface BankFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BankFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Bank findFirstOrThrow
   */
  export type BankFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
    /**
     * Filter, which Bank to fetch.
     */
    where?: BankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banks to fetch.
     */
    orderBy?: Enumerable<BankOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Banks.
     */
    cursor?: BankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Banks.
     */
    distinct?: Enumerable<BankScalarFieldEnum>
  }


  /**
   * Bank findMany
   */
  export type BankFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
    /**
     * Filter, which Banks to fetch.
     */
    where?: BankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banks to fetch.
     */
    orderBy?: Enumerable<BankOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Banks.
     */
    cursor?: BankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banks.
     */
    skip?: number
    distinct?: Enumerable<BankScalarFieldEnum>
  }


  /**
   * Bank create
   */
  export type BankCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
    /**
     * The data needed to create a Bank.
     */
    data: XOR<BankCreateInput, BankUncheckedCreateInput>
  }


  /**
   * Bank createMany
   */
  export type BankCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Banks.
     */
    data: Enumerable<BankCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Bank update
   */
  export type BankUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
    /**
     * The data needed to update a Bank.
     */
    data: XOR<BankUpdateInput, BankUncheckedUpdateInput>
    /**
     * Choose, which Bank to update.
     */
    where: BankWhereUniqueInput
  }


  /**
   * Bank updateMany
   */
  export type BankUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Banks.
     */
    data: XOR<BankUpdateManyMutationInput, BankUncheckedUpdateManyInput>
    /**
     * Filter which Banks to update
     */
    where?: BankWhereInput
  }


  /**
   * Bank upsert
   */
  export type BankUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
    /**
     * The filter to search for the Bank to update in case it exists.
     */
    where: BankWhereUniqueInput
    /**
     * In case the Bank found by the `where` argument doesn't exist, create a new Bank with this data.
     */
    create: XOR<BankCreateInput, BankUncheckedCreateInput>
    /**
     * In case the Bank was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BankUpdateInput, BankUncheckedUpdateInput>
  }


  /**
   * Bank delete
   */
  export type BankDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
    /**
     * Filter which Bank to delete.
     */
    where: BankWhereUniqueInput
  }


  /**
   * Bank deleteMany
   */
  export type BankDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Banks to delete
     */
    where?: BankWhereInput
  }


  /**
   * Bank without action
   */
  export type BankArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
  }



  /**
   * Model Notification
   */


  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    title: string | null
    body: string | null
    readStatus: boolean | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    title: string | null
    body: string | null
    readStatus: boolean | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    title: number
    body: number
    readStatus: number
    isDeprecated: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    title?: true
    body?: true
    readStatus?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    title?: true
    body?: true
    readStatus?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    title?: true
    body?: true
    readStatus?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: Enumerable<NotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: Enumerable<NotificationOrderByWithAggregationInput>
    by: NotificationScalarFieldEnum[]
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }


  export type NotificationGroupByOutputType = {
    id: string
    title: string
    body: string
    readStatus: boolean
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    body?: boolean
    readStatus?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    title?: boolean
    body?: boolean
    readStatus?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  type NotificationGetPayload<S extends boolean | null | undefined | NotificationArgs> = $Types.GetResult<NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NotificationFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Notification'> extends True ? Prisma__NotificationClient<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__NotificationClient<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NotificationFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Notification'> extends True ? Prisma__NotificationClient<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__NotificationClient<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NotificationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
    **/
    create<T extends NotificationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Notifications.
     *     @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     *     @example
     *     // Create many Notifications
     *     const notification = await prisma.notification.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NotificationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
    **/
    delete<T extends NotificationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NotificationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NotificationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NotificationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
    **/
    upsert<T extends NotificationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Notification base type for findUnique actions
   */
  export type NotificationFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUnique
   */
  export interface NotificationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends NotificationFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification base type for findFirst actions
   */
  export type NotificationFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: Enumerable<NotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }

  /**
   * Notification findFirst
   */
  export interface NotificationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends NotificationFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: Enumerable<NotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }


  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: Enumerable<NotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }


  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }


  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: Enumerable<NotificationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }


  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }


  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }


  /**
   * Notification without action
   */
  export type NotificationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
  }



  /**
   * Model Account
   */


  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    scope: string | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    scope: string | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    scope: number
    isDeprecated: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    scope?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    scope?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    scope?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: Enumerable<AccountOrderByWithAggregationInput>
    by: AccountScalarFieldEnum[]
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }


  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    scope: string
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    scope?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    scope?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type AccountGetPayload<S extends boolean | null | undefined | AccountArgs> = $Types.GetResult<AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AccountFindManyArgs, 'select' | 'include'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccountFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Account'> extends True ? Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Account that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccountFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Account'> extends True ? Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Account that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AccountFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
    **/
    create<T extends AccountCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AccountCreateArgs<ExtArgs>>
    ): Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Accounts.
     *     @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     *     @example
     *     // Create many Accounts
     *     const account = await prisma.account.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AccountCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
    **/
    delete<T extends AccountDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>
    ): Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccountUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>
    ): Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccountDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccountUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
    **/
    upsert<T extends AccountUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>
    ): Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Account base type for findUnique actions
   */
  export type AccountFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUnique
   */
  export interface AccountFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AccountFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account base type for findFirst actions
   */
  export type AccountFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: Enumerable<AccountScalarFieldEnum>
  }

  /**
   * Account findFirst
   */
  export interface AccountFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AccountFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: Enumerable<AccountScalarFieldEnum>
  }


  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: Enumerable<AccountScalarFieldEnum>
  }


  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }


  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: Enumerable<AccountCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
  }


  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }


  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
  }


  /**
   * Account without action
   */
  export type AccountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    fullName: string | null
    username: string | null
    email: string | null
    password: string | null
    googleId: string | null
    phone: string | null
    picture: string | null
    isVerified: boolean | null
    referral: string | null
    country: string | null
    resetToken: string | null
    isPartner: boolean | null
    isStaff: boolean | null
    isPhoneRegistered: boolean | null
    isPhoneVerified: boolean | null
    isIdentificationRegistered: boolean | null
    isIdentificationVerified: boolean | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    fullName: string | null
    username: string | null
    email: string | null
    password: string | null
    googleId: string | null
    phone: string | null
    picture: string | null
    isVerified: boolean | null
    referral: string | null
    country: string | null
    resetToken: string | null
    isPartner: boolean | null
    isStaff: boolean | null
    isPhoneRegistered: boolean | null
    isPhoneVerified: boolean | null
    isIdentificationRegistered: boolean | null
    isIdentificationVerified: boolean | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    fullName: number
    username: number
    email: number
    password: number
    googleId: number
    phone: number
    picture: number
    isVerified: number
    referral: number
    country: number
    resetToken: number
    isPartner: number
    isStaff: number
    isPhoneRegistered: number
    isPhoneVerified: number
    isIdentificationRegistered: number
    isIdentificationVerified: number
    partnerPermission: number
    staffPermission: number
    userPermission: number
    isDeprecated: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    fullName?: true
    username?: true
    email?: true
    password?: true
    googleId?: true
    phone?: true
    picture?: true
    isVerified?: true
    referral?: true
    country?: true
    resetToken?: true
    isPartner?: true
    isStaff?: true
    isPhoneRegistered?: true
    isPhoneVerified?: true
    isIdentificationRegistered?: true
    isIdentificationVerified?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    fullName?: true
    username?: true
    email?: true
    password?: true
    googleId?: true
    phone?: true
    picture?: true
    isVerified?: true
    referral?: true
    country?: true
    resetToken?: true
    isPartner?: true
    isStaff?: true
    isPhoneRegistered?: true
    isPhoneVerified?: true
    isIdentificationRegistered?: true
    isIdentificationVerified?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    fullName?: true
    username?: true
    email?: true
    password?: true
    googleId?: true
    phone?: true
    picture?: true
    isVerified?: true
    referral?: true
    country?: true
    resetToken?: true
    isPartner?: true
    isStaff?: true
    isPhoneRegistered?: true
    isPhoneVerified?: true
    isIdentificationRegistered?: true
    isIdentificationVerified?: true
    partnerPermission?: true
    staffPermission?: true
    userPermission?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    fullName: string
    username: string | null
    email: string
    password: string | null
    googleId: string | null
    phone: string | null
    picture: string | null
    isVerified: boolean
    referral: string | null
    country: string | null
    resetToken: string | null
    isPartner: boolean
    isStaff: boolean
    isPhoneRegistered: boolean
    isPhoneVerified: boolean
    isIdentificationRegistered: boolean
    isIdentificationVerified: boolean
    partnerPermission: string[]
    staffPermission: string[]
    userPermission: string[]
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    googleId?: boolean
    phone?: boolean
    picture?: boolean
    isVerified?: boolean
    referral?: boolean
    country?: boolean
    resetToken?: boolean
    isPartner?: boolean
    isStaff?: boolean
    isPhoneRegistered?: boolean
    isPhoneVerified?: boolean
    isIdentificationRegistered?: boolean
    isIdentificationVerified?: boolean
    partnerPermission?: boolean
    staffPermission?: boolean
    userPermission?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teamMember?: boolean | User$teamMemberArgs<ExtArgs>
    account?: boolean | User$accountArgs<ExtArgs>
    productRequest?: boolean | User$productRequestArgs<ExtArgs>
    document?: boolean | User$documentArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    fullName?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    googleId?: boolean
    phone?: boolean
    picture?: boolean
    isVerified?: boolean
    referral?: boolean
    country?: boolean
    resetToken?: boolean
    isPartner?: boolean
    isStaff?: boolean
    isPhoneRegistered?: boolean
    isPhoneVerified?: boolean
    isIdentificationRegistered?: boolean
    isIdentificationVerified?: boolean
    partnerPermission?: boolean
    staffPermission?: boolean
    userPermission?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    teamMember?: boolean | User$teamMemberArgs<ExtArgs>
    account?: boolean | User$accountArgs<ExtArgs>
    productRequest?: boolean | User$productRequestArgs<ExtArgs>
    document?: boolean | User$documentArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeArgs<ExtArgs>
  }


  type UserGetPayload<S extends boolean | null | undefined | UserArgs> = $Types.GetResult<UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<UserPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    teamMember<T extends User$teamMemberArgs<ExtArgs> = {}>(args?: Subset<T, User$teamMemberArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<TeamMemberPayload<ExtArgs>, T, 'findMany', never>| Null>;

    account<T extends User$accountArgs<ExtArgs> = {}>(args?: Subset<T, User$accountArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findMany', never>| Null>;

    productRequest<T extends User$productRequestArgs<ExtArgs> = {}>(args?: Subset<T, User$productRequestArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ProductRequestPayload<ExtArgs>, T, 'findMany', never>| Null>;

    document<T extends User$documentArgs<ExtArgs> = {}>(args?: Subset<T, User$documentArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<UserDocumentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUnique
   */
  export interface UserFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User findFirst
   */
  export interface UserFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.teamMember
   */
  export type User$teamMemberArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamMemberInclude<ExtArgs> | null
    where?: TeamMemberWhereInput
    orderBy?: Enumerable<TeamMemberOrderByWithRelationInput>
    cursor?: TeamMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TeamMemberScalarFieldEnum>
  }


  /**
   * User.account
   */
  export type User$accountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AccountScalarFieldEnum>
  }


  /**
   * User.productRequest
   */
  export type User$productRequestArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRequest
     */
    select?: ProductRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductRequestInclude<ExtArgs> | null
    where?: ProductRequestWhereInput
    orderBy?: Enumerable<ProductRequestOrderByWithRelationInput>
    cursor?: ProductRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductRequestScalarFieldEnum>
  }


  /**
   * User.document
   */
  export type User$documentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocument
     */
    select?: UserDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserDocumentInclude<ExtArgs> | null
    where?: UserDocumentWhereInput
    orderBy?: Enumerable<UserDocumentOrderByWithRelationInput>
    cursor?: UserDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserDocumentScalarFieldEnum>
  }


  /**
   * User without action
   */
  export type UserArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model UserDocument
   */


  export type AggregateUserDocument = {
    _count: UserDocumentCountAggregateOutputType | null
    _min: UserDocumentMinAggregateOutputType | null
    _max: UserDocumentMaxAggregateOutputType | null
  }

  export type UserDocumentMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    link: string | null
    size: string | null
    belongsTo: string | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type UserDocumentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    link: string | null
    size: string | null
    belongsTo: string | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type UserDocumentCountAggregateOutputType = {
    id: number
    name: number
    type: number
    link: number
    size: number
    belongsTo: number
    isDeprecated: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type UserDocumentMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    link?: true
    size?: true
    belongsTo?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type UserDocumentMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    link?: true
    size?: true
    belongsTo?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type UserDocumentCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    link?: true
    size?: true
    belongsTo?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type UserDocumentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserDocument to aggregate.
     */
    where?: UserDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDocuments to fetch.
     */
    orderBy?: Enumerable<UserDocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserDocuments
    **/
    _count?: true | UserDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserDocumentMaxAggregateInputType
  }

  export type GetUserDocumentAggregateType<T extends UserDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateUserDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserDocument[P]>
      : GetScalarType<T[P], AggregateUserDocument[P]>
  }




  export type UserDocumentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserDocumentWhereInput
    orderBy?: Enumerable<UserDocumentOrderByWithAggregationInput>
    by: UserDocumentScalarFieldEnum[]
    having?: UserDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserDocumentCountAggregateInputType | true
    _min?: UserDocumentMinAggregateInputType
    _max?: UserDocumentMaxAggregateInputType
  }


  export type UserDocumentGroupByOutputType = {
    id: string
    name: string | null
    type: string | null
    link: string | null
    size: string | null
    belongsTo: string | null
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
    userId: string
    _count: UserDocumentCountAggregateOutputType | null
    _min: UserDocumentMinAggregateOutputType | null
    _max: UserDocumentMaxAggregateOutputType | null
  }

  type GetUserDocumentGroupByPayload<T extends UserDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], UserDocumentGroupByOutputType[P]>
        }
      >
    >


  export type UserDocumentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    link?: boolean
    size?: boolean
    belongsTo?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["userDocument"]>

  export type UserDocumentSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    link?: boolean
    size?: boolean
    belongsTo?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type UserDocumentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type UserDocumentGetPayload<S extends boolean | null | undefined | UserDocumentArgs> = $Types.GetResult<UserDocumentPayload, S>

  type UserDocumentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserDocumentFindManyArgs, 'select' | 'include'> & {
      select?: UserDocumentCountAggregateInputType | true
    }

  export interface UserDocumentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserDocument'], meta: { name: 'UserDocument' } }
    /**
     * Find zero or one UserDocument that matches the filter.
     * @param {UserDocumentFindUniqueArgs} args - Arguments to find a UserDocument
     * @example
     * // Get one UserDocument
     * const userDocument = await prisma.userDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserDocumentFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserDocumentFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserDocument'> extends True ? Prisma__UserDocumentClient<$Types.GetResult<UserDocumentPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__UserDocumentClient<$Types.GetResult<UserDocumentPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one UserDocument that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserDocumentFindUniqueOrThrowArgs} args - Arguments to find a UserDocument
     * @example
     * // Get one UserDocument
     * const userDocument = await prisma.userDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserDocumentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDocumentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserDocumentClient<$Types.GetResult<UserDocumentPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first UserDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDocumentFindFirstArgs} args - Arguments to find a UserDocument
     * @example
     * // Get one UserDocument
     * const userDocument = await prisma.userDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserDocumentFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserDocumentFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserDocument'> extends True ? Prisma__UserDocumentClient<$Types.GetResult<UserDocumentPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__UserDocumentClient<$Types.GetResult<UserDocumentPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first UserDocument that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDocumentFindFirstOrThrowArgs} args - Arguments to find a UserDocument
     * @example
     * // Get one UserDocument
     * const userDocument = await prisma.userDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserDocumentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDocumentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserDocumentClient<$Types.GetResult<UserDocumentPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more UserDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDocumentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserDocuments
     * const userDocuments = await prisma.userDocument.findMany()
     * 
     * // Get first 10 UserDocuments
     * const userDocuments = await prisma.userDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userDocumentWithIdOnly = await prisma.userDocument.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserDocumentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDocumentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<UserDocumentPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a UserDocument.
     * @param {UserDocumentCreateArgs} args - Arguments to create a UserDocument.
     * @example
     * // Create one UserDocument
     * const UserDocument = await prisma.userDocument.create({
     *   data: {
     *     // ... data to create a UserDocument
     *   }
     * })
     * 
    **/
    create<T extends UserDocumentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserDocumentCreateArgs<ExtArgs>>
    ): Prisma__UserDocumentClient<$Types.GetResult<UserDocumentPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many UserDocuments.
     *     @param {UserDocumentCreateManyArgs} args - Arguments to create many UserDocuments.
     *     @example
     *     // Create many UserDocuments
     *     const userDocument = await prisma.userDocument.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserDocumentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDocumentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserDocument.
     * @param {UserDocumentDeleteArgs} args - Arguments to delete one UserDocument.
     * @example
     * // Delete one UserDocument
     * const UserDocument = await prisma.userDocument.delete({
     *   where: {
     *     // ... filter to delete one UserDocument
     *   }
     * })
     * 
    **/
    delete<T extends UserDocumentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDocumentDeleteArgs<ExtArgs>>
    ): Prisma__UserDocumentClient<$Types.GetResult<UserDocumentPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one UserDocument.
     * @param {UserDocumentUpdateArgs} args - Arguments to update one UserDocument.
     * @example
     * // Update one UserDocument
     * const userDocument = await prisma.userDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserDocumentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserDocumentUpdateArgs<ExtArgs>>
    ): Prisma__UserDocumentClient<$Types.GetResult<UserDocumentPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more UserDocuments.
     * @param {UserDocumentDeleteManyArgs} args - Arguments to filter UserDocuments to delete.
     * @example
     * // Delete a few UserDocuments
     * const { count } = await prisma.userDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDocumentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDocumentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserDocuments
     * const userDocument = await prisma.userDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserDocumentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserDocumentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserDocument.
     * @param {UserDocumentUpsertArgs} args - Arguments to update or create a UserDocument.
     * @example
     * // Update or create a UserDocument
     * const userDocument = await prisma.userDocument.upsert({
     *   create: {
     *     // ... data to create a UserDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserDocument we want to update
     *   }
     * })
    **/
    upsert<T extends UserDocumentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserDocumentUpsertArgs<ExtArgs>>
    ): Prisma__UserDocumentClient<$Types.GetResult<UserDocumentPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of UserDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDocumentCountArgs} args - Arguments to filter UserDocuments to count.
     * @example
     * // Count the number of UserDocuments
     * const count = await prisma.userDocument.count({
     *   where: {
     *     // ... the filter for the UserDocuments we want to count
     *   }
     * })
    **/
    count<T extends UserDocumentCountArgs>(
      args?: Subset<T, UserDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserDocumentAggregateArgs>(args: Subset<T, UserDocumentAggregateArgs>): Prisma.PrismaPromise<GetUserDocumentAggregateType<T>>

    /**
     * Group by UserDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserDocumentGroupByArgs['orderBy'] }
        : { orderBy?: UserDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserDocumentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserDocument base type for findUnique actions
   */
  export type UserDocumentFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocument
     */
    select?: UserDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserDocumentInclude<ExtArgs> | null
    /**
     * Filter, which UserDocument to fetch.
     */
    where: UserDocumentWhereUniqueInput
  }

  /**
   * UserDocument findUnique
   */
  export interface UserDocumentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserDocumentFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserDocument findUniqueOrThrow
   */
  export type UserDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocument
     */
    select?: UserDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserDocumentInclude<ExtArgs> | null
    /**
     * Filter, which UserDocument to fetch.
     */
    where: UserDocumentWhereUniqueInput
  }


  /**
   * UserDocument base type for findFirst actions
   */
  export type UserDocumentFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocument
     */
    select?: UserDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserDocumentInclude<ExtArgs> | null
    /**
     * Filter, which UserDocument to fetch.
     */
    where?: UserDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDocuments to fetch.
     */
    orderBy?: Enumerable<UserDocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserDocuments.
     */
    cursor?: UserDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserDocuments.
     */
    distinct?: Enumerable<UserDocumentScalarFieldEnum>
  }

  /**
   * UserDocument findFirst
   */
  export interface UserDocumentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserDocumentFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserDocument findFirstOrThrow
   */
  export type UserDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocument
     */
    select?: UserDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserDocumentInclude<ExtArgs> | null
    /**
     * Filter, which UserDocument to fetch.
     */
    where?: UserDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDocuments to fetch.
     */
    orderBy?: Enumerable<UserDocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserDocuments.
     */
    cursor?: UserDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserDocuments.
     */
    distinct?: Enumerable<UserDocumentScalarFieldEnum>
  }


  /**
   * UserDocument findMany
   */
  export type UserDocumentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocument
     */
    select?: UserDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserDocumentInclude<ExtArgs> | null
    /**
     * Filter, which UserDocuments to fetch.
     */
    where?: UserDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDocuments to fetch.
     */
    orderBy?: Enumerable<UserDocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserDocuments.
     */
    cursor?: UserDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDocuments.
     */
    skip?: number
    distinct?: Enumerable<UserDocumentScalarFieldEnum>
  }


  /**
   * UserDocument create
   */
  export type UserDocumentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocument
     */
    select?: UserDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a UserDocument.
     */
    data: XOR<UserDocumentCreateInput, UserDocumentUncheckedCreateInput>
  }


  /**
   * UserDocument createMany
   */
  export type UserDocumentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserDocuments.
     */
    data: Enumerable<UserDocumentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserDocument update
   */
  export type UserDocumentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocument
     */
    select?: UserDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a UserDocument.
     */
    data: XOR<UserDocumentUpdateInput, UserDocumentUncheckedUpdateInput>
    /**
     * Choose, which UserDocument to update.
     */
    where: UserDocumentWhereUniqueInput
  }


  /**
   * UserDocument updateMany
   */
  export type UserDocumentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserDocuments.
     */
    data: XOR<UserDocumentUpdateManyMutationInput, UserDocumentUncheckedUpdateManyInput>
    /**
     * Filter which UserDocuments to update
     */
    where?: UserDocumentWhereInput
  }


  /**
   * UserDocument upsert
   */
  export type UserDocumentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocument
     */
    select?: UserDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the UserDocument to update in case it exists.
     */
    where: UserDocumentWhereUniqueInput
    /**
     * In case the UserDocument found by the `where` argument doesn't exist, create a new UserDocument with this data.
     */
    create: XOR<UserDocumentCreateInput, UserDocumentUncheckedCreateInput>
    /**
     * In case the UserDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserDocumentUpdateInput, UserDocumentUncheckedUpdateInput>
  }


  /**
   * UserDocument delete
   */
  export type UserDocumentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocument
     */
    select?: UserDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserDocumentInclude<ExtArgs> | null
    /**
     * Filter which UserDocument to delete.
     */
    where: UserDocumentWhereUniqueInput
  }


  /**
   * UserDocument deleteMany
   */
  export type UserDocumentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserDocuments to delete
     */
    where?: UserDocumentWhereInput
  }


  /**
   * UserDocument without action
   */
  export type UserDocumentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocument
     */
    select?: UserDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserDocumentInclude<ExtArgs> | null
  }



  /**
   * Model Service
   */


  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isDeprecated: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: Enumerable<ServiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: Enumerable<ServiceOrderByWithAggregationInput>
    by: ServiceScalarFieldEnum[]
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }


  export type ServiceGroupByOutputType = {
    id: string
    name: string
    description: string
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
    _count: ServiceCountAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    products?: boolean | Service$productsArgs<ExtArgs>
    form?: boolean | Service$formArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    products?: boolean | Service$productsArgs<ExtArgs>
    form?: boolean | Service$formArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeArgs<ExtArgs>
  }


  type ServiceGetPayload<S extends boolean | null | undefined | ServiceArgs> = $Types.GetResult<ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ServiceFindManyArgs, 'select' | 'include'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ServiceFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Service'> extends True ? Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Service that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ServiceFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Service'> extends True ? Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Service that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ServiceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
    **/
    create<T extends ServiceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Services.
     *     @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     *     @example
     *     // Create many Services
     *     const service = await prisma.service.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ServiceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
    **/
    delete<T extends ServiceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ServiceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ServiceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ServiceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
    **/
    upsert<T extends ServiceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    products<T extends Service$productsArgs<ExtArgs> = {}>(args?: Subset<T, Service$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findMany', never>| Null>;

    form<T extends Service$formArgs<ExtArgs> = {}>(args?: Subset<T, Service$formArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ServiceFormPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Service base type for findUnique actions
   */
  export type ServiceFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUnique
   */
  export interface ServiceFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ServiceFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }


  /**
   * Service base type for findFirst actions
   */
  export type ServiceFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: Enumerable<ServiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: Enumerable<ServiceScalarFieldEnum>
  }

  /**
   * Service findFirst
   */
  export interface ServiceFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ServiceFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: Enumerable<ServiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: Enumerable<ServiceScalarFieldEnum>
  }


  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: Enumerable<ServiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: Enumerable<ServiceScalarFieldEnum>
  }


  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }


  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: Enumerable<ServiceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }


  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
  }


  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }


  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }


  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
  }


  /**
   * Service.products
   */
  export type Service$productsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Service.form
   */
  export type Service$formArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceFormInclude<ExtArgs> | null
    where?: ServiceFormWhereInput
    orderBy?: Enumerable<ServiceFormOrderByWithRelationInput>
    cursor?: ServiceFormWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ServiceFormScalarFieldEnum>
  }


  /**
   * Service without action
   */
  export type ServiceArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
  }



  /**
   * Model ServiceForm
   */


  export type AggregateServiceForm = {
    _count: ServiceFormCountAggregateOutputType | null
    _min: ServiceFormMinAggregateOutputType | null
    _max: ServiceFormMaxAggregateOutputType | null
  }

  export type ServiceFormMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    type: string | null
    compulsory: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeprecated: boolean | null
    serviceId: string | null
  }

  export type ServiceFormMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    type: string | null
    compulsory: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeprecated: boolean | null
    serviceId: string | null
  }

  export type ServiceFormCountAggregateOutputType = {
    id: number
    title: number
    description: number
    type: number
    compulsory: number
    createdAt: number
    updatedAt: number
    isDeprecated: number
    serviceId: number
    _all: number
  }


  export type ServiceFormMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    compulsory?: true
    createdAt?: true
    updatedAt?: true
    isDeprecated?: true
    serviceId?: true
  }

  export type ServiceFormMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    compulsory?: true
    createdAt?: true
    updatedAt?: true
    isDeprecated?: true
    serviceId?: true
  }

  export type ServiceFormCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    compulsory?: true
    createdAt?: true
    updatedAt?: true
    isDeprecated?: true
    serviceId?: true
    _all?: true
  }

  export type ServiceFormAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceForm to aggregate.
     */
    where?: ServiceFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceForms to fetch.
     */
    orderBy?: Enumerable<ServiceFormOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceForms
    **/
    _count?: true | ServiceFormCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceFormMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceFormMaxAggregateInputType
  }

  export type GetServiceFormAggregateType<T extends ServiceFormAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceForm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceForm[P]>
      : GetScalarType<T[P], AggregateServiceForm[P]>
  }




  export type ServiceFormGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ServiceFormWhereInput
    orderBy?: Enumerable<ServiceFormOrderByWithAggregationInput>
    by: ServiceFormScalarFieldEnum[]
    having?: ServiceFormScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceFormCountAggregateInputType | true
    _min?: ServiceFormMinAggregateInputType
    _max?: ServiceFormMaxAggregateInputType
  }


  export type ServiceFormGroupByOutputType = {
    id: string
    title: string | null
    description: string | null
    type: string | null
    compulsory: boolean
    createdAt: Date
    updatedAt: Date
    isDeprecated: boolean
    serviceId: string
    _count: ServiceFormCountAggregateOutputType | null
    _min: ServiceFormMinAggregateOutputType | null
    _max: ServiceFormMaxAggregateOutputType | null
  }

  type GetServiceFormGroupByPayload<T extends ServiceFormGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ServiceFormGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceFormGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceFormGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceFormGroupByOutputType[P]>
        }
      >
    >


  export type ServiceFormSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    compulsory?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeprecated?: boolean
    serviceId?: boolean
    service?: boolean | ServiceArgs<ExtArgs>
    subForm?: boolean | ServiceForm$subFormArgs<ExtArgs>
    _count?: boolean | ServiceFormCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["serviceForm"]>

  export type ServiceFormSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    compulsory?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeprecated?: boolean
    serviceId?: boolean
  }

  export type ServiceFormInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceArgs<ExtArgs>
    subForm?: boolean | ServiceForm$subFormArgs<ExtArgs>
    _count?: boolean | ServiceFormCountOutputTypeArgs<ExtArgs>
  }


  type ServiceFormGetPayload<S extends boolean | null | undefined | ServiceFormArgs> = $Types.GetResult<ServiceFormPayload, S>

  type ServiceFormCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ServiceFormFindManyArgs, 'select' | 'include'> & {
      select?: ServiceFormCountAggregateInputType | true
    }

  export interface ServiceFormDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceForm'], meta: { name: 'ServiceForm' } }
    /**
     * Find zero or one ServiceForm that matches the filter.
     * @param {ServiceFormFindUniqueArgs} args - Arguments to find a ServiceForm
     * @example
     * // Get one ServiceForm
     * const serviceForm = await prisma.serviceForm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ServiceFormFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ServiceFormFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ServiceForm'> extends True ? Prisma__ServiceFormClient<$Types.GetResult<ServiceFormPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ServiceFormClient<$Types.GetResult<ServiceFormPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ServiceForm that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ServiceFormFindUniqueOrThrowArgs} args - Arguments to find a ServiceForm
     * @example
     * // Get one ServiceForm
     * const serviceForm = await prisma.serviceForm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ServiceFormFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceFormFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceFormClient<$Types.GetResult<ServiceFormPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ServiceForm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFormFindFirstArgs} args - Arguments to find a ServiceForm
     * @example
     * // Get one ServiceForm
     * const serviceForm = await prisma.serviceForm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ServiceFormFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ServiceFormFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ServiceForm'> extends True ? Prisma__ServiceFormClient<$Types.GetResult<ServiceFormPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ServiceFormClient<$Types.GetResult<ServiceFormPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ServiceForm that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFormFindFirstOrThrowArgs} args - Arguments to find a ServiceForm
     * @example
     * // Get one ServiceForm
     * const serviceForm = await prisma.serviceForm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ServiceFormFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceFormFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceFormClient<$Types.GetResult<ServiceFormPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more ServiceForms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFormFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceForms
     * const serviceForms = await prisma.serviceForm.findMany()
     * 
     * // Get first 10 ServiceForms
     * const serviceForms = await prisma.serviceForm.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceFormWithIdOnly = await prisma.serviceForm.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ServiceFormFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceFormFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ServiceFormPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ServiceForm.
     * @param {ServiceFormCreateArgs} args - Arguments to create a ServiceForm.
     * @example
     * // Create one ServiceForm
     * const ServiceForm = await prisma.serviceForm.create({
     *   data: {
     *     // ... data to create a ServiceForm
     *   }
     * })
     * 
    **/
    create<T extends ServiceFormCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceFormCreateArgs<ExtArgs>>
    ): Prisma__ServiceFormClient<$Types.GetResult<ServiceFormPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many ServiceForms.
     *     @param {ServiceFormCreateManyArgs} args - Arguments to create many ServiceForms.
     *     @example
     *     // Create many ServiceForms
     *     const serviceForm = await prisma.serviceForm.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ServiceFormCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceFormCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ServiceForm.
     * @param {ServiceFormDeleteArgs} args - Arguments to delete one ServiceForm.
     * @example
     * // Delete one ServiceForm
     * const ServiceForm = await prisma.serviceForm.delete({
     *   where: {
     *     // ... filter to delete one ServiceForm
     *   }
     * })
     * 
    **/
    delete<T extends ServiceFormDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceFormDeleteArgs<ExtArgs>>
    ): Prisma__ServiceFormClient<$Types.GetResult<ServiceFormPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ServiceForm.
     * @param {ServiceFormUpdateArgs} args - Arguments to update one ServiceForm.
     * @example
     * // Update one ServiceForm
     * const serviceForm = await prisma.serviceForm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ServiceFormUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceFormUpdateArgs<ExtArgs>>
    ): Prisma__ServiceFormClient<$Types.GetResult<ServiceFormPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more ServiceForms.
     * @param {ServiceFormDeleteManyArgs} args - Arguments to filter ServiceForms to delete.
     * @example
     * // Delete a few ServiceForms
     * const { count } = await prisma.serviceForm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ServiceFormDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceFormDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFormUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceForms
     * const serviceForm = await prisma.serviceForm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ServiceFormUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceFormUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceForm.
     * @param {ServiceFormUpsertArgs} args - Arguments to update or create a ServiceForm.
     * @example
     * // Update or create a ServiceForm
     * const serviceForm = await prisma.serviceForm.upsert({
     *   create: {
     *     // ... data to create a ServiceForm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceForm we want to update
     *   }
     * })
    **/
    upsert<T extends ServiceFormUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceFormUpsertArgs<ExtArgs>>
    ): Prisma__ServiceFormClient<$Types.GetResult<ServiceFormPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of ServiceForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFormCountArgs} args - Arguments to filter ServiceForms to count.
     * @example
     * // Count the number of ServiceForms
     * const count = await prisma.serviceForm.count({
     *   where: {
     *     // ... the filter for the ServiceForms we want to count
     *   }
     * })
    **/
    count<T extends ServiceFormCountArgs>(
      args?: Subset<T, ServiceFormCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceFormCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFormAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceFormAggregateArgs>(args: Subset<T, ServiceFormAggregateArgs>): Prisma.PrismaPromise<GetServiceFormAggregateType<T>>

    /**
     * Group by ServiceForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFormGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceFormGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceFormGroupByArgs['orderBy'] }
        : { orderBy?: ServiceFormGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceFormGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceFormGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceForm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ServiceFormClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    service<T extends ServiceArgs<ExtArgs> = {}>(args?: Subset<T, ServiceArgs<ExtArgs>>): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    subForm<T extends ServiceForm$subFormArgs<ExtArgs> = {}>(args?: Subset<T, ServiceForm$subFormArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ServiceSubFormPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ServiceForm base type for findUnique actions
   */
  export type ServiceFormFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceFormInclude<ExtArgs> | null
    /**
     * Filter, which ServiceForm to fetch.
     */
    where: ServiceFormWhereUniqueInput
  }

  /**
   * ServiceForm findUnique
   */
  export interface ServiceFormFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ServiceFormFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ServiceForm findUniqueOrThrow
   */
  export type ServiceFormFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceFormInclude<ExtArgs> | null
    /**
     * Filter, which ServiceForm to fetch.
     */
    where: ServiceFormWhereUniqueInput
  }


  /**
   * ServiceForm base type for findFirst actions
   */
  export type ServiceFormFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceFormInclude<ExtArgs> | null
    /**
     * Filter, which ServiceForm to fetch.
     */
    where?: ServiceFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceForms to fetch.
     */
    orderBy?: Enumerable<ServiceFormOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceForms.
     */
    cursor?: ServiceFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceForms.
     */
    distinct?: Enumerable<ServiceFormScalarFieldEnum>
  }

  /**
   * ServiceForm findFirst
   */
  export interface ServiceFormFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ServiceFormFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ServiceForm findFirstOrThrow
   */
  export type ServiceFormFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceFormInclude<ExtArgs> | null
    /**
     * Filter, which ServiceForm to fetch.
     */
    where?: ServiceFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceForms to fetch.
     */
    orderBy?: Enumerable<ServiceFormOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceForms.
     */
    cursor?: ServiceFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceForms.
     */
    distinct?: Enumerable<ServiceFormScalarFieldEnum>
  }


  /**
   * ServiceForm findMany
   */
  export type ServiceFormFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceFormInclude<ExtArgs> | null
    /**
     * Filter, which ServiceForms to fetch.
     */
    where?: ServiceFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceForms to fetch.
     */
    orderBy?: Enumerable<ServiceFormOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceForms.
     */
    cursor?: ServiceFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceForms.
     */
    skip?: number
    distinct?: Enumerable<ServiceFormScalarFieldEnum>
  }


  /**
   * ServiceForm create
   */
  export type ServiceFormCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceFormInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceForm.
     */
    data: XOR<ServiceFormCreateInput, ServiceFormUncheckedCreateInput>
  }


  /**
   * ServiceForm createMany
   */
  export type ServiceFormCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceForms.
     */
    data: Enumerable<ServiceFormCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ServiceForm update
   */
  export type ServiceFormUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceFormInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceForm.
     */
    data: XOR<ServiceFormUpdateInput, ServiceFormUncheckedUpdateInput>
    /**
     * Choose, which ServiceForm to update.
     */
    where: ServiceFormWhereUniqueInput
  }


  /**
   * ServiceForm updateMany
   */
  export type ServiceFormUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceForms.
     */
    data: XOR<ServiceFormUpdateManyMutationInput, ServiceFormUncheckedUpdateManyInput>
    /**
     * Filter which ServiceForms to update
     */
    where?: ServiceFormWhereInput
  }


  /**
   * ServiceForm upsert
   */
  export type ServiceFormUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceFormInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceForm to update in case it exists.
     */
    where: ServiceFormWhereUniqueInput
    /**
     * In case the ServiceForm found by the `where` argument doesn't exist, create a new ServiceForm with this data.
     */
    create: XOR<ServiceFormCreateInput, ServiceFormUncheckedCreateInput>
    /**
     * In case the ServiceForm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceFormUpdateInput, ServiceFormUncheckedUpdateInput>
  }


  /**
   * ServiceForm delete
   */
  export type ServiceFormDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceFormInclude<ExtArgs> | null
    /**
     * Filter which ServiceForm to delete.
     */
    where: ServiceFormWhereUniqueInput
  }


  /**
   * ServiceForm deleteMany
   */
  export type ServiceFormDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceForms to delete
     */
    where?: ServiceFormWhereInput
  }


  /**
   * ServiceForm.subForm
   */
  export type ServiceForm$subFormArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubForm
     */
    select?: ServiceSubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubFormInclude<ExtArgs> | null
    where?: ServiceSubFormWhereInput
    orderBy?: Enumerable<ServiceSubFormOrderByWithRelationInput>
    cursor?: ServiceSubFormWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ServiceSubFormScalarFieldEnum>
  }


  /**
   * ServiceForm without action
   */
  export type ServiceFormArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceFormInclude<ExtArgs> | null
  }



  /**
   * Model ServiceSubForm
   */


  export type AggregateServiceSubForm = {
    _count: ServiceSubFormCountAggregateOutputType | null
    _min: ServiceSubFormMinAggregateOutputType | null
    _max: ServiceSubFormMaxAggregateOutputType | null
  }

  export type ServiceSubFormMinAggregateOutputType = {
    id: string | null
    question: string | null
    type: string | null
    fileName: string | null
    fileType: string | null
    fileLink: string | null
    fileSize: string | null
    dependentField: string | null
    documentType: string | null
    allowOther: boolean | null
    compulsory: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeprecated: boolean | null
    formId: string | null
  }

  export type ServiceSubFormMaxAggregateOutputType = {
    id: string | null
    question: string | null
    type: string | null
    fileName: string | null
    fileType: string | null
    fileLink: string | null
    fileSize: string | null
    dependentField: string | null
    documentType: string | null
    allowOther: boolean | null
    compulsory: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeprecated: boolean | null
    formId: string | null
  }

  export type ServiceSubFormCountAggregateOutputType = {
    id: number
    question: number
    type: number
    options: number
    fileName: number
    fileType: number
    fileLink: number
    fileSize: number
    dependentField: number
    dependentOptions: number
    documentType: number
    allowOther: number
    compulsory: number
    createdAt: number
    updatedAt: number
    isDeprecated: number
    formId: number
    _all: number
  }


  export type ServiceSubFormMinAggregateInputType = {
    id?: true
    question?: true
    type?: true
    fileName?: true
    fileType?: true
    fileLink?: true
    fileSize?: true
    dependentField?: true
    documentType?: true
    allowOther?: true
    compulsory?: true
    createdAt?: true
    updatedAt?: true
    isDeprecated?: true
    formId?: true
  }

  export type ServiceSubFormMaxAggregateInputType = {
    id?: true
    question?: true
    type?: true
    fileName?: true
    fileType?: true
    fileLink?: true
    fileSize?: true
    dependentField?: true
    documentType?: true
    allowOther?: true
    compulsory?: true
    createdAt?: true
    updatedAt?: true
    isDeprecated?: true
    formId?: true
  }

  export type ServiceSubFormCountAggregateInputType = {
    id?: true
    question?: true
    type?: true
    options?: true
    fileName?: true
    fileType?: true
    fileLink?: true
    fileSize?: true
    dependentField?: true
    dependentOptions?: true
    documentType?: true
    allowOther?: true
    compulsory?: true
    createdAt?: true
    updatedAt?: true
    isDeprecated?: true
    formId?: true
    _all?: true
  }

  export type ServiceSubFormAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceSubForm to aggregate.
     */
    where?: ServiceSubFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSubForms to fetch.
     */
    orderBy?: Enumerable<ServiceSubFormOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceSubFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSubForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSubForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceSubForms
    **/
    _count?: true | ServiceSubFormCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceSubFormMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceSubFormMaxAggregateInputType
  }

  export type GetServiceSubFormAggregateType<T extends ServiceSubFormAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceSubForm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceSubForm[P]>
      : GetScalarType<T[P], AggregateServiceSubForm[P]>
  }




  export type ServiceSubFormGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ServiceSubFormWhereInput
    orderBy?: Enumerable<ServiceSubFormOrderByWithAggregationInput>
    by: ServiceSubFormScalarFieldEnum[]
    having?: ServiceSubFormScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceSubFormCountAggregateInputType | true
    _min?: ServiceSubFormMinAggregateInputType
    _max?: ServiceSubFormMaxAggregateInputType
  }


  export type ServiceSubFormGroupByOutputType = {
    id: string
    question: string | null
    type: string | null
    options: string[]
    fileName: string | null
    fileType: string | null
    fileLink: string | null
    fileSize: string | null
    dependentField: string | null
    dependentOptions: string[]
    documentType: string | null
    allowOther: boolean
    compulsory: boolean
    createdAt: Date
    updatedAt: Date
    isDeprecated: boolean
    formId: string
    _count: ServiceSubFormCountAggregateOutputType | null
    _min: ServiceSubFormMinAggregateOutputType | null
    _max: ServiceSubFormMaxAggregateOutputType | null
  }

  type GetServiceSubFormGroupByPayload<T extends ServiceSubFormGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ServiceSubFormGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceSubFormGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceSubFormGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceSubFormGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSubFormSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    type?: boolean
    options?: boolean
    fileName?: boolean
    fileType?: boolean
    fileLink?: boolean
    fileSize?: boolean
    dependentField?: boolean
    dependentOptions?: boolean
    documentType?: boolean
    allowOther?: boolean
    compulsory?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeprecated?: boolean
    formId?: boolean
    form?: boolean | ServiceFormArgs<ExtArgs>
  }, ExtArgs["result"]["serviceSubForm"]>

  export type ServiceSubFormSelectScalar = {
    id?: boolean
    question?: boolean
    type?: boolean
    options?: boolean
    fileName?: boolean
    fileType?: boolean
    fileLink?: boolean
    fileSize?: boolean
    dependentField?: boolean
    dependentOptions?: boolean
    documentType?: boolean
    allowOther?: boolean
    compulsory?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeprecated?: boolean
    formId?: boolean
  }

  export type ServiceSubFormInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    form?: boolean | ServiceFormArgs<ExtArgs>
  }


  type ServiceSubFormGetPayload<S extends boolean | null | undefined | ServiceSubFormArgs> = $Types.GetResult<ServiceSubFormPayload, S>

  type ServiceSubFormCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ServiceSubFormFindManyArgs, 'select' | 'include'> & {
      select?: ServiceSubFormCountAggregateInputType | true
    }

  export interface ServiceSubFormDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceSubForm'], meta: { name: 'ServiceSubForm' } }
    /**
     * Find zero or one ServiceSubForm that matches the filter.
     * @param {ServiceSubFormFindUniqueArgs} args - Arguments to find a ServiceSubForm
     * @example
     * // Get one ServiceSubForm
     * const serviceSubForm = await prisma.serviceSubForm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ServiceSubFormFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ServiceSubFormFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ServiceSubForm'> extends True ? Prisma__ServiceSubFormClient<$Types.GetResult<ServiceSubFormPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ServiceSubFormClient<$Types.GetResult<ServiceSubFormPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ServiceSubForm that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ServiceSubFormFindUniqueOrThrowArgs} args - Arguments to find a ServiceSubForm
     * @example
     * // Get one ServiceSubForm
     * const serviceSubForm = await prisma.serviceSubForm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ServiceSubFormFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceSubFormFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceSubFormClient<$Types.GetResult<ServiceSubFormPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ServiceSubForm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSubFormFindFirstArgs} args - Arguments to find a ServiceSubForm
     * @example
     * // Get one ServiceSubForm
     * const serviceSubForm = await prisma.serviceSubForm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ServiceSubFormFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ServiceSubFormFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ServiceSubForm'> extends True ? Prisma__ServiceSubFormClient<$Types.GetResult<ServiceSubFormPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ServiceSubFormClient<$Types.GetResult<ServiceSubFormPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ServiceSubForm that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSubFormFindFirstOrThrowArgs} args - Arguments to find a ServiceSubForm
     * @example
     * // Get one ServiceSubForm
     * const serviceSubForm = await prisma.serviceSubForm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ServiceSubFormFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceSubFormFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceSubFormClient<$Types.GetResult<ServiceSubFormPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more ServiceSubForms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSubFormFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceSubForms
     * const serviceSubForms = await prisma.serviceSubForm.findMany()
     * 
     * // Get first 10 ServiceSubForms
     * const serviceSubForms = await prisma.serviceSubForm.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceSubFormWithIdOnly = await prisma.serviceSubForm.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ServiceSubFormFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceSubFormFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ServiceSubFormPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ServiceSubForm.
     * @param {ServiceSubFormCreateArgs} args - Arguments to create a ServiceSubForm.
     * @example
     * // Create one ServiceSubForm
     * const ServiceSubForm = await prisma.serviceSubForm.create({
     *   data: {
     *     // ... data to create a ServiceSubForm
     *   }
     * })
     * 
    **/
    create<T extends ServiceSubFormCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceSubFormCreateArgs<ExtArgs>>
    ): Prisma__ServiceSubFormClient<$Types.GetResult<ServiceSubFormPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many ServiceSubForms.
     *     @param {ServiceSubFormCreateManyArgs} args - Arguments to create many ServiceSubForms.
     *     @example
     *     // Create many ServiceSubForms
     *     const serviceSubForm = await prisma.serviceSubForm.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ServiceSubFormCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceSubFormCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ServiceSubForm.
     * @param {ServiceSubFormDeleteArgs} args - Arguments to delete one ServiceSubForm.
     * @example
     * // Delete one ServiceSubForm
     * const ServiceSubForm = await prisma.serviceSubForm.delete({
     *   where: {
     *     // ... filter to delete one ServiceSubForm
     *   }
     * })
     * 
    **/
    delete<T extends ServiceSubFormDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceSubFormDeleteArgs<ExtArgs>>
    ): Prisma__ServiceSubFormClient<$Types.GetResult<ServiceSubFormPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ServiceSubForm.
     * @param {ServiceSubFormUpdateArgs} args - Arguments to update one ServiceSubForm.
     * @example
     * // Update one ServiceSubForm
     * const serviceSubForm = await prisma.serviceSubForm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ServiceSubFormUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceSubFormUpdateArgs<ExtArgs>>
    ): Prisma__ServiceSubFormClient<$Types.GetResult<ServiceSubFormPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more ServiceSubForms.
     * @param {ServiceSubFormDeleteManyArgs} args - Arguments to filter ServiceSubForms to delete.
     * @example
     * // Delete a few ServiceSubForms
     * const { count } = await prisma.serviceSubForm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ServiceSubFormDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceSubFormDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceSubForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSubFormUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceSubForms
     * const serviceSubForm = await prisma.serviceSubForm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ServiceSubFormUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceSubFormUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceSubForm.
     * @param {ServiceSubFormUpsertArgs} args - Arguments to update or create a ServiceSubForm.
     * @example
     * // Update or create a ServiceSubForm
     * const serviceSubForm = await prisma.serviceSubForm.upsert({
     *   create: {
     *     // ... data to create a ServiceSubForm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceSubForm we want to update
     *   }
     * })
    **/
    upsert<T extends ServiceSubFormUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceSubFormUpsertArgs<ExtArgs>>
    ): Prisma__ServiceSubFormClient<$Types.GetResult<ServiceSubFormPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of ServiceSubForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSubFormCountArgs} args - Arguments to filter ServiceSubForms to count.
     * @example
     * // Count the number of ServiceSubForms
     * const count = await prisma.serviceSubForm.count({
     *   where: {
     *     // ... the filter for the ServiceSubForms we want to count
     *   }
     * })
    **/
    count<T extends ServiceSubFormCountArgs>(
      args?: Subset<T, ServiceSubFormCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceSubFormCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceSubForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSubFormAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceSubFormAggregateArgs>(args: Subset<T, ServiceSubFormAggregateArgs>): Prisma.PrismaPromise<GetServiceSubFormAggregateType<T>>

    /**
     * Group by ServiceSubForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSubFormGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceSubFormGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceSubFormGroupByArgs['orderBy'] }
        : { orderBy?: ServiceSubFormGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceSubFormGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceSubFormGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceSubForm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ServiceSubFormClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    form<T extends ServiceFormArgs<ExtArgs> = {}>(args?: Subset<T, ServiceFormArgs<ExtArgs>>): Prisma__ServiceFormClient<$Types.GetResult<ServiceFormPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ServiceSubForm base type for findUnique actions
   */
  export type ServiceSubFormFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubForm
     */
    select?: ServiceSubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubFormInclude<ExtArgs> | null
    /**
     * Filter, which ServiceSubForm to fetch.
     */
    where: ServiceSubFormWhereUniqueInput
  }

  /**
   * ServiceSubForm findUnique
   */
  export interface ServiceSubFormFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ServiceSubFormFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ServiceSubForm findUniqueOrThrow
   */
  export type ServiceSubFormFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubForm
     */
    select?: ServiceSubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubFormInclude<ExtArgs> | null
    /**
     * Filter, which ServiceSubForm to fetch.
     */
    where: ServiceSubFormWhereUniqueInput
  }


  /**
   * ServiceSubForm base type for findFirst actions
   */
  export type ServiceSubFormFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubForm
     */
    select?: ServiceSubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubFormInclude<ExtArgs> | null
    /**
     * Filter, which ServiceSubForm to fetch.
     */
    where?: ServiceSubFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSubForms to fetch.
     */
    orderBy?: Enumerable<ServiceSubFormOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceSubForms.
     */
    cursor?: ServiceSubFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSubForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSubForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceSubForms.
     */
    distinct?: Enumerable<ServiceSubFormScalarFieldEnum>
  }

  /**
   * ServiceSubForm findFirst
   */
  export interface ServiceSubFormFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ServiceSubFormFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ServiceSubForm findFirstOrThrow
   */
  export type ServiceSubFormFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubForm
     */
    select?: ServiceSubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubFormInclude<ExtArgs> | null
    /**
     * Filter, which ServiceSubForm to fetch.
     */
    where?: ServiceSubFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSubForms to fetch.
     */
    orderBy?: Enumerable<ServiceSubFormOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceSubForms.
     */
    cursor?: ServiceSubFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSubForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSubForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceSubForms.
     */
    distinct?: Enumerable<ServiceSubFormScalarFieldEnum>
  }


  /**
   * ServiceSubForm findMany
   */
  export type ServiceSubFormFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubForm
     */
    select?: ServiceSubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubFormInclude<ExtArgs> | null
    /**
     * Filter, which ServiceSubForms to fetch.
     */
    where?: ServiceSubFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSubForms to fetch.
     */
    orderBy?: Enumerable<ServiceSubFormOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceSubForms.
     */
    cursor?: ServiceSubFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSubForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSubForms.
     */
    skip?: number
    distinct?: Enumerable<ServiceSubFormScalarFieldEnum>
  }


  /**
   * ServiceSubForm create
   */
  export type ServiceSubFormCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubForm
     */
    select?: ServiceSubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubFormInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceSubForm.
     */
    data: XOR<ServiceSubFormCreateInput, ServiceSubFormUncheckedCreateInput>
  }


  /**
   * ServiceSubForm createMany
   */
  export type ServiceSubFormCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceSubForms.
     */
    data: Enumerable<ServiceSubFormCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ServiceSubForm update
   */
  export type ServiceSubFormUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubForm
     */
    select?: ServiceSubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubFormInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceSubForm.
     */
    data: XOR<ServiceSubFormUpdateInput, ServiceSubFormUncheckedUpdateInput>
    /**
     * Choose, which ServiceSubForm to update.
     */
    where: ServiceSubFormWhereUniqueInput
  }


  /**
   * ServiceSubForm updateMany
   */
  export type ServiceSubFormUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceSubForms.
     */
    data: XOR<ServiceSubFormUpdateManyMutationInput, ServiceSubFormUncheckedUpdateManyInput>
    /**
     * Filter which ServiceSubForms to update
     */
    where?: ServiceSubFormWhereInput
  }


  /**
   * ServiceSubForm upsert
   */
  export type ServiceSubFormUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubForm
     */
    select?: ServiceSubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubFormInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceSubForm to update in case it exists.
     */
    where: ServiceSubFormWhereUniqueInput
    /**
     * In case the ServiceSubForm found by the `where` argument doesn't exist, create a new ServiceSubForm with this data.
     */
    create: XOR<ServiceSubFormCreateInput, ServiceSubFormUncheckedCreateInput>
    /**
     * In case the ServiceSubForm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceSubFormUpdateInput, ServiceSubFormUncheckedUpdateInput>
  }


  /**
   * ServiceSubForm delete
   */
  export type ServiceSubFormDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubForm
     */
    select?: ServiceSubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubFormInclude<ExtArgs> | null
    /**
     * Filter which ServiceSubForm to delete.
     */
    where: ServiceSubFormWhereUniqueInput
  }


  /**
   * ServiceSubForm deleteMany
   */
  export type ServiceSubFormDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceSubForms to delete
     */
    where?: ServiceSubFormWhereInput
  }


  /**
   * ServiceSubForm without action
   */
  export type ServiceSubFormArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubForm
     */
    select?: ServiceSubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubFormInclude<ExtArgs> | null
  }



  /**
   * Model Product
   */


  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    amount: number | null
  }

  export type ProductSumAggregateOutputType = {
    amount: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    country: string | null
    currency: string | null
    amount: number | null
    timeline: string | null
    hasShares: boolean | null
    hasAgent: boolean | null
    hasOwner: boolean | null
    hasController: boolean | null
    controllerIsCalled: string | null
    OwnerIsCalled: string | null
    agentIsCalled: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeprecated: boolean | null
    serviceId: string | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    country: string | null
    currency: string | null
    amount: number | null
    timeline: string | null
    hasShares: boolean | null
    hasAgent: boolean | null
    hasOwner: boolean | null
    hasController: boolean | null
    controllerIsCalled: string | null
    OwnerIsCalled: string | null
    agentIsCalled: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeprecated: boolean | null
    serviceId: string | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    description: number
    country: number
    currency: number
    amount: number
    timeline: number
    feature: number
    canAlsoDo: number
    hasShares: number
    hasAgent: number
    hasOwner: number
    hasController: number
    controllerIsCalled: number
    OwnerIsCalled: number
    agentIsCalled: number
    createdAt: number
    updatedAt: number
    isDeprecated: number
    serviceId: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    amount?: true
  }

  export type ProductSumAggregateInputType = {
    amount?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    country?: true
    currency?: true
    amount?: true
    timeline?: true
    hasShares?: true
    hasAgent?: true
    hasOwner?: true
    hasController?: true
    controllerIsCalled?: true
    OwnerIsCalled?: true
    agentIsCalled?: true
    createdAt?: true
    updatedAt?: true
    isDeprecated?: true
    serviceId?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    country?: true
    currency?: true
    amount?: true
    timeline?: true
    hasShares?: true
    hasAgent?: true
    hasOwner?: true
    hasController?: true
    controllerIsCalled?: true
    OwnerIsCalled?: true
    agentIsCalled?: true
    createdAt?: true
    updatedAt?: true
    isDeprecated?: true
    serviceId?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    country?: true
    currency?: true
    amount?: true
    timeline?: true
    feature?: true
    canAlsoDo?: true
    hasShares?: true
    hasAgent?: true
    hasOwner?: true
    hasController?: true
    controllerIsCalled?: true
    OwnerIsCalled?: true
    agentIsCalled?: true
    createdAt?: true
    updatedAt?: true
    isDeprecated?: true
    serviceId?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: Enumerable<ProductOrderByWithAggregationInput>
    by: ProductScalarFieldEnum[]
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }


  export type ProductGroupByOutputType = {
    id: string
    name: string
    description: string
    country: string
    currency: string
    amount: number
    timeline: string
    feature: string[]
    canAlsoDo: string[]
    hasShares: boolean
    hasAgent: boolean
    hasOwner: boolean
    hasController: boolean
    controllerIsCalled: string | null
    OwnerIsCalled: string | null
    agentIsCalled: string | null
    createdAt: Date
    updatedAt: Date
    isDeprecated: boolean
    serviceId: string
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    country?: boolean
    currency?: boolean
    amount?: boolean
    timeline?: boolean
    feature?: boolean
    canAlsoDo?: boolean
    hasShares?: boolean
    hasAgent?: boolean
    hasOwner?: boolean
    hasController?: boolean
    controllerIsCalled?: boolean
    OwnerIsCalled?: boolean
    agentIsCalled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeprecated?: boolean
    serviceId?: boolean
    service?: boolean | ServiceArgs<ExtArgs>
    request?: boolean | Product$requestArgs<ExtArgs>
    form?: boolean | Product$formArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    country?: boolean
    currency?: boolean
    amount?: boolean
    timeline?: boolean
    feature?: boolean
    canAlsoDo?: boolean
    hasShares?: boolean
    hasAgent?: boolean
    hasOwner?: boolean
    hasController?: boolean
    controllerIsCalled?: boolean
    OwnerIsCalled?: boolean
    agentIsCalled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeprecated?: boolean
    serviceId?: boolean
  }

  export type ProductInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceArgs<ExtArgs>
    request?: boolean | Product$requestArgs<ExtArgs>
    form?: boolean | Product$formArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeArgs<ExtArgs>
  }


  type ProductGetPayload<S extends boolean | null | undefined | ProductArgs> = $Types.GetResult<ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ProductFindManyArgs, 'select' | 'include'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Product'> extends True ? Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Product'> extends True ? Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
    **/
    create<T extends ProductCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductCreateArgs<ExtArgs>>
    ): Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Products.
     *     @param {ProductCreateManyArgs} args - Arguments to create many Products.
     *     @example
     *     // Create many Products
     *     const product = await prisma.product.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
    **/
    delete<T extends ProductDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>
    ): Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>
    ): Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
    **/
    upsert<T extends ProductUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>
    ): Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    service<T extends ServiceArgs<ExtArgs> = {}>(args?: Subset<T, ServiceArgs<ExtArgs>>): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    request<T extends Product$requestArgs<ExtArgs> = {}>(args?: Subset<T, Product$requestArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ProductRequestPayload<ExtArgs>, T, 'findMany', never>| Null>;

    form<T extends Product$formArgs<ExtArgs> = {}>(args?: Subset<T, Product$formArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ProductFormPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Product base type for findUnique actions
   */
  export type ProductFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUnique
   */
  export interface ProductFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProductFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product base type for findFirst actions
   */
  export type ProductFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: Enumerable<ProductScalarFieldEnum>
  }

  /**
   * Product findFirst
   */
  export interface ProductFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProductFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }


  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: Enumerable<ProductCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
  }


  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }


  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
  }


  /**
   * Product.request
   */
  export type Product$requestArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRequest
     */
    select?: ProductRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductRequestInclude<ExtArgs> | null
    where?: ProductRequestWhereInput
    orderBy?: Enumerable<ProductRequestOrderByWithRelationInput>
    cursor?: ProductRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductRequestScalarFieldEnum>
  }


  /**
   * Product.form
   */
  export type Product$formArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductForm
     */
    select?: ProductFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductFormInclude<ExtArgs> | null
    where?: ProductFormWhereInput
    orderBy?: Enumerable<ProductFormOrderByWithRelationInput>
    cursor?: ProductFormWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductFormScalarFieldEnum>
  }


  /**
   * Product without action
   */
  export type ProductArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
  }



  /**
   * Model ProductForm
   */


  export type AggregateProductForm = {
    _count: ProductFormCountAggregateOutputType | null
    _min: ProductFormMinAggregateOutputType | null
    _max: ProductFormMaxAggregateOutputType | null
  }

  export type ProductFormMinAggregateOutputType = {
    id: string | null
    title: string | null
    type: string | null
    description: string | null
    compulsory: boolean | null
    createdAt: Date | null
    isDeprecated: boolean | null
    updatedAt: Date | null
    productId: string | null
  }

  export type ProductFormMaxAggregateOutputType = {
    id: string | null
    title: string | null
    type: string | null
    description: string | null
    compulsory: boolean | null
    createdAt: Date | null
    isDeprecated: boolean | null
    updatedAt: Date | null
    productId: string | null
  }

  export type ProductFormCountAggregateOutputType = {
    id: number
    title: number
    type: number
    description: number
    compulsory: number
    createdAt: number
    isDeprecated: number
    updatedAt: number
    productId: number
    _all: number
  }


  export type ProductFormMinAggregateInputType = {
    id?: true
    title?: true
    type?: true
    description?: true
    compulsory?: true
    createdAt?: true
    isDeprecated?: true
    updatedAt?: true
    productId?: true
  }

  export type ProductFormMaxAggregateInputType = {
    id?: true
    title?: true
    type?: true
    description?: true
    compulsory?: true
    createdAt?: true
    isDeprecated?: true
    updatedAt?: true
    productId?: true
  }

  export type ProductFormCountAggregateInputType = {
    id?: true
    title?: true
    type?: true
    description?: true
    compulsory?: true
    createdAt?: true
    isDeprecated?: true
    updatedAt?: true
    productId?: true
    _all?: true
  }

  export type ProductFormAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductForm to aggregate.
     */
    where?: ProductFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductForms to fetch.
     */
    orderBy?: Enumerable<ProductFormOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductForms
    **/
    _count?: true | ProductFormCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductFormMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductFormMaxAggregateInputType
  }

  export type GetProductFormAggregateType<T extends ProductFormAggregateArgs> = {
        [P in keyof T & keyof AggregateProductForm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductForm[P]>
      : GetScalarType<T[P], AggregateProductForm[P]>
  }




  export type ProductFormGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductFormWhereInput
    orderBy?: Enumerable<ProductFormOrderByWithAggregationInput>
    by: ProductFormScalarFieldEnum[]
    having?: ProductFormScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductFormCountAggregateInputType | true
    _min?: ProductFormMinAggregateInputType
    _max?: ProductFormMaxAggregateInputType
  }


  export type ProductFormGroupByOutputType = {
    id: string
    title: string | null
    type: string | null
    description: string | null
    compulsory: boolean
    createdAt: Date
    isDeprecated: boolean
    updatedAt: Date
    productId: string
    _count: ProductFormCountAggregateOutputType | null
    _min: ProductFormMinAggregateOutputType | null
    _max: ProductFormMaxAggregateOutputType | null
  }

  type GetProductFormGroupByPayload<T extends ProductFormGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProductFormGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductFormGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductFormGroupByOutputType[P]>
            : GetScalarType<T[P], ProductFormGroupByOutputType[P]>
        }
      >
    >


  export type ProductFormSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    type?: boolean
    description?: boolean
    compulsory?: boolean
    createdAt?: boolean
    isDeprecated?: boolean
    updatedAt?: boolean
    productId?: boolean
    product?: boolean | ProductArgs<ExtArgs>
    productSubForm?: boolean | ProductForm$productSubFormArgs<ExtArgs>
    _count?: boolean | ProductFormCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["productForm"]>

  export type ProductFormSelectScalar = {
    id?: boolean
    title?: boolean
    type?: boolean
    description?: boolean
    compulsory?: boolean
    createdAt?: boolean
    isDeprecated?: boolean
    updatedAt?: boolean
    productId?: boolean
  }

  export type ProductFormInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    product?: boolean | ProductArgs<ExtArgs>
    productSubForm?: boolean | ProductForm$productSubFormArgs<ExtArgs>
    _count?: boolean | ProductFormCountOutputTypeArgs<ExtArgs>
  }


  type ProductFormGetPayload<S extends boolean | null | undefined | ProductFormArgs> = $Types.GetResult<ProductFormPayload, S>

  type ProductFormCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ProductFormFindManyArgs, 'select' | 'include'> & {
      select?: ProductFormCountAggregateInputType | true
    }

  export interface ProductFormDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductForm'], meta: { name: 'ProductForm' } }
    /**
     * Find zero or one ProductForm that matches the filter.
     * @param {ProductFormFindUniqueArgs} args - Arguments to find a ProductForm
     * @example
     * // Get one ProductForm
     * const productForm = await prisma.productForm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductFormFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductFormFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductForm'> extends True ? Prisma__ProductFormClient<$Types.GetResult<ProductFormPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ProductFormClient<$Types.GetResult<ProductFormPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ProductForm that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductFormFindUniqueOrThrowArgs} args - Arguments to find a ProductForm
     * @example
     * // Get one ProductForm
     * const productForm = await prisma.productForm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductFormFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFormFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductFormClient<$Types.GetResult<ProductFormPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ProductForm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFormFindFirstArgs} args - Arguments to find a ProductForm
     * @example
     * // Get one ProductForm
     * const productForm = await prisma.productForm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductFormFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductFormFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductForm'> extends True ? Prisma__ProductFormClient<$Types.GetResult<ProductFormPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ProductFormClient<$Types.GetResult<ProductFormPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ProductForm that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFormFindFirstOrThrowArgs} args - Arguments to find a ProductForm
     * @example
     * // Get one ProductForm
     * const productForm = await prisma.productForm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductFormFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFormFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductFormClient<$Types.GetResult<ProductFormPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more ProductForms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFormFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductForms
     * const productForms = await prisma.productForm.findMany()
     * 
     * // Get first 10 ProductForms
     * const productForms = await prisma.productForm.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productFormWithIdOnly = await prisma.productForm.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductFormFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFormFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ProductFormPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ProductForm.
     * @param {ProductFormCreateArgs} args - Arguments to create a ProductForm.
     * @example
     * // Create one ProductForm
     * const ProductForm = await prisma.productForm.create({
     *   data: {
     *     // ... data to create a ProductForm
     *   }
     * })
     * 
    **/
    create<T extends ProductFormCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductFormCreateArgs<ExtArgs>>
    ): Prisma__ProductFormClient<$Types.GetResult<ProductFormPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many ProductForms.
     *     @param {ProductFormCreateManyArgs} args - Arguments to create many ProductForms.
     *     @example
     *     // Create many ProductForms
     *     const productForm = await prisma.productForm.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductFormCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFormCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductForm.
     * @param {ProductFormDeleteArgs} args - Arguments to delete one ProductForm.
     * @example
     * // Delete one ProductForm
     * const ProductForm = await prisma.productForm.delete({
     *   where: {
     *     // ... filter to delete one ProductForm
     *   }
     * })
     * 
    **/
    delete<T extends ProductFormDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProductFormDeleteArgs<ExtArgs>>
    ): Prisma__ProductFormClient<$Types.GetResult<ProductFormPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ProductForm.
     * @param {ProductFormUpdateArgs} args - Arguments to update one ProductForm.
     * @example
     * // Update one ProductForm
     * const productForm = await prisma.productForm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductFormUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductFormUpdateArgs<ExtArgs>>
    ): Prisma__ProductFormClient<$Types.GetResult<ProductFormPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more ProductForms.
     * @param {ProductFormDeleteManyArgs} args - Arguments to filter ProductForms to delete.
     * @example
     * // Delete a few ProductForms
     * const { count } = await prisma.productForm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductFormDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFormDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFormUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductForms
     * const productForm = await prisma.productForm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductFormUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProductFormUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductForm.
     * @param {ProductFormUpsertArgs} args - Arguments to update or create a ProductForm.
     * @example
     * // Update or create a ProductForm
     * const productForm = await prisma.productForm.upsert({
     *   create: {
     *     // ... data to create a ProductForm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductForm we want to update
     *   }
     * })
    **/
    upsert<T extends ProductFormUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProductFormUpsertArgs<ExtArgs>>
    ): Prisma__ProductFormClient<$Types.GetResult<ProductFormPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of ProductForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFormCountArgs} args - Arguments to filter ProductForms to count.
     * @example
     * // Count the number of ProductForms
     * const count = await prisma.productForm.count({
     *   where: {
     *     // ... the filter for the ProductForms we want to count
     *   }
     * })
    **/
    count<T extends ProductFormCountArgs>(
      args?: Subset<T, ProductFormCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductFormCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFormAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductFormAggregateArgs>(args: Subset<T, ProductFormAggregateArgs>): Prisma.PrismaPromise<GetProductFormAggregateType<T>>

    /**
     * Group by ProductForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFormGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductFormGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductFormGroupByArgs['orderBy'] }
        : { orderBy?: ProductFormGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductFormGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductFormGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductForm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductFormClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    product<T extends ProductArgs<ExtArgs> = {}>(args?: Subset<T, ProductArgs<ExtArgs>>): Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    productSubForm<T extends ProductForm$productSubFormArgs<ExtArgs> = {}>(args?: Subset<T, ProductForm$productSubFormArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ProductSubFormPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ProductForm base type for findUnique actions
   */
  export type ProductFormFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductForm
     */
    select?: ProductFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductFormInclude<ExtArgs> | null
    /**
     * Filter, which ProductForm to fetch.
     */
    where: ProductFormWhereUniqueInput
  }

  /**
   * ProductForm findUnique
   */
  export interface ProductFormFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProductFormFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductForm findUniqueOrThrow
   */
  export type ProductFormFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductForm
     */
    select?: ProductFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductFormInclude<ExtArgs> | null
    /**
     * Filter, which ProductForm to fetch.
     */
    where: ProductFormWhereUniqueInput
  }


  /**
   * ProductForm base type for findFirst actions
   */
  export type ProductFormFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductForm
     */
    select?: ProductFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductFormInclude<ExtArgs> | null
    /**
     * Filter, which ProductForm to fetch.
     */
    where?: ProductFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductForms to fetch.
     */
    orderBy?: Enumerable<ProductFormOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductForms.
     */
    cursor?: ProductFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductForms.
     */
    distinct?: Enumerable<ProductFormScalarFieldEnum>
  }

  /**
   * ProductForm findFirst
   */
  export interface ProductFormFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProductFormFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductForm findFirstOrThrow
   */
  export type ProductFormFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductForm
     */
    select?: ProductFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductFormInclude<ExtArgs> | null
    /**
     * Filter, which ProductForm to fetch.
     */
    where?: ProductFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductForms to fetch.
     */
    orderBy?: Enumerable<ProductFormOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductForms.
     */
    cursor?: ProductFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductForms.
     */
    distinct?: Enumerable<ProductFormScalarFieldEnum>
  }


  /**
   * ProductForm findMany
   */
  export type ProductFormFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductForm
     */
    select?: ProductFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductFormInclude<ExtArgs> | null
    /**
     * Filter, which ProductForms to fetch.
     */
    where?: ProductFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductForms to fetch.
     */
    orderBy?: Enumerable<ProductFormOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductForms.
     */
    cursor?: ProductFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductForms.
     */
    skip?: number
    distinct?: Enumerable<ProductFormScalarFieldEnum>
  }


  /**
   * ProductForm create
   */
  export type ProductFormCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductForm
     */
    select?: ProductFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductFormInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductForm.
     */
    data: XOR<ProductFormCreateInput, ProductFormUncheckedCreateInput>
  }


  /**
   * ProductForm createMany
   */
  export type ProductFormCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductForms.
     */
    data: Enumerable<ProductFormCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductForm update
   */
  export type ProductFormUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductForm
     */
    select?: ProductFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductFormInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductForm.
     */
    data: XOR<ProductFormUpdateInput, ProductFormUncheckedUpdateInput>
    /**
     * Choose, which ProductForm to update.
     */
    where: ProductFormWhereUniqueInput
  }


  /**
   * ProductForm updateMany
   */
  export type ProductFormUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductForms.
     */
    data: XOR<ProductFormUpdateManyMutationInput, ProductFormUncheckedUpdateManyInput>
    /**
     * Filter which ProductForms to update
     */
    where?: ProductFormWhereInput
  }


  /**
   * ProductForm upsert
   */
  export type ProductFormUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductForm
     */
    select?: ProductFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductFormInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductForm to update in case it exists.
     */
    where: ProductFormWhereUniqueInput
    /**
     * In case the ProductForm found by the `where` argument doesn't exist, create a new ProductForm with this data.
     */
    create: XOR<ProductFormCreateInput, ProductFormUncheckedCreateInput>
    /**
     * In case the ProductForm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductFormUpdateInput, ProductFormUncheckedUpdateInput>
  }


  /**
   * ProductForm delete
   */
  export type ProductFormDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductForm
     */
    select?: ProductFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductFormInclude<ExtArgs> | null
    /**
     * Filter which ProductForm to delete.
     */
    where: ProductFormWhereUniqueInput
  }


  /**
   * ProductForm deleteMany
   */
  export type ProductFormDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductForms to delete
     */
    where?: ProductFormWhereInput
  }


  /**
   * ProductForm.productSubForm
   */
  export type ProductForm$productSubFormArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSubForm
     */
    select?: ProductSubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductSubFormInclude<ExtArgs> | null
    where?: ProductSubFormWhereInput
    orderBy?: Enumerable<ProductSubFormOrderByWithRelationInput>
    cursor?: ProductSubFormWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductSubFormScalarFieldEnum>
  }


  /**
   * ProductForm without action
   */
  export type ProductFormArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductForm
     */
    select?: ProductFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductFormInclude<ExtArgs> | null
  }



  /**
   * Model ProductSubForm
   */


  export type AggregateProductSubForm = {
    _count: ProductSubFormCountAggregateOutputType | null
    _min: ProductSubFormMinAggregateOutputType | null
    _max: ProductSubFormMaxAggregateOutputType | null
  }

  export type ProductSubFormMinAggregateOutputType = {
    id: string | null
    question: string | null
    type: string | null
    allowOther: boolean | null
    dependentField: string | null
    fileName: string | null
    fileType: string | null
    fileLink: string | null
    fileSize: string | null
    documentType: string | null
    compulsory: boolean | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    formId: string | null
  }

  export type ProductSubFormMaxAggregateOutputType = {
    id: string | null
    question: string | null
    type: string | null
    allowOther: boolean | null
    dependentField: string | null
    fileName: string | null
    fileType: string | null
    fileLink: string | null
    fileSize: string | null
    documentType: string | null
    compulsory: boolean | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    formId: string | null
  }

  export type ProductSubFormCountAggregateOutputType = {
    id: number
    question: number
    options: number
    type: number
    allowOther: number
    dependentField: number
    dependentOptions: number
    fileName: number
    fileType: number
    fileLink: number
    fileSize: number
    documentType: number
    compulsory: number
    isDeprecated: number
    createdAt: number
    updatedAt: number
    formId: number
    _all: number
  }


  export type ProductSubFormMinAggregateInputType = {
    id?: true
    question?: true
    type?: true
    allowOther?: true
    dependentField?: true
    fileName?: true
    fileType?: true
    fileLink?: true
    fileSize?: true
    documentType?: true
    compulsory?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
    formId?: true
  }

  export type ProductSubFormMaxAggregateInputType = {
    id?: true
    question?: true
    type?: true
    allowOther?: true
    dependentField?: true
    fileName?: true
    fileType?: true
    fileLink?: true
    fileSize?: true
    documentType?: true
    compulsory?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
    formId?: true
  }

  export type ProductSubFormCountAggregateInputType = {
    id?: true
    question?: true
    options?: true
    type?: true
    allowOther?: true
    dependentField?: true
    dependentOptions?: true
    fileName?: true
    fileType?: true
    fileLink?: true
    fileSize?: true
    documentType?: true
    compulsory?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
    formId?: true
    _all?: true
  }

  export type ProductSubFormAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductSubForm to aggregate.
     */
    where?: ProductSubFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductSubForms to fetch.
     */
    orderBy?: Enumerable<ProductSubFormOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductSubFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductSubForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductSubForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductSubForms
    **/
    _count?: true | ProductSubFormCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductSubFormMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductSubFormMaxAggregateInputType
  }

  export type GetProductSubFormAggregateType<T extends ProductSubFormAggregateArgs> = {
        [P in keyof T & keyof AggregateProductSubForm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductSubForm[P]>
      : GetScalarType<T[P], AggregateProductSubForm[P]>
  }




  export type ProductSubFormGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductSubFormWhereInput
    orderBy?: Enumerable<ProductSubFormOrderByWithAggregationInput>
    by: ProductSubFormScalarFieldEnum[]
    having?: ProductSubFormScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductSubFormCountAggregateInputType | true
    _min?: ProductSubFormMinAggregateInputType
    _max?: ProductSubFormMaxAggregateInputType
  }


  export type ProductSubFormGroupByOutputType = {
    id: string
    question: string | null
    options: string[]
    type: string | null
    allowOther: boolean
    dependentField: string | null
    dependentOptions: string[]
    fileName: string | null
    fileType: string | null
    fileLink: string | null
    fileSize: string | null
    documentType: string | null
    compulsory: boolean
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
    formId: string
    _count: ProductSubFormCountAggregateOutputType | null
    _min: ProductSubFormMinAggregateOutputType | null
    _max: ProductSubFormMaxAggregateOutputType | null
  }

  type GetProductSubFormGroupByPayload<T extends ProductSubFormGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProductSubFormGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductSubFormGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductSubFormGroupByOutputType[P]>
            : GetScalarType<T[P], ProductSubFormGroupByOutputType[P]>
        }
      >
    >


  export type ProductSubFormSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    options?: boolean
    type?: boolean
    allowOther?: boolean
    dependentField?: boolean
    dependentOptions?: boolean
    fileName?: boolean
    fileType?: boolean
    fileLink?: boolean
    fileSize?: boolean
    documentType?: boolean
    compulsory?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    formId?: boolean
    form?: boolean | ProductFormArgs<ExtArgs>
  }, ExtArgs["result"]["productSubForm"]>

  export type ProductSubFormSelectScalar = {
    id?: boolean
    question?: boolean
    options?: boolean
    type?: boolean
    allowOther?: boolean
    dependentField?: boolean
    dependentOptions?: boolean
    fileName?: boolean
    fileType?: boolean
    fileLink?: boolean
    fileSize?: boolean
    documentType?: boolean
    compulsory?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    formId?: boolean
  }

  export type ProductSubFormInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    form?: boolean | ProductFormArgs<ExtArgs>
  }


  type ProductSubFormGetPayload<S extends boolean | null | undefined | ProductSubFormArgs> = $Types.GetResult<ProductSubFormPayload, S>

  type ProductSubFormCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ProductSubFormFindManyArgs, 'select' | 'include'> & {
      select?: ProductSubFormCountAggregateInputType | true
    }

  export interface ProductSubFormDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductSubForm'], meta: { name: 'ProductSubForm' } }
    /**
     * Find zero or one ProductSubForm that matches the filter.
     * @param {ProductSubFormFindUniqueArgs} args - Arguments to find a ProductSubForm
     * @example
     * // Get one ProductSubForm
     * const productSubForm = await prisma.productSubForm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductSubFormFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductSubFormFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductSubForm'> extends True ? Prisma__ProductSubFormClient<$Types.GetResult<ProductSubFormPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ProductSubFormClient<$Types.GetResult<ProductSubFormPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ProductSubForm that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductSubFormFindUniqueOrThrowArgs} args - Arguments to find a ProductSubForm
     * @example
     * // Get one ProductSubForm
     * const productSubForm = await prisma.productSubForm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductSubFormFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductSubFormFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductSubFormClient<$Types.GetResult<ProductSubFormPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ProductSubForm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSubFormFindFirstArgs} args - Arguments to find a ProductSubForm
     * @example
     * // Get one ProductSubForm
     * const productSubForm = await prisma.productSubForm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductSubFormFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductSubFormFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductSubForm'> extends True ? Prisma__ProductSubFormClient<$Types.GetResult<ProductSubFormPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ProductSubFormClient<$Types.GetResult<ProductSubFormPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ProductSubForm that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSubFormFindFirstOrThrowArgs} args - Arguments to find a ProductSubForm
     * @example
     * // Get one ProductSubForm
     * const productSubForm = await prisma.productSubForm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductSubFormFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductSubFormFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductSubFormClient<$Types.GetResult<ProductSubFormPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more ProductSubForms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSubFormFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductSubForms
     * const productSubForms = await prisma.productSubForm.findMany()
     * 
     * // Get first 10 ProductSubForms
     * const productSubForms = await prisma.productSubForm.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productSubFormWithIdOnly = await prisma.productSubForm.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductSubFormFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductSubFormFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ProductSubFormPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ProductSubForm.
     * @param {ProductSubFormCreateArgs} args - Arguments to create a ProductSubForm.
     * @example
     * // Create one ProductSubForm
     * const ProductSubForm = await prisma.productSubForm.create({
     *   data: {
     *     // ... data to create a ProductSubForm
     *   }
     * })
     * 
    **/
    create<T extends ProductSubFormCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductSubFormCreateArgs<ExtArgs>>
    ): Prisma__ProductSubFormClient<$Types.GetResult<ProductSubFormPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many ProductSubForms.
     *     @param {ProductSubFormCreateManyArgs} args - Arguments to create many ProductSubForms.
     *     @example
     *     // Create many ProductSubForms
     *     const productSubForm = await prisma.productSubForm.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductSubFormCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductSubFormCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductSubForm.
     * @param {ProductSubFormDeleteArgs} args - Arguments to delete one ProductSubForm.
     * @example
     * // Delete one ProductSubForm
     * const ProductSubForm = await prisma.productSubForm.delete({
     *   where: {
     *     // ... filter to delete one ProductSubForm
     *   }
     * })
     * 
    **/
    delete<T extends ProductSubFormDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProductSubFormDeleteArgs<ExtArgs>>
    ): Prisma__ProductSubFormClient<$Types.GetResult<ProductSubFormPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ProductSubForm.
     * @param {ProductSubFormUpdateArgs} args - Arguments to update one ProductSubForm.
     * @example
     * // Update one ProductSubForm
     * const productSubForm = await prisma.productSubForm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductSubFormUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductSubFormUpdateArgs<ExtArgs>>
    ): Prisma__ProductSubFormClient<$Types.GetResult<ProductSubFormPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more ProductSubForms.
     * @param {ProductSubFormDeleteManyArgs} args - Arguments to filter ProductSubForms to delete.
     * @example
     * // Delete a few ProductSubForms
     * const { count } = await prisma.productSubForm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductSubFormDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductSubFormDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductSubForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSubFormUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductSubForms
     * const productSubForm = await prisma.productSubForm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductSubFormUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProductSubFormUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductSubForm.
     * @param {ProductSubFormUpsertArgs} args - Arguments to update or create a ProductSubForm.
     * @example
     * // Update or create a ProductSubForm
     * const productSubForm = await prisma.productSubForm.upsert({
     *   create: {
     *     // ... data to create a ProductSubForm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductSubForm we want to update
     *   }
     * })
    **/
    upsert<T extends ProductSubFormUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProductSubFormUpsertArgs<ExtArgs>>
    ): Prisma__ProductSubFormClient<$Types.GetResult<ProductSubFormPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of ProductSubForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSubFormCountArgs} args - Arguments to filter ProductSubForms to count.
     * @example
     * // Count the number of ProductSubForms
     * const count = await prisma.productSubForm.count({
     *   where: {
     *     // ... the filter for the ProductSubForms we want to count
     *   }
     * })
    **/
    count<T extends ProductSubFormCountArgs>(
      args?: Subset<T, ProductSubFormCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductSubFormCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductSubForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSubFormAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductSubFormAggregateArgs>(args: Subset<T, ProductSubFormAggregateArgs>): Prisma.PrismaPromise<GetProductSubFormAggregateType<T>>

    /**
     * Group by ProductSubForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSubFormGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductSubFormGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductSubFormGroupByArgs['orderBy'] }
        : { orderBy?: ProductSubFormGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductSubFormGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductSubFormGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductSubForm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductSubFormClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    form<T extends ProductFormArgs<ExtArgs> = {}>(args?: Subset<T, ProductFormArgs<ExtArgs>>): Prisma__ProductFormClient<$Types.GetResult<ProductFormPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ProductSubForm base type for findUnique actions
   */
  export type ProductSubFormFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSubForm
     */
    select?: ProductSubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductSubFormInclude<ExtArgs> | null
    /**
     * Filter, which ProductSubForm to fetch.
     */
    where: ProductSubFormWhereUniqueInput
  }

  /**
   * ProductSubForm findUnique
   */
  export interface ProductSubFormFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProductSubFormFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductSubForm findUniqueOrThrow
   */
  export type ProductSubFormFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSubForm
     */
    select?: ProductSubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductSubFormInclude<ExtArgs> | null
    /**
     * Filter, which ProductSubForm to fetch.
     */
    where: ProductSubFormWhereUniqueInput
  }


  /**
   * ProductSubForm base type for findFirst actions
   */
  export type ProductSubFormFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSubForm
     */
    select?: ProductSubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductSubFormInclude<ExtArgs> | null
    /**
     * Filter, which ProductSubForm to fetch.
     */
    where?: ProductSubFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductSubForms to fetch.
     */
    orderBy?: Enumerable<ProductSubFormOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductSubForms.
     */
    cursor?: ProductSubFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductSubForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductSubForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductSubForms.
     */
    distinct?: Enumerable<ProductSubFormScalarFieldEnum>
  }

  /**
   * ProductSubForm findFirst
   */
  export interface ProductSubFormFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProductSubFormFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductSubForm findFirstOrThrow
   */
  export type ProductSubFormFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSubForm
     */
    select?: ProductSubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductSubFormInclude<ExtArgs> | null
    /**
     * Filter, which ProductSubForm to fetch.
     */
    where?: ProductSubFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductSubForms to fetch.
     */
    orderBy?: Enumerable<ProductSubFormOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductSubForms.
     */
    cursor?: ProductSubFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductSubForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductSubForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductSubForms.
     */
    distinct?: Enumerable<ProductSubFormScalarFieldEnum>
  }


  /**
   * ProductSubForm findMany
   */
  export type ProductSubFormFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSubForm
     */
    select?: ProductSubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductSubFormInclude<ExtArgs> | null
    /**
     * Filter, which ProductSubForms to fetch.
     */
    where?: ProductSubFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductSubForms to fetch.
     */
    orderBy?: Enumerable<ProductSubFormOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductSubForms.
     */
    cursor?: ProductSubFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductSubForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductSubForms.
     */
    skip?: number
    distinct?: Enumerable<ProductSubFormScalarFieldEnum>
  }


  /**
   * ProductSubForm create
   */
  export type ProductSubFormCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSubForm
     */
    select?: ProductSubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductSubFormInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductSubForm.
     */
    data: XOR<ProductSubFormCreateInput, ProductSubFormUncheckedCreateInput>
  }


  /**
   * ProductSubForm createMany
   */
  export type ProductSubFormCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductSubForms.
     */
    data: Enumerable<ProductSubFormCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductSubForm update
   */
  export type ProductSubFormUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSubForm
     */
    select?: ProductSubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductSubFormInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductSubForm.
     */
    data: XOR<ProductSubFormUpdateInput, ProductSubFormUncheckedUpdateInput>
    /**
     * Choose, which ProductSubForm to update.
     */
    where: ProductSubFormWhereUniqueInput
  }


  /**
   * ProductSubForm updateMany
   */
  export type ProductSubFormUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductSubForms.
     */
    data: XOR<ProductSubFormUpdateManyMutationInput, ProductSubFormUncheckedUpdateManyInput>
    /**
     * Filter which ProductSubForms to update
     */
    where?: ProductSubFormWhereInput
  }


  /**
   * ProductSubForm upsert
   */
  export type ProductSubFormUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSubForm
     */
    select?: ProductSubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductSubFormInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductSubForm to update in case it exists.
     */
    where: ProductSubFormWhereUniqueInput
    /**
     * In case the ProductSubForm found by the `where` argument doesn't exist, create a new ProductSubForm with this data.
     */
    create: XOR<ProductSubFormCreateInput, ProductSubFormUncheckedCreateInput>
    /**
     * In case the ProductSubForm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductSubFormUpdateInput, ProductSubFormUncheckedUpdateInput>
  }


  /**
   * ProductSubForm delete
   */
  export type ProductSubFormDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSubForm
     */
    select?: ProductSubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductSubFormInclude<ExtArgs> | null
    /**
     * Filter which ProductSubForm to delete.
     */
    where: ProductSubFormWhereUniqueInput
  }


  /**
   * ProductSubForm deleteMany
   */
  export type ProductSubFormDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductSubForms to delete
     */
    where?: ProductSubFormWhereInput
  }


  /**
   * ProductSubForm without action
   */
  export type ProductSubFormArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSubForm
     */
    select?: ProductSubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductSubFormInclude<ExtArgs> | null
  }



  /**
   * Model ProductRequest
   */


  export type AggregateProductRequest = {
    _count: ProductRequestCountAggregateOutputType | null
    _min: ProductRequestMinAggregateOutputType | null
    _max: ProductRequestMaxAggregateOutputType | null
  }

  export type ProductRequestMinAggregateOutputType = {
    id: string | null
    email: string | null
    address: string | null
    paid: boolean | null
    completed: boolean | null
    status: string | null
    currentState: ProductActivityStage | null
    createdAt: Date | null
    isDeprecated: boolean | null
    updatedAt: Date | null
    productId: string | null
    userId: string | null
  }

  export type ProductRequestMaxAggregateOutputType = {
    id: string | null
    email: string | null
    address: string | null
    paid: boolean | null
    completed: boolean | null
    status: string | null
    currentState: ProductActivityStage | null
    createdAt: Date | null
    isDeprecated: boolean | null
    updatedAt: Date | null
    productId: string | null
    userId: string | null
  }

  export type ProductRequestCountAggregateOutputType = {
    id: number
    email: number
    address: number
    paid: number
    completed: number
    status: number
    currentState: number
    createdAt: number
    isDeprecated: number
    updatedAt: number
    productId: number
    userId: number
    _all: number
  }


  export type ProductRequestMinAggregateInputType = {
    id?: true
    email?: true
    address?: true
    paid?: true
    completed?: true
    status?: true
    currentState?: true
    createdAt?: true
    isDeprecated?: true
    updatedAt?: true
    productId?: true
    userId?: true
  }

  export type ProductRequestMaxAggregateInputType = {
    id?: true
    email?: true
    address?: true
    paid?: true
    completed?: true
    status?: true
    currentState?: true
    createdAt?: true
    isDeprecated?: true
    updatedAt?: true
    productId?: true
    userId?: true
  }

  export type ProductRequestCountAggregateInputType = {
    id?: true
    email?: true
    address?: true
    paid?: true
    completed?: true
    status?: true
    currentState?: true
    createdAt?: true
    isDeprecated?: true
    updatedAt?: true
    productId?: true
    userId?: true
    _all?: true
  }

  export type ProductRequestAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductRequest to aggregate.
     */
    where?: ProductRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductRequests to fetch.
     */
    orderBy?: Enumerable<ProductRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductRequests
    **/
    _count?: true | ProductRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductRequestMaxAggregateInputType
  }

  export type GetProductRequestAggregateType<T extends ProductRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateProductRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductRequest[P]>
      : GetScalarType<T[P], AggregateProductRequest[P]>
  }




  export type ProductRequestGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductRequestWhereInput
    orderBy?: Enumerable<ProductRequestOrderByWithAggregationInput>
    by: ProductRequestScalarFieldEnum[]
    having?: ProductRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductRequestCountAggregateInputType | true
    _min?: ProductRequestMinAggregateInputType
    _max?: ProductRequestMaxAggregateInputType
  }


  export type ProductRequestGroupByOutputType = {
    id: string
    email: string | null
    address: string | null
    paid: boolean
    completed: boolean
    status: string
    currentState: ProductActivityStage
    createdAt: Date
    isDeprecated: boolean
    updatedAt: Date
    productId: string | null
    userId: string
    _count: ProductRequestCountAggregateOutputType | null
    _min: ProductRequestMinAggregateOutputType | null
    _max: ProductRequestMaxAggregateOutputType | null
  }

  type GetProductRequestGroupByPayload<T extends ProductRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProductRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductRequestGroupByOutputType[P]>
            : GetScalarType<T[P], ProductRequestGroupByOutputType[P]>
        }
      >
    >


  export type ProductRequestSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    address?: boolean
    paid?: boolean
    completed?: boolean
    status?: boolean
    currentState?: boolean
    createdAt?: boolean
    isDeprecated?: boolean
    updatedAt?: boolean
    productId?: boolean
    userId?: boolean
    Team?: boolean | ProductRequest$TeamArgs<ExtArgs>
    product?: boolean | ProductArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
    Payment?: boolean | ProductRequest$PaymentArgs<ExtArgs>
    requestQA?: boolean | ProductRequest$requestQAArgs<ExtArgs>
    _count?: boolean | ProductRequestCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["productRequest"]>

  export type ProductRequestSelectScalar = {
    id?: boolean
    email?: boolean
    address?: boolean
    paid?: boolean
    completed?: boolean
    status?: boolean
    currentState?: boolean
    createdAt?: boolean
    isDeprecated?: boolean
    updatedAt?: boolean
    productId?: boolean
    userId?: boolean
  }

  export type ProductRequestInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Team?: boolean | ProductRequest$TeamArgs<ExtArgs>
    product?: boolean | ProductArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
    Payment?: boolean | ProductRequest$PaymentArgs<ExtArgs>
    requestQA?: boolean | ProductRequest$requestQAArgs<ExtArgs>
    _count?: boolean | ProductRequestCountOutputTypeArgs<ExtArgs>
  }


  type ProductRequestGetPayload<S extends boolean | null | undefined | ProductRequestArgs> = $Types.GetResult<ProductRequestPayload, S>

  type ProductRequestCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ProductRequestFindManyArgs, 'select' | 'include'> & {
      select?: ProductRequestCountAggregateInputType | true
    }

  export interface ProductRequestDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductRequest'], meta: { name: 'ProductRequest' } }
    /**
     * Find zero or one ProductRequest that matches the filter.
     * @param {ProductRequestFindUniqueArgs} args - Arguments to find a ProductRequest
     * @example
     * // Get one ProductRequest
     * const productRequest = await prisma.productRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductRequestFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductRequestFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductRequest'> extends True ? Prisma__ProductRequestClient<$Types.GetResult<ProductRequestPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ProductRequestClient<$Types.GetResult<ProductRequestPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ProductRequest that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductRequestFindUniqueOrThrowArgs} args - Arguments to find a ProductRequest
     * @example
     * // Get one ProductRequest
     * const productRequest = await prisma.productRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductRequestFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductRequestFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductRequestClient<$Types.GetResult<ProductRequestPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ProductRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRequestFindFirstArgs} args - Arguments to find a ProductRequest
     * @example
     * // Get one ProductRequest
     * const productRequest = await prisma.productRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductRequestFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductRequestFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductRequest'> extends True ? Prisma__ProductRequestClient<$Types.GetResult<ProductRequestPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ProductRequestClient<$Types.GetResult<ProductRequestPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ProductRequest that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRequestFindFirstOrThrowArgs} args - Arguments to find a ProductRequest
     * @example
     * // Get one ProductRequest
     * const productRequest = await prisma.productRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductRequestFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductRequestFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductRequestClient<$Types.GetResult<ProductRequestPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more ProductRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRequestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductRequests
     * const productRequests = await prisma.productRequest.findMany()
     * 
     * // Get first 10 ProductRequests
     * const productRequests = await prisma.productRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productRequestWithIdOnly = await prisma.productRequest.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductRequestFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductRequestFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ProductRequestPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ProductRequest.
     * @param {ProductRequestCreateArgs} args - Arguments to create a ProductRequest.
     * @example
     * // Create one ProductRequest
     * const ProductRequest = await prisma.productRequest.create({
     *   data: {
     *     // ... data to create a ProductRequest
     *   }
     * })
     * 
    **/
    create<T extends ProductRequestCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductRequestCreateArgs<ExtArgs>>
    ): Prisma__ProductRequestClient<$Types.GetResult<ProductRequestPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many ProductRequests.
     *     @param {ProductRequestCreateManyArgs} args - Arguments to create many ProductRequests.
     *     @example
     *     // Create many ProductRequests
     *     const productRequest = await prisma.productRequest.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductRequestCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductRequestCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductRequest.
     * @param {ProductRequestDeleteArgs} args - Arguments to delete one ProductRequest.
     * @example
     * // Delete one ProductRequest
     * const ProductRequest = await prisma.productRequest.delete({
     *   where: {
     *     // ... filter to delete one ProductRequest
     *   }
     * })
     * 
    **/
    delete<T extends ProductRequestDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProductRequestDeleteArgs<ExtArgs>>
    ): Prisma__ProductRequestClient<$Types.GetResult<ProductRequestPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ProductRequest.
     * @param {ProductRequestUpdateArgs} args - Arguments to update one ProductRequest.
     * @example
     * // Update one ProductRequest
     * const productRequest = await prisma.productRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductRequestUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductRequestUpdateArgs<ExtArgs>>
    ): Prisma__ProductRequestClient<$Types.GetResult<ProductRequestPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more ProductRequests.
     * @param {ProductRequestDeleteManyArgs} args - Arguments to filter ProductRequests to delete.
     * @example
     * // Delete a few ProductRequests
     * const { count } = await prisma.productRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductRequestDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductRequestDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductRequests
     * const productRequest = await prisma.productRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductRequestUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProductRequestUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductRequest.
     * @param {ProductRequestUpsertArgs} args - Arguments to update or create a ProductRequest.
     * @example
     * // Update or create a ProductRequest
     * const productRequest = await prisma.productRequest.upsert({
     *   create: {
     *     // ... data to create a ProductRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductRequest we want to update
     *   }
     * })
    **/
    upsert<T extends ProductRequestUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProductRequestUpsertArgs<ExtArgs>>
    ): Prisma__ProductRequestClient<$Types.GetResult<ProductRequestPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of ProductRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRequestCountArgs} args - Arguments to filter ProductRequests to count.
     * @example
     * // Count the number of ProductRequests
     * const count = await prisma.productRequest.count({
     *   where: {
     *     // ... the filter for the ProductRequests we want to count
     *   }
     * })
    **/
    count<T extends ProductRequestCountArgs>(
      args?: Subset<T, ProductRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductRequestAggregateArgs>(args: Subset<T, ProductRequestAggregateArgs>): Prisma.PrismaPromise<GetProductRequestAggregateType<T>>

    /**
     * Group by ProductRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductRequestGroupByArgs['orderBy'] }
        : { orderBy?: ProductRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductRequestClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Team<T extends ProductRequest$TeamArgs<ExtArgs> = {}>(args?: Subset<T, ProductRequest$TeamArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<TeamPayload<ExtArgs>, T, 'findMany', never>| Null>;

    product<T extends ProductArgs<ExtArgs> = {}>(args?: Subset<T, ProductArgs<ExtArgs>>): Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    Payment<T extends ProductRequest$PaymentArgs<ExtArgs> = {}>(args?: Subset<T, ProductRequest$PaymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    requestQA<T extends ProductRequest$requestQAArgs<ExtArgs> = {}>(args?: Subset<T, ProductRequest$requestQAArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ProductRequestQAPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ProductRequest base type for findUnique actions
   */
  export type ProductRequestFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRequest
     */
    select?: ProductRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductRequestInclude<ExtArgs> | null
    /**
     * Filter, which ProductRequest to fetch.
     */
    where: ProductRequestWhereUniqueInput
  }

  /**
   * ProductRequest findUnique
   */
  export interface ProductRequestFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProductRequestFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductRequest findUniqueOrThrow
   */
  export type ProductRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRequest
     */
    select?: ProductRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductRequestInclude<ExtArgs> | null
    /**
     * Filter, which ProductRequest to fetch.
     */
    where: ProductRequestWhereUniqueInput
  }


  /**
   * ProductRequest base type for findFirst actions
   */
  export type ProductRequestFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRequest
     */
    select?: ProductRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductRequestInclude<ExtArgs> | null
    /**
     * Filter, which ProductRequest to fetch.
     */
    where?: ProductRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductRequests to fetch.
     */
    orderBy?: Enumerable<ProductRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductRequests.
     */
    cursor?: ProductRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductRequests.
     */
    distinct?: Enumerable<ProductRequestScalarFieldEnum>
  }

  /**
   * ProductRequest findFirst
   */
  export interface ProductRequestFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProductRequestFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductRequest findFirstOrThrow
   */
  export type ProductRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRequest
     */
    select?: ProductRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductRequestInclude<ExtArgs> | null
    /**
     * Filter, which ProductRequest to fetch.
     */
    where?: ProductRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductRequests to fetch.
     */
    orderBy?: Enumerable<ProductRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductRequests.
     */
    cursor?: ProductRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductRequests.
     */
    distinct?: Enumerable<ProductRequestScalarFieldEnum>
  }


  /**
   * ProductRequest findMany
   */
  export type ProductRequestFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRequest
     */
    select?: ProductRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductRequestInclude<ExtArgs> | null
    /**
     * Filter, which ProductRequests to fetch.
     */
    where?: ProductRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductRequests to fetch.
     */
    orderBy?: Enumerable<ProductRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductRequests.
     */
    cursor?: ProductRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductRequests.
     */
    skip?: number
    distinct?: Enumerable<ProductRequestScalarFieldEnum>
  }


  /**
   * ProductRequest create
   */
  export type ProductRequestCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRequest
     */
    select?: ProductRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductRequest.
     */
    data: XOR<ProductRequestCreateInput, ProductRequestUncheckedCreateInput>
  }


  /**
   * ProductRequest createMany
   */
  export type ProductRequestCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductRequests.
     */
    data: Enumerable<ProductRequestCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductRequest update
   */
  export type ProductRequestUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRequest
     */
    select?: ProductRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductRequest.
     */
    data: XOR<ProductRequestUpdateInput, ProductRequestUncheckedUpdateInput>
    /**
     * Choose, which ProductRequest to update.
     */
    where: ProductRequestWhereUniqueInput
  }


  /**
   * ProductRequest updateMany
   */
  export type ProductRequestUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductRequests.
     */
    data: XOR<ProductRequestUpdateManyMutationInput, ProductRequestUncheckedUpdateManyInput>
    /**
     * Filter which ProductRequests to update
     */
    where?: ProductRequestWhereInput
  }


  /**
   * ProductRequest upsert
   */
  export type ProductRequestUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRequest
     */
    select?: ProductRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductRequest to update in case it exists.
     */
    where: ProductRequestWhereUniqueInput
    /**
     * In case the ProductRequest found by the `where` argument doesn't exist, create a new ProductRequest with this data.
     */
    create: XOR<ProductRequestCreateInput, ProductRequestUncheckedCreateInput>
    /**
     * In case the ProductRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductRequestUpdateInput, ProductRequestUncheckedUpdateInput>
  }


  /**
   * ProductRequest delete
   */
  export type ProductRequestDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRequest
     */
    select?: ProductRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductRequestInclude<ExtArgs> | null
    /**
     * Filter which ProductRequest to delete.
     */
    where: ProductRequestWhereUniqueInput
  }


  /**
   * ProductRequest deleteMany
   */
  export type ProductRequestDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductRequests to delete
     */
    where?: ProductRequestWhereInput
  }


  /**
   * ProductRequest.Team
   */
  export type ProductRequest$TeamArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
    orderBy?: Enumerable<TeamOrderByWithRelationInput>
    cursor?: TeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TeamScalarFieldEnum>
  }


  /**
   * ProductRequest.Payment
   */
  export type ProductRequest$PaymentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: Enumerable<PaymentOrderByWithRelationInput>
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }


  /**
   * ProductRequest.requestQA
   */
  export type ProductRequest$requestQAArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRequestQA
     */
    select?: ProductRequestQASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductRequestQAInclude<ExtArgs> | null
    where?: ProductRequestQAWhereInput
    orderBy?: Enumerable<ProductRequestQAOrderByWithRelationInput>
    cursor?: ProductRequestQAWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductRequestQAScalarFieldEnum>
  }


  /**
   * ProductRequest without action
   */
  export type ProductRequestArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRequest
     */
    select?: ProductRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductRequestInclude<ExtArgs> | null
  }



  /**
   * Model ProductRequestQA
   */


  export type AggregateProductRequestQA = {
    _count: ProductRequestQACountAggregateOutputType | null
    _min: ProductRequestQAMinAggregateOutputType | null
    _max: ProductRequestQAMaxAggregateOutputType | null
  }

  export type ProductRequestQAMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    type: string | null
    compulsory: boolean | null
    isGeneral: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeprecated: boolean | null
    requestId: string | null
  }

  export type ProductRequestQAMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    type: string | null
    compulsory: boolean | null
    isGeneral: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeprecated: boolean | null
    requestId: string | null
  }

  export type ProductRequestQACountAggregateOutputType = {
    id: number
    title: number
    description: number
    type: number
    compulsory: number
    isGeneral: number
    createdAt: number
    updatedAt: number
    isDeprecated: number
    requestId: number
    _all: number
  }


  export type ProductRequestQAMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    compulsory?: true
    isGeneral?: true
    createdAt?: true
    updatedAt?: true
    isDeprecated?: true
    requestId?: true
  }

  export type ProductRequestQAMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    compulsory?: true
    isGeneral?: true
    createdAt?: true
    updatedAt?: true
    isDeprecated?: true
    requestId?: true
  }

  export type ProductRequestQACountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    compulsory?: true
    isGeneral?: true
    createdAt?: true
    updatedAt?: true
    isDeprecated?: true
    requestId?: true
    _all?: true
  }

  export type ProductRequestQAAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductRequestQA to aggregate.
     */
    where?: ProductRequestQAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductRequestQAS to fetch.
     */
    orderBy?: Enumerable<ProductRequestQAOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductRequestQAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductRequestQAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductRequestQAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductRequestQAS
    **/
    _count?: true | ProductRequestQACountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductRequestQAMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductRequestQAMaxAggregateInputType
  }

  export type GetProductRequestQAAggregateType<T extends ProductRequestQAAggregateArgs> = {
        [P in keyof T & keyof AggregateProductRequestQA]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductRequestQA[P]>
      : GetScalarType<T[P], AggregateProductRequestQA[P]>
  }




  export type ProductRequestQAGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductRequestQAWhereInput
    orderBy?: Enumerable<ProductRequestQAOrderByWithAggregationInput>
    by: ProductRequestQAScalarFieldEnum[]
    having?: ProductRequestQAScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductRequestQACountAggregateInputType | true
    _min?: ProductRequestQAMinAggregateInputType
    _max?: ProductRequestQAMaxAggregateInputType
  }


  export type ProductRequestQAGroupByOutputType = {
    id: string
    title: string | null
    description: string | null
    type: string | null
    compulsory: boolean
    isGeneral: boolean
    createdAt: Date
    updatedAt: Date
    isDeprecated: boolean
    requestId: string
    _count: ProductRequestQACountAggregateOutputType | null
    _min: ProductRequestQAMinAggregateOutputType | null
    _max: ProductRequestQAMaxAggregateOutputType | null
  }

  type GetProductRequestQAGroupByPayload<T extends ProductRequestQAGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProductRequestQAGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductRequestQAGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductRequestQAGroupByOutputType[P]>
            : GetScalarType<T[P], ProductRequestQAGroupByOutputType[P]>
        }
      >
    >


  export type ProductRequestQASelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    compulsory?: boolean
    isGeneral?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeprecated?: boolean
    requestId?: boolean
    request?: boolean | ProductRequestArgs<ExtArgs>
    subForm?: boolean | ProductRequestQA$subFormArgs<ExtArgs>
    _count?: boolean | ProductRequestQACountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["productRequestQA"]>

  export type ProductRequestQASelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    compulsory?: boolean
    isGeneral?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeprecated?: boolean
    requestId?: boolean
  }

  export type ProductRequestQAInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    request?: boolean | ProductRequestArgs<ExtArgs>
    subForm?: boolean | ProductRequestQA$subFormArgs<ExtArgs>
    _count?: boolean | ProductRequestQACountOutputTypeArgs<ExtArgs>
  }


  type ProductRequestQAGetPayload<S extends boolean | null | undefined | ProductRequestQAArgs> = $Types.GetResult<ProductRequestQAPayload, S>

  type ProductRequestQACountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ProductRequestQAFindManyArgs, 'select' | 'include'> & {
      select?: ProductRequestQACountAggregateInputType | true
    }

  export interface ProductRequestQADelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductRequestQA'], meta: { name: 'ProductRequestQA' } }
    /**
     * Find zero or one ProductRequestQA that matches the filter.
     * @param {ProductRequestQAFindUniqueArgs} args - Arguments to find a ProductRequestQA
     * @example
     * // Get one ProductRequestQA
     * const productRequestQA = await prisma.productRequestQA.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductRequestQAFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductRequestQAFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductRequestQA'> extends True ? Prisma__ProductRequestQAClient<$Types.GetResult<ProductRequestQAPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ProductRequestQAClient<$Types.GetResult<ProductRequestQAPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ProductRequestQA that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductRequestQAFindUniqueOrThrowArgs} args - Arguments to find a ProductRequestQA
     * @example
     * // Get one ProductRequestQA
     * const productRequestQA = await prisma.productRequestQA.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductRequestQAFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductRequestQAFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductRequestQAClient<$Types.GetResult<ProductRequestQAPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ProductRequestQA that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRequestQAFindFirstArgs} args - Arguments to find a ProductRequestQA
     * @example
     * // Get one ProductRequestQA
     * const productRequestQA = await prisma.productRequestQA.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductRequestQAFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductRequestQAFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductRequestQA'> extends True ? Prisma__ProductRequestQAClient<$Types.GetResult<ProductRequestQAPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ProductRequestQAClient<$Types.GetResult<ProductRequestQAPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ProductRequestQA that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRequestQAFindFirstOrThrowArgs} args - Arguments to find a ProductRequestQA
     * @example
     * // Get one ProductRequestQA
     * const productRequestQA = await prisma.productRequestQA.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductRequestQAFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductRequestQAFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductRequestQAClient<$Types.GetResult<ProductRequestQAPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more ProductRequestQAS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRequestQAFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductRequestQAS
     * const productRequestQAS = await prisma.productRequestQA.findMany()
     * 
     * // Get first 10 ProductRequestQAS
     * const productRequestQAS = await prisma.productRequestQA.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productRequestQAWithIdOnly = await prisma.productRequestQA.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductRequestQAFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductRequestQAFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ProductRequestQAPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ProductRequestQA.
     * @param {ProductRequestQACreateArgs} args - Arguments to create a ProductRequestQA.
     * @example
     * // Create one ProductRequestQA
     * const ProductRequestQA = await prisma.productRequestQA.create({
     *   data: {
     *     // ... data to create a ProductRequestQA
     *   }
     * })
     * 
    **/
    create<T extends ProductRequestQACreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductRequestQACreateArgs<ExtArgs>>
    ): Prisma__ProductRequestQAClient<$Types.GetResult<ProductRequestQAPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many ProductRequestQAS.
     *     @param {ProductRequestQACreateManyArgs} args - Arguments to create many ProductRequestQAS.
     *     @example
     *     // Create many ProductRequestQAS
     *     const productRequestQA = await prisma.productRequestQA.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductRequestQACreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductRequestQACreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductRequestQA.
     * @param {ProductRequestQADeleteArgs} args - Arguments to delete one ProductRequestQA.
     * @example
     * // Delete one ProductRequestQA
     * const ProductRequestQA = await prisma.productRequestQA.delete({
     *   where: {
     *     // ... filter to delete one ProductRequestQA
     *   }
     * })
     * 
    **/
    delete<T extends ProductRequestQADeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProductRequestQADeleteArgs<ExtArgs>>
    ): Prisma__ProductRequestQAClient<$Types.GetResult<ProductRequestQAPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ProductRequestQA.
     * @param {ProductRequestQAUpdateArgs} args - Arguments to update one ProductRequestQA.
     * @example
     * // Update one ProductRequestQA
     * const productRequestQA = await prisma.productRequestQA.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductRequestQAUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductRequestQAUpdateArgs<ExtArgs>>
    ): Prisma__ProductRequestQAClient<$Types.GetResult<ProductRequestQAPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more ProductRequestQAS.
     * @param {ProductRequestQADeleteManyArgs} args - Arguments to filter ProductRequestQAS to delete.
     * @example
     * // Delete a few ProductRequestQAS
     * const { count } = await prisma.productRequestQA.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductRequestQADeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductRequestQADeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductRequestQAS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRequestQAUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductRequestQAS
     * const productRequestQA = await prisma.productRequestQA.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductRequestQAUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProductRequestQAUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductRequestQA.
     * @param {ProductRequestQAUpsertArgs} args - Arguments to update or create a ProductRequestQA.
     * @example
     * // Update or create a ProductRequestQA
     * const productRequestQA = await prisma.productRequestQA.upsert({
     *   create: {
     *     // ... data to create a ProductRequestQA
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductRequestQA we want to update
     *   }
     * })
    **/
    upsert<T extends ProductRequestQAUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProductRequestQAUpsertArgs<ExtArgs>>
    ): Prisma__ProductRequestQAClient<$Types.GetResult<ProductRequestQAPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of ProductRequestQAS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRequestQACountArgs} args - Arguments to filter ProductRequestQAS to count.
     * @example
     * // Count the number of ProductRequestQAS
     * const count = await prisma.productRequestQA.count({
     *   where: {
     *     // ... the filter for the ProductRequestQAS we want to count
     *   }
     * })
    **/
    count<T extends ProductRequestQACountArgs>(
      args?: Subset<T, ProductRequestQACountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductRequestQACountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductRequestQA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRequestQAAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductRequestQAAggregateArgs>(args: Subset<T, ProductRequestQAAggregateArgs>): Prisma.PrismaPromise<GetProductRequestQAAggregateType<T>>

    /**
     * Group by ProductRequestQA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRequestQAGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductRequestQAGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductRequestQAGroupByArgs['orderBy'] }
        : { orderBy?: ProductRequestQAGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductRequestQAGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductRequestQAGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductRequestQA.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductRequestQAClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    request<T extends ProductRequestArgs<ExtArgs> = {}>(args?: Subset<T, ProductRequestArgs<ExtArgs>>): Prisma__ProductRequestClient<$Types.GetResult<ProductRequestPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    subForm<T extends ProductRequestQA$subFormArgs<ExtArgs> = {}>(args?: Subset<T, ProductRequestQA$subFormArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ProductRequestQASubFormPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ProductRequestQA base type for findUnique actions
   */
  export type ProductRequestQAFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRequestQA
     */
    select?: ProductRequestQASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductRequestQAInclude<ExtArgs> | null
    /**
     * Filter, which ProductRequestQA to fetch.
     */
    where: ProductRequestQAWhereUniqueInput
  }

  /**
   * ProductRequestQA findUnique
   */
  export interface ProductRequestQAFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProductRequestQAFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductRequestQA findUniqueOrThrow
   */
  export type ProductRequestQAFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRequestQA
     */
    select?: ProductRequestQASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductRequestQAInclude<ExtArgs> | null
    /**
     * Filter, which ProductRequestQA to fetch.
     */
    where: ProductRequestQAWhereUniqueInput
  }


  /**
   * ProductRequestQA base type for findFirst actions
   */
  export type ProductRequestQAFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRequestQA
     */
    select?: ProductRequestQASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductRequestQAInclude<ExtArgs> | null
    /**
     * Filter, which ProductRequestQA to fetch.
     */
    where?: ProductRequestQAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductRequestQAS to fetch.
     */
    orderBy?: Enumerable<ProductRequestQAOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductRequestQAS.
     */
    cursor?: ProductRequestQAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductRequestQAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductRequestQAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductRequestQAS.
     */
    distinct?: Enumerable<ProductRequestQAScalarFieldEnum>
  }

  /**
   * ProductRequestQA findFirst
   */
  export interface ProductRequestQAFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProductRequestQAFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductRequestQA findFirstOrThrow
   */
  export type ProductRequestQAFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRequestQA
     */
    select?: ProductRequestQASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductRequestQAInclude<ExtArgs> | null
    /**
     * Filter, which ProductRequestQA to fetch.
     */
    where?: ProductRequestQAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductRequestQAS to fetch.
     */
    orderBy?: Enumerable<ProductRequestQAOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductRequestQAS.
     */
    cursor?: ProductRequestQAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductRequestQAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductRequestQAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductRequestQAS.
     */
    distinct?: Enumerable<ProductRequestQAScalarFieldEnum>
  }


  /**
   * ProductRequestQA findMany
   */
  export type ProductRequestQAFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRequestQA
     */
    select?: ProductRequestQASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductRequestQAInclude<ExtArgs> | null
    /**
     * Filter, which ProductRequestQAS to fetch.
     */
    where?: ProductRequestQAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductRequestQAS to fetch.
     */
    orderBy?: Enumerable<ProductRequestQAOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductRequestQAS.
     */
    cursor?: ProductRequestQAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductRequestQAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductRequestQAS.
     */
    skip?: number
    distinct?: Enumerable<ProductRequestQAScalarFieldEnum>
  }


  /**
   * ProductRequestQA create
   */
  export type ProductRequestQACreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRequestQA
     */
    select?: ProductRequestQASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductRequestQAInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductRequestQA.
     */
    data: XOR<ProductRequestQACreateInput, ProductRequestQAUncheckedCreateInput>
  }


  /**
   * ProductRequestQA createMany
   */
  export type ProductRequestQACreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductRequestQAS.
     */
    data: Enumerable<ProductRequestQACreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductRequestQA update
   */
  export type ProductRequestQAUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRequestQA
     */
    select?: ProductRequestQASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductRequestQAInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductRequestQA.
     */
    data: XOR<ProductRequestQAUpdateInput, ProductRequestQAUncheckedUpdateInput>
    /**
     * Choose, which ProductRequestQA to update.
     */
    where: ProductRequestQAWhereUniqueInput
  }


  /**
   * ProductRequestQA updateMany
   */
  export type ProductRequestQAUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductRequestQAS.
     */
    data: XOR<ProductRequestQAUpdateManyMutationInput, ProductRequestQAUncheckedUpdateManyInput>
    /**
     * Filter which ProductRequestQAS to update
     */
    where?: ProductRequestQAWhereInput
  }


  /**
   * ProductRequestQA upsert
   */
  export type ProductRequestQAUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRequestQA
     */
    select?: ProductRequestQASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductRequestQAInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductRequestQA to update in case it exists.
     */
    where: ProductRequestQAWhereUniqueInput
    /**
     * In case the ProductRequestQA found by the `where` argument doesn't exist, create a new ProductRequestQA with this data.
     */
    create: XOR<ProductRequestQACreateInput, ProductRequestQAUncheckedCreateInput>
    /**
     * In case the ProductRequestQA was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductRequestQAUpdateInput, ProductRequestQAUncheckedUpdateInput>
  }


  /**
   * ProductRequestQA delete
   */
  export type ProductRequestQADeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRequestQA
     */
    select?: ProductRequestQASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductRequestQAInclude<ExtArgs> | null
    /**
     * Filter which ProductRequestQA to delete.
     */
    where: ProductRequestQAWhereUniqueInput
  }


  /**
   * ProductRequestQA deleteMany
   */
  export type ProductRequestQADeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductRequestQAS to delete
     */
    where?: ProductRequestQAWhereInput
  }


  /**
   * ProductRequestQA.subForm
   */
  export type ProductRequestQA$subFormArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRequestQASubForm
     */
    select?: ProductRequestQASubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductRequestQASubFormInclude<ExtArgs> | null
    where?: ProductRequestQASubFormWhereInput
    orderBy?: Enumerable<ProductRequestQASubFormOrderByWithRelationInput>
    cursor?: ProductRequestQASubFormWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductRequestQASubFormScalarFieldEnum>
  }


  /**
   * ProductRequestQA without action
   */
  export type ProductRequestQAArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRequestQA
     */
    select?: ProductRequestQASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductRequestQAInclude<ExtArgs> | null
  }



  /**
   * Model ProductRequestQASubForm
   */


  export type AggregateProductRequestQASubForm = {
    _count: ProductRequestQASubFormCountAggregateOutputType | null
    _min: ProductRequestQASubFormMinAggregateOutputType | null
    _max: ProductRequestQASubFormMaxAggregateOutputType | null
  }

  export type ProductRequestQASubFormMinAggregateOutputType = {
    id: string | null
    question: string | null
    type: string | null
    fileName: string | null
    fileType: string | null
    fileLink: string | null
    fileSize: string | null
    compulsory: boolean | null
    isDeprecated: boolean | null
    requestQAId: string | null
  }

  export type ProductRequestQASubFormMaxAggregateOutputType = {
    id: string | null
    question: string | null
    type: string | null
    fileName: string | null
    fileType: string | null
    fileLink: string | null
    fileSize: string | null
    compulsory: boolean | null
    isDeprecated: boolean | null
    requestQAId: string | null
  }

  export type ProductRequestQASubFormCountAggregateOutputType = {
    id: number
    question: number
    answer: number
    type: number
    fileName: number
    fileType: number
    fileLink: number
    fileSize: number
    compulsory: number
    isDeprecated: number
    requestQAId: number
    _all: number
  }


  export type ProductRequestQASubFormMinAggregateInputType = {
    id?: true
    question?: true
    type?: true
    fileName?: true
    fileType?: true
    fileLink?: true
    fileSize?: true
    compulsory?: true
    isDeprecated?: true
    requestQAId?: true
  }

  export type ProductRequestQASubFormMaxAggregateInputType = {
    id?: true
    question?: true
    type?: true
    fileName?: true
    fileType?: true
    fileLink?: true
    fileSize?: true
    compulsory?: true
    isDeprecated?: true
    requestQAId?: true
  }

  export type ProductRequestQASubFormCountAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    type?: true
    fileName?: true
    fileType?: true
    fileLink?: true
    fileSize?: true
    compulsory?: true
    isDeprecated?: true
    requestQAId?: true
    _all?: true
  }

  export type ProductRequestQASubFormAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductRequestQASubForm to aggregate.
     */
    where?: ProductRequestQASubFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductRequestQASubForms to fetch.
     */
    orderBy?: Enumerable<ProductRequestQASubFormOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductRequestQASubFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductRequestQASubForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductRequestQASubForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductRequestQASubForms
    **/
    _count?: true | ProductRequestQASubFormCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductRequestQASubFormMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductRequestQASubFormMaxAggregateInputType
  }

  export type GetProductRequestQASubFormAggregateType<T extends ProductRequestQASubFormAggregateArgs> = {
        [P in keyof T & keyof AggregateProductRequestQASubForm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductRequestQASubForm[P]>
      : GetScalarType<T[P], AggregateProductRequestQASubForm[P]>
  }




  export type ProductRequestQASubFormGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductRequestQASubFormWhereInput
    orderBy?: Enumerable<ProductRequestQASubFormOrderByWithAggregationInput>
    by: ProductRequestQASubFormScalarFieldEnum[]
    having?: ProductRequestQASubFormScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductRequestQASubFormCountAggregateInputType | true
    _min?: ProductRequestQASubFormMinAggregateInputType
    _max?: ProductRequestQASubFormMaxAggregateInputType
  }


  export type ProductRequestQASubFormGroupByOutputType = {
    id: string
    question: string | null
    answer: string[]
    type: string | null
    fileName: string | null
    fileType: string | null
    fileLink: string | null
    fileSize: string | null
    compulsory: boolean
    isDeprecated: boolean
    requestQAId: string
    _count: ProductRequestQASubFormCountAggregateOutputType | null
    _min: ProductRequestQASubFormMinAggregateOutputType | null
    _max: ProductRequestQASubFormMaxAggregateOutputType | null
  }

  type GetProductRequestQASubFormGroupByPayload<T extends ProductRequestQASubFormGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProductRequestQASubFormGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductRequestQASubFormGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductRequestQASubFormGroupByOutputType[P]>
            : GetScalarType<T[P], ProductRequestQASubFormGroupByOutputType[P]>
        }
      >
    >


  export type ProductRequestQASubFormSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    type?: boolean
    fileName?: boolean
    fileType?: boolean
    fileLink?: boolean
    fileSize?: boolean
    compulsory?: boolean
    isDeprecated?: boolean
    requestQAId?: boolean
    requestQA?: boolean | ProductRequestQAArgs<ExtArgs>
  }, ExtArgs["result"]["productRequestQASubForm"]>

  export type ProductRequestQASubFormSelectScalar = {
    id?: boolean
    question?: boolean
    answer?: boolean
    type?: boolean
    fileName?: boolean
    fileType?: boolean
    fileLink?: boolean
    fileSize?: boolean
    compulsory?: boolean
    isDeprecated?: boolean
    requestQAId?: boolean
  }

  export type ProductRequestQASubFormInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    requestQA?: boolean | ProductRequestQAArgs<ExtArgs>
  }


  type ProductRequestQASubFormGetPayload<S extends boolean | null | undefined | ProductRequestQASubFormArgs> = $Types.GetResult<ProductRequestQASubFormPayload, S>

  type ProductRequestQASubFormCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ProductRequestQASubFormFindManyArgs, 'select' | 'include'> & {
      select?: ProductRequestQASubFormCountAggregateInputType | true
    }

  export interface ProductRequestQASubFormDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductRequestQASubForm'], meta: { name: 'ProductRequestQASubForm' } }
    /**
     * Find zero or one ProductRequestQASubForm that matches the filter.
     * @param {ProductRequestQASubFormFindUniqueArgs} args - Arguments to find a ProductRequestQASubForm
     * @example
     * // Get one ProductRequestQASubForm
     * const productRequestQASubForm = await prisma.productRequestQASubForm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductRequestQASubFormFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductRequestQASubFormFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductRequestQASubForm'> extends True ? Prisma__ProductRequestQASubFormClient<$Types.GetResult<ProductRequestQASubFormPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ProductRequestQASubFormClient<$Types.GetResult<ProductRequestQASubFormPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ProductRequestQASubForm that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductRequestQASubFormFindUniqueOrThrowArgs} args - Arguments to find a ProductRequestQASubForm
     * @example
     * // Get one ProductRequestQASubForm
     * const productRequestQASubForm = await prisma.productRequestQASubForm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductRequestQASubFormFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductRequestQASubFormFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductRequestQASubFormClient<$Types.GetResult<ProductRequestQASubFormPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ProductRequestQASubForm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRequestQASubFormFindFirstArgs} args - Arguments to find a ProductRequestQASubForm
     * @example
     * // Get one ProductRequestQASubForm
     * const productRequestQASubForm = await prisma.productRequestQASubForm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductRequestQASubFormFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductRequestQASubFormFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductRequestQASubForm'> extends True ? Prisma__ProductRequestQASubFormClient<$Types.GetResult<ProductRequestQASubFormPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ProductRequestQASubFormClient<$Types.GetResult<ProductRequestQASubFormPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ProductRequestQASubForm that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRequestQASubFormFindFirstOrThrowArgs} args - Arguments to find a ProductRequestQASubForm
     * @example
     * // Get one ProductRequestQASubForm
     * const productRequestQASubForm = await prisma.productRequestQASubForm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductRequestQASubFormFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductRequestQASubFormFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductRequestQASubFormClient<$Types.GetResult<ProductRequestQASubFormPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more ProductRequestQASubForms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRequestQASubFormFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductRequestQASubForms
     * const productRequestQASubForms = await prisma.productRequestQASubForm.findMany()
     * 
     * // Get first 10 ProductRequestQASubForms
     * const productRequestQASubForms = await prisma.productRequestQASubForm.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productRequestQASubFormWithIdOnly = await prisma.productRequestQASubForm.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductRequestQASubFormFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductRequestQASubFormFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ProductRequestQASubFormPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ProductRequestQASubForm.
     * @param {ProductRequestQASubFormCreateArgs} args - Arguments to create a ProductRequestQASubForm.
     * @example
     * // Create one ProductRequestQASubForm
     * const ProductRequestQASubForm = await prisma.productRequestQASubForm.create({
     *   data: {
     *     // ... data to create a ProductRequestQASubForm
     *   }
     * })
     * 
    **/
    create<T extends ProductRequestQASubFormCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductRequestQASubFormCreateArgs<ExtArgs>>
    ): Prisma__ProductRequestQASubFormClient<$Types.GetResult<ProductRequestQASubFormPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many ProductRequestQASubForms.
     *     @param {ProductRequestQASubFormCreateManyArgs} args - Arguments to create many ProductRequestQASubForms.
     *     @example
     *     // Create many ProductRequestQASubForms
     *     const productRequestQASubForm = await prisma.productRequestQASubForm.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductRequestQASubFormCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductRequestQASubFormCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductRequestQASubForm.
     * @param {ProductRequestQASubFormDeleteArgs} args - Arguments to delete one ProductRequestQASubForm.
     * @example
     * // Delete one ProductRequestQASubForm
     * const ProductRequestQASubForm = await prisma.productRequestQASubForm.delete({
     *   where: {
     *     // ... filter to delete one ProductRequestQASubForm
     *   }
     * })
     * 
    **/
    delete<T extends ProductRequestQASubFormDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProductRequestQASubFormDeleteArgs<ExtArgs>>
    ): Prisma__ProductRequestQASubFormClient<$Types.GetResult<ProductRequestQASubFormPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ProductRequestQASubForm.
     * @param {ProductRequestQASubFormUpdateArgs} args - Arguments to update one ProductRequestQASubForm.
     * @example
     * // Update one ProductRequestQASubForm
     * const productRequestQASubForm = await prisma.productRequestQASubForm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductRequestQASubFormUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductRequestQASubFormUpdateArgs<ExtArgs>>
    ): Prisma__ProductRequestQASubFormClient<$Types.GetResult<ProductRequestQASubFormPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more ProductRequestQASubForms.
     * @param {ProductRequestQASubFormDeleteManyArgs} args - Arguments to filter ProductRequestQASubForms to delete.
     * @example
     * // Delete a few ProductRequestQASubForms
     * const { count } = await prisma.productRequestQASubForm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductRequestQASubFormDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductRequestQASubFormDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductRequestQASubForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRequestQASubFormUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductRequestQASubForms
     * const productRequestQASubForm = await prisma.productRequestQASubForm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductRequestQASubFormUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProductRequestQASubFormUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductRequestQASubForm.
     * @param {ProductRequestQASubFormUpsertArgs} args - Arguments to update or create a ProductRequestQASubForm.
     * @example
     * // Update or create a ProductRequestQASubForm
     * const productRequestQASubForm = await prisma.productRequestQASubForm.upsert({
     *   create: {
     *     // ... data to create a ProductRequestQASubForm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductRequestQASubForm we want to update
     *   }
     * })
    **/
    upsert<T extends ProductRequestQASubFormUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProductRequestQASubFormUpsertArgs<ExtArgs>>
    ): Prisma__ProductRequestQASubFormClient<$Types.GetResult<ProductRequestQASubFormPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of ProductRequestQASubForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRequestQASubFormCountArgs} args - Arguments to filter ProductRequestQASubForms to count.
     * @example
     * // Count the number of ProductRequestQASubForms
     * const count = await prisma.productRequestQASubForm.count({
     *   where: {
     *     // ... the filter for the ProductRequestQASubForms we want to count
     *   }
     * })
    **/
    count<T extends ProductRequestQASubFormCountArgs>(
      args?: Subset<T, ProductRequestQASubFormCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductRequestQASubFormCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductRequestQASubForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRequestQASubFormAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductRequestQASubFormAggregateArgs>(args: Subset<T, ProductRequestQASubFormAggregateArgs>): Prisma.PrismaPromise<GetProductRequestQASubFormAggregateType<T>>

    /**
     * Group by ProductRequestQASubForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRequestQASubFormGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductRequestQASubFormGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductRequestQASubFormGroupByArgs['orderBy'] }
        : { orderBy?: ProductRequestQASubFormGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductRequestQASubFormGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductRequestQASubFormGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductRequestQASubForm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductRequestQASubFormClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    requestQA<T extends ProductRequestQAArgs<ExtArgs> = {}>(args?: Subset<T, ProductRequestQAArgs<ExtArgs>>): Prisma__ProductRequestQAClient<$Types.GetResult<ProductRequestQAPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ProductRequestQASubForm base type for findUnique actions
   */
  export type ProductRequestQASubFormFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRequestQASubForm
     */
    select?: ProductRequestQASubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductRequestQASubFormInclude<ExtArgs> | null
    /**
     * Filter, which ProductRequestQASubForm to fetch.
     */
    where: ProductRequestQASubFormWhereUniqueInput
  }

  /**
   * ProductRequestQASubForm findUnique
   */
  export interface ProductRequestQASubFormFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProductRequestQASubFormFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductRequestQASubForm findUniqueOrThrow
   */
  export type ProductRequestQASubFormFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRequestQASubForm
     */
    select?: ProductRequestQASubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductRequestQASubFormInclude<ExtArgs> | null
    /**
     * Filter, which ProductRequestQASubForm to fetch.
     */
    where: ProductRequestQASubFormWhereUniqueInput
  }


  /**
   * ProductRequestQASubForm base type for findFirst actions
   */
  export type ProductRequestQASubFormFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRequestQASubForm
     */
    select?: ProductRequestQASubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductRequestQASubFormInclude<ExtArgs> | null
    /**
     * Filter, which ProductRequestQASubForm to fetch.
     */
    where?: ProductRequestQASubFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductRequestQASubForms to fetch.
     */
    orderBy?: Enumerable<ProductRequestQASubFormOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductRequestQASubForms.
     */
    cursor?: ProductRequestQASubFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductRequestQASubForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductRequestQASubForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductRequestQASubForms.
     */
    distinct?: Enumerable<ProductRequestQASubFormScalarFieldEnum>
  }

  /**
   * ProductRequestQASubForm findFirst
   */
  export interface ProductRequestQASubFormFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProductRequestQASubFormFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductRequestQASubForm findFirstOrThrow
   */
  export type ProductRequestQASubFormFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRequestQASubForm
     */
    select?: ProductRequestQASubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductRequestQASubFormInclude<ExtArgs> | null
    /**
     * Filter, which ProductRequestQASubForm to fetch.
     */
    where?: ProductRequestQASubFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductRequestQASubForms to fetch.
     */
    orderBy?: Enumerable<ProductRequestQASubFormOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductRequestQASubForms.
     */
    cursor?: ProductRequestQASubFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductRequestQASubForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductRequestQASubForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductRequestQASubForms.
     */
    distinct?: Enumerable<ProductRequestQASubFormScalarFieldEnum>
  }


  /**
   * ProductRequestQASubForm findMany
   */
  export type ProductRequestQASubFormFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRequestQASubForm
     */
    select?: ProductRequestQASubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductRequestQASubFormInclude<ExtArgs> | null
    /**
     * Filter, which ProductRequestQASubForms to fetch.
     */
    where?: ProductRequestQASubFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductRequestQASubForms to fetch.
     */
    orderBy?: Enumerable<ProductRequestQASubFormOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductRequestQASubForms.
     */
    cursor?: ProductRequestQASubFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductRequestQASubForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductRequestQASubForms.
     */
    skip?: number
    distinct?: Enumerable<ProductRequestQASubFormScalarFieldEnum>
  }


  /**
   * ProductRequestQASubForm create
   */
  export type ProductRequestQASubFormCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRequestQASubForm
     */
    select?: ProductRequestQASubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductRequestQASubFormInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductRequestQASubForm.
     */
    data: XOR<ProductRequestQASubFormCreateInput, ProductRequestQASubFormUncheckedCreateInput>
  }


  /**
   * ProductRequestQASubForm createMany
   */
  export type ProductRequestQASubFormCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductRequestQASubForms.
     */
    data: Enumerable<ProductRequestQASubFormCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductRequestQASubForm update
   */
  export type ProductRequestQASubFormUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRequestQASubForm
     */
    select?: ProductRequestQASubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductRequestQASubFormInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductRequestQASubForm.
     */
    data: XOR<ProductRequestQASubFormUpdateInput, ProductRequestQASubFormUncheckedUpdateInput>
    /**
     * Choose, which ProductRequestQASubForm to update.
     */
    where: ProductRequestQASubFormWhereUniqueInput
  }


  /**
   * ProductRequestQASubForm updateMany
   */
  export type ProductRequestQASubFormUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductRequestQASubForms.
     */
    data: XOR<ProductRequestQASubFormUpdateManyMutationInput, ProductRequestQASubFormUncheckedUpdateManyInput>
    /**
     * Filter which ProductRequestQASubForms to update
     */
    where?: ProductRequestQASubFormWhereInput
  }


  /**
   * ProductRequestQASubForm upsert
   */
  export type ProductRequestQASubFormUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRequestQASubForm
     */
    select?: ProductRequestQASubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductRequestQASubFormInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductRequestQASubForm to update in case it exists.
     */
    where: ProductRequestQASubFormWhereUniqueInput
    /**
     * In case the ProductRequestQASubForm found by the `where` argument doesn't exist, create a new ProductRequestQASubForm with this data.
     */
    create: XOR<ProductRequestQASubFormCreateInput, ProductRequestQASubFormUncheckedCreateInput>
    /**
     * In case the ProductRequestQASubForm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductRequestQASubFormUpdateInput, ProductRequestQASubFormUncheckedUpdateInput>
  }


  /**
   * ProductRequestQASubForm delete
   */
  export type ProductRequestQASubFormDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRequestQASubForm
     */
    select?: ProductRequestQASubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductRequestQASubFormInclude<ExtArgs> | null
    /**
     * Filter which ProductRequestQASubForm to delete.
     */
    where: ProductRequestQASubFormWhereUniqueInput
  }


  /**
   * ProductRequestQASubForm deleteMany
   */
  export type ProductRequestQASubFormDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductRequestQASubForms to delete
     */
    where?: ProductRequestQASubFormWhereInput
  }


  /**
   * ProductRequestQASubForm without action
   */
  export type ProductRequestQASubFormArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRequestQASubForm
     */
    select?: ProductRequestQASubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductRequestQASubFormInclude<ExtArgs> | null
  }



  /**
   * Model Claim
   */


  export type AggregateClaim = {
    _count: ClaimCountAggregateOutputType | null
    _min: ClaimMinAggregateOutputType | null
    _max: ClaimMaxAggregateOutputType | null
  }

  export type ClaimMinAggregateOutputType = {
    id: string | null
    value: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeprecated: boolean | null
  }

  export type ClaimMaxAggregateOutputType = {
    id: string | null
    value: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeprecated: boolean | null
  }

  export type ClaimCountAggregateOutputType = {
    id: number
    value: number
    userId: number
    createdAt: number
    updatedAt: number
    isDeprecated: number
    _all: number
  }


  export type ClaimMinAggregateInputType = {
    id?: true
    value?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    isDeprecated?: true
  }

  export type ClaimMaxAggregateInputType = {
    id?: true
    value?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    isDeprecated?: true
  }

  export type ClaimCountAggregateInputType = {
    id?: true
    value?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    isDeprecated?: true
    _all?: true
  }

  export type ClaimAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Claim to aggregate.
     */
    where?: ClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claims to fetch.
     */
    orderBy?: Enumerable<ClaimOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Claims
    **/
    _count?: true | ClaimCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClaimMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClaimMaxAggregateInputType
  }

  export type GetClaimAggregateType<T extends ClaimAggregateArgs> = {
        [P in keyof T & keyof AggregateClaim]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClaim[P]>
      : GetScalarType<T[P], AggregateClaim[P]>
  }




  export type ClaimGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ClaimWhereInput
    orderBy?: Enumerable<ClaimOrderByWithAggregationInput>
    by: ClaimScalarFieldEnum[]
    having?: ClaimScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClaimCountAggregateInputType | true
    _min?: ClaimMinAggregateInputType
    _max?: ClaimMaxAggregateInputType
  }


  export type ClaimGroupByOutputType = {
    id: string
    value: string
    userId: string
    createdAt: Date
    updatedAt: Date
    isDeprecated: boolean
    _count: ClaimCountAggregateOutputType | null
    _min: ClaimMinAggregateOutputType | null
    _max: ClaimMaxAggregateOutputType | null
  }

  type GetClaimGroupByPayload<T extends ClaimGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ClaimGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClaimGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClaimGroupByOutputType[P]>
            : GetScalarType<T[P], ClaimGroupByOutputType[P]>
        }
      >
    >


  export type ClaimSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeprecated?: boolean
  }, ExtArgs["result"]["claim"]>

  export type ClaimSelectScalar = {
    id?: boolean
    value?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeprecated?: boolean
  }


  type ClaimGetPayload<S extends boolean | null | undefined | ClaimArgs> = $Types.GetResult<ClaimPayload, S>

  type ClaimCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ClaimFindManyArgs, 'select' | 'include'> & {
      select?: ClaimCountAggregateInputType | true
    }

  export interface ClaimDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Claim'], meta: { name: 'Claim' } }
    /**
     * Find zero or one Claim that matches the filter.
     * @param {ClaimFindUniqueArgs} args - Arguments to find a Claim
     * @example
     * // Get one Claim
     * const claim = await prisma.claim.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClaimFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ClaimFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Claim'> extends True ? Prisma__ClaimClient<$Types.GetResult<ClaimPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ClaimClient<$Types.GetResult<ClaimPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Claim that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ClaimFindUniqueOrThrowArgs} args - Arguments to find a Claim
     * @example
     * // Get one Claim
     * const claim = await prisma.claim.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClaimFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClaimClient<$Types.GetResult<ClaimPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Claim that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimFindFirstArgs} args - Arguments to find a Claim
     * @example
     * // Get one Claim
     * const claim = await prisma.claim.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClaimFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ClaimFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Claim'> extends True ? Prisma__ClaimClient<$Types.GetResult<ClaimPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ClaimClient<$Types.GetResult<ClaimPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Claim that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimFindFirstOrThrowArgs} args - Arguments to find a Claim
     * @example
     * // Get one Claim
     * const claim = await prisma.claim.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClaimFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClaimClient<$Types.GetResult<ClaimPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Claims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Claims
     * const claims = await prisma.claim.findMany()
     * 
     * // Get first 10 Claims
     * const claims = await prisma.claim.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const claimWithIdOnly = await prisma.claim.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClaimFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ClaimPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Claim.
     * @param {ClaimCreateArgs} args - Arguments to create a Claim.
     * @example
     * // Create one Claim
     * const Claim = await prisma.claim.create({
     *   data: {
     *     // ... data to create a Claim
     *   }
     * })
     * 
    **/
    create<T extends ClaimCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimCreateArgs<ExtArgs>>
    ): Prisma__ClaimClient<$Types.GetResult<ClaimPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Claims.
     *     @param {ClaimCreateManyArgs} args - Arguments to create many Claims.
     *     @example
     *     // Create many Claims
     *     const claim = await prisma.claim.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ClaimCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Claim.
     * @param {ClaimDeleteArgs} args - Arguments to delete one Claim.
     * @example
     * // Delete one Claim
     * const Claim = await prisma.claim.delete({
     *   where: {
     *     // ... filter to delete one Claim
     *   }
     * })
     * 
    **/
    delete<T extends ClaimDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimDeleteArgs<ExtArgs>>
    ): Prisma__ClaimClient<$Types.GetResult<ClaimPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Claim.
     * @param {ClaimUpdateArgs} args - Arguments to update one Claim.
     * @example
     * // Update one Claim
     * const claim = await prisma.claim.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClaimUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimUpdateArgs<ExtArgs>>
    ): Prisma__ClaimClient<$Types.GetResult<ClaimPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Claims.
     * @param {ClaimDeleteManyArgs} args - Arguments to filter Claims to delete.
     * @example
     * // Delete a few Claims
     * const { count } = await prisma.claim.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClaimDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Claims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Claims
     * const claim = await prisma.claim.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClaimUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Claim.
     * @param {ClaimUpsertArgs} args - Arguments to update or create a Claim.
     * @example
     * // Update or create a Claim
     * const claim = await prisma.claim.upsert({
     *   create: {
     *     // ... data to create a Claim
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Claim we want to update
     *   }
     * })
    **/
    upsert<T extends ClaimUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimUpsertArgs<ExtArgs>>
    ): Prisma__ClaimClient<$Types.GetResult<ClaimPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Claims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimCountArgs} args - Arguments to filter Claims to count.
     * @example
     * // Count the number of Claims
     * const count = await prisma.claim.count({
     *   where: {
     *     // ... the filter for the Claims we want to count
     *   }
     * })
    **/
    count<T extends ClaimCountArgs>(
      args?: Subset<T, ClaimCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClaimCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Claim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClaimAggregateArgs>(args: Subset<T, ClaimAggregateArgs>): Prisma.PrismaPromise<GetClaimAggregateType<T>>

    /**
     * Group by Claim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClaimGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClaimGroupByArgs['orderBy'] }
        : { orderBy?: ClaimGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClaimGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClaimGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Claim.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ClaimClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Claim base type for findUnique actions
   */
  export type ClaimFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Filter, which Claim to fetch.
     */
    where: ClaimWhereUniqueInput
  }

  /**
   * Claim findUnique
   */
  export interface ClaimFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ClaimFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Claim findUniqueOrThrow
   */
  export type ClaimFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Filter, which Claim to fetch.
     */
    where: ClaimWhereUniqueInput
  }


  /**
   * Claim base type for findFirst actions
   */
  export type ClaimFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Filter, which Claim to fetch.
     */
    where?: ClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claims to fetch.
     */
    orderBy?: Enumerable<ClaimOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Claims.
     */
    cursor?: ClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Claims.
     */
    distinct?: Enumerable<ClaimScalarFieldEnum>
  }

  /**
   * Claim findFirst
   */
  export interface ClaimFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ClaimFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Claim findFirstOrThrow
   */
  export type ClaimFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Filter, which Claim to fetch.
     */
    where?: ClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claims to fetch.
     */
    orderBy?: Enumerable<ClaimOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Claims.
     */
    cursor?: ClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Claims.
     */
    distinct?: Enumerable<ClaimScalarFieldEnum>
  }


  /**
   * Claim findMany
   */
  export type ClaimFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Filter, which Claims to fetch.
     */
    where?: ClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claims to fetch.
     */
    orderBy?: Enumerable<ClaimOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Claims.
     */
    cursor?: ClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claims.
     */
    skip?: number
    distinct?: Enumerable<ClaimScalarFieldEnum>
  }


  /**
   * Claim create
   */
  export type ClaimCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * The data needed to create a Claim.
     */
    data: XOR<ClaimCreateInput, ClaimUncheckedCreateInput>
  }


  /**
   * Claim createMany
   */
  export type ClaimCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Claims.
     */
    data: Enumerable<ClaimCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Claim update
   */
  export type ClaimUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * The data needed to update a Claim.
     */
    data: XOR<ClaimUpdateInput, ClaimUncheckedUpdateInput>
    /**
     * Choose, which Claim to update.
     */
    where: ClaimWhereUniqueInput
  }


  /**
   * Claim updateMany
   */
  export type ClaimUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Claims.
     */
    data: XOR<ClaimUpdateManyMutationInput, ClaimUncheckedUpdateManyInput>
    /**
     * Filter which Claims to update
     */
    where?: ClaimWhereInput
  }


  /**
   * Claim upsert
   */
  export type ClaimUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * The filter to search for the Claim to update in case it exists.
     */
    where: ClaimWhereUniqueInput
    /**
     * In case the Claim found by the `where` argument doesn't exist, create a new Claim with this data.
     */
    create: XOR<ClaimCreateInput, ClaimUncheckedCreateInput>
    /**
     * In case the Claim was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClaimUpdateInput, ClaimUncheckedUpdateInput>
  }


  /**
   * Claim delete
   */
  export type ClaimDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Filter which Claim to delete.
     */
    where: ClaimWhereUniqueInput
  }


  /**
   * Claim deleteMany
   */
  export type ClaimDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Claims to delete
     */
    where?: ClaimWhereInput
  }


  /**
   * Claim without action
   */
  export type ClaimArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
  }



  /**
   * Model Team
   */


  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeprecated: boolean | null
    productRequestId: string | null
  }

  export type TeamMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeprecated: boolean | null
    productRequestId: string | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    userId: number
    createdAt: number
    updatedAt: number
    isDeprecated: number
    productRequestId: number
    _all: number
  }


  export type TeamMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    isDeprecated?: true
    productRequestId?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    isDeprecated?: true
    productRequestId?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    isDeprecated?: true
    productRequestId?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: Enumerable<TeamOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
    orderBy?: Enumerable<TeamOrderByWithAggregationInput>
    by: TeamScalarFieldEnum[]
    having?: TeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }


  export type TeamGroupByOutputType = {
    id: string
    name: string
    slug: string
    userId: string
    createdAt: Date
    updatedAt: Date
    isDeprecated: boolean
    productRequestId: string
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type TeamSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeprecated?: boolean
    productRequestId?: boolean
    productRequest?: boolean | ProductRequestArgs<ExtArgs>
    invitation?: boolean | Team$invitationArgs<ExtArgs>
    teamMember?: boolean | Team$teamMemberArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeprecated?: boolean
    productRequestId?: boolean
  }

  export type TeamInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    productRequest?: boolean | ProductRequestArgs<ExtArgs>
    invitation?: boolean | Team$invitationArgs<ExtArgs>
    teamMember?: boolean | Team$teamMemberArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeArgs<ExtArgs>
  }


  type TeamGetPayload<S extends boolean | null | undefined | TeamArgs> = $Types.GetResult<TeamPayload, S>

  type TeamCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<TeamFindManyArgs, 'select' | 'include'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface TeamDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Team'], meta: { name: 'Team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TeamFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Team'> extends True ? Prisma__TeamClient<$Types.GetResult<TeamPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__TeamClient<$Types.GetResult<TeamPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Team that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TeamClient<$Types.GetResult<TeamPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TeamFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Team'> extends True ? Prisma__TeamClient<$Types.GetResult<TeamPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__TeamClient<$Types.GetResult<TeamPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Team that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TeamClient<$Types.GetResult<TeamPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TeamFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<TeamPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
    **/
    create<T extends TeamCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TeamCreateArgs<ExtArgs>>
    ): Prisma__TeamClient<$Types.GetResult<TeamPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Teams.
     *     @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     *     @example
     *     // Create many Teams
     *     const team = await prisma.team.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TeamCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
    **/
    delete<T extends TeamDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>
    ): Prisma__TeamClient<$Types.GetResult<TeamPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TeamUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>
    ): Prisma__TeamClient<$Types.GetResult<TeamPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TeamDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TeamUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
    **/
    upsert<T extends TeamUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>
    ): Prisma__TeamClient<$Types.GetResult<TeamPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TeamClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    productRequest<T extends ProductRequestArgs<ExtArgs> = {}>(args?: Subset<T, ProductRequestArgs<ExtArgs>>): Prisma__ProductRequestClient<$Types.GetResult<ProductRequestPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    invitation<T extends Team$invitationArgs<ExtArgs> = {}>(args?: Subset<T, Team$invitationArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<InvitationPayload<ExtArgs>, T, 'findMany', never>| Null>;

    teamMember<T extends Team$teamMemberArgs<ExtArgs> = {}>(args?: Subset<T, Team$teamMemberArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<TeamMemberPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Team base type for findUnique actions
   */
  export type TeamFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findUnique
   */
  export interface TeamFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends TeamFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }


  /**
   * Team base type for findFirst actions
   */
  export type TeamFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: Enumerable<TeamOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: Enumerable<TeamScalarFieldEnum>
  }

  /**
   * Team findFirst
   */
  export interface TeamFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends TeamFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: Enumerable<TeamOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: Enumerable<TeamScalarFieldEnum>
  }


  /**
   * Team findMany
   */
  export type TeamFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Teams to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: Enumerable<TeamOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    distinct?: Enumerable<TeamScalarFieldEnum>
  }


  /**
   * Team create
   */
  export type TeamCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>
  }


  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teams.
     */
    data: Enumerable<TeamCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Team update
   */
  export type TeamUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput
  }


  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
  }


  /**
   * Team upsert
   */
  export type TeamUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
  }


  /**
   * Team delete
   */
  export type TeamDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput
  }


  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput
  }


  /**
   * Team.invitation
   */
  export type Team$invitationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvitationInclude<ExtArgs> | null
    where?: InvitationWhereInput
    orderBy?: Enumerable<InvitationOrderByWithRelationInput>
    cursor?: InvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<InvitationScalarFieldEnum>
  }


  /**
   * Team.teamMember
   */
  export type Team$teamMemberArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamMemberInclude<ExtArgs> | null
    where?: TeamMemberWhereInput
    orderBy?: Enumerable<TeamMemberOrderByWithRelationInput>
    cursor?: TeamMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TeamMemberScalarFieldEnum>
  }


  /**
   * Team without action
   */
  export type TeamArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamInclude<ExtArgs> | null
  }



  /**
   * Model TeamMember
   */


  export type AggregateTeamMember = {
    _count: TeamMemberCountAggregateOutputType | null
    _avg: TeamMemberAvgAggregateOutputType | null
    _sum: TeamMemberSumAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  export type TeamMemberAvgAggregateOutputType = {
    launchOwnership: number | null
  }

  export type TeamMemberSumAggregateOutputType = {
    launchOwnership: number | null
  }

  export type TeamMemberMinAggregateOutputType = {
    id: string | null
    isLaunchMember: boolean | null
    isLaunchController: boolean | null
    isLaunchOwner: boolean | null
    launchOwnership: number | null
    teamId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeprecated: boolean | null
  }

  export type TeamMemberMaxAggregateOutputType = {
    id: string | null
    isLaunchMember: boolean | null
    isLaunchController: boolean | null
    isLaunchOwner: boolean | null
    launchOwnership: number | null
    teamId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeprecated: boolean | null
  }

  export type TeamMemberCountAggregateOutputType = {
    id: number
    isLaunchMember: number
    isLaunchController: number
    isLaunchOwner: number
    launchOwnership: number
    teamId: number
    userId: number
    createdAt: number
    updatedAt: number
    isDeprecated: number
    _all: number
  }


  export type TeamMemberAvgAggregateInputType = {
    launchOwnership?: true
  }

  export type TeamMemberSumAggregateInputType = {
    launchOwnership?: true
  }

  export type TeamMemberMinAggregateInputType = {
    id?: true
    isLaunchMember?: true
    isLaunchController?: true
    isLaunchOwner?: true
    launchOwnership?: true
    teamId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    isDeprecated?: true
  }

  export type TeamMemberMaxAggregateInputType = {
    id?: true
    isLaunchMember?: true
    isLaunchController?: true
    isLaunchOwner?: true
    launchOwnership?: true
    teamId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    isDeprecated?: true
  }

  export type TeamMemberCountAggregateInputType = {
    id?: true
    isLaunchMember?: true
    isLaunchController?: true
    isLaunchOwner?: true
    launchOwnership?: true
    teamId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    isDeprecated?: true
    _all?: true
  }

  export type TeamMemberAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMember to aggregate.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: Enumerable<TeamMemberOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamMembers
    **/
    _count?: true | TeamMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMemberMaxAggregateInputType
  }

  export type GetTeamMemberAggregateType<T extends TeamMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamMember[P]>
      : GetScalarType<T[P], AggregateTeamMember[P]>
  }




  export type TeamMemberGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
    orderBy?: Enumerable<TeamMemberOrderByWithAggregationInput>
    by: TeamMemberScalarFieldEnum[]
    having?: TeamMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamMemberCountAggregateInputType | true
    _avg?: TeamMemberAvgAggregateInputType
    _sum?: TeamMemberSumAggregateInputType
    _min?: TeamMemberMinAggregateInputType
    _max?: TeamMemberMaxAggregateInputType
  }


  export type TeamMemberGroupByOutputType = {
    id: string
    isLaunchMember: boolean
    isLaunchController: boolean
    isLaunchOwner: boolean
    launchOwnership: number
    teamId: string
    userId: string
    createdAt: Date
    updatedAt: Date
    isDeprecated: boolean
    _count: TeamMemberCountAggregateOutputType | null
    _avg: TeamMemberAvgAggregateOutputType | null
    _sum: TeamMemberSumAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  type GetTeamMemberGroupByPayload<T extends TeamMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TeamMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
            : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
        }
      >
    >


  export type TeamMemberSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isLaunchMember?: boolean
    isLaunchController?: boolean
    isLaunchOwner?: boolean
    launchOwnership?: boolean
    teamId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeprecated?: boolean
    team?: boolean | TeamArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["teamMember"]>

  export type TeamMemberSelectScalar = {
    id?: boolean
    isLaunchMember?: boolean
    isLaunchController?: boolean
    isLaunchOwner?: boolean
    launchOwnership?: boolean
    teamId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeprecated?: boolean
  }

  export type TeamMemberInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    team?: boolean | TeamArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
  }


  type TeamMemberGetPayload<S extends boolean | null | undefined | TeamMemberArgs> = $Types.GetResult<TeamMemberPayload, S>

  type TeamMemberCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<TeamMemberFindManyArgs, 'select' | 'include'> & {
      select?: TeamMemberCountAggregateInputType | true
    }

  export interface TeamMemberDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamMember'], meta: { name: 'TeamMember' } }
    /**
     * Find zero or one TeamMember that matches the filter.
     * @param {TeamMemberFindUniqueArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TeamMemberFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TeamMemberFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TeamMember'> extends True ? Prisma__TeamMemberClient<$Types.GetResult<TeamMemberPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__TeamMemberClient<$Types.GetResult<TeamMemberPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one TeamMember that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TeamMemberFindUniqueOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TeamMemberFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TeamMemberFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TeamMemberClient<$Types.GetResult<TeamMemberPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first TeamMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TeamMemberFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TeamMemberFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TeamMember'> extends True ? Prisma__TeamMemberClient<$Types.GetResult<TeamMemberPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__TeamMemberClient<$Types.GetResult<TeamMemberPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first TeamMember that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TeamMemberFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TeamMemberFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TeamMemberClient<$Types.GetResult<TeamMemberPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more TeamMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamMembers
     * const teamMembers = await prisma.teamMember.findMany()
     * 
     * // Get first 10 TeamMembers
     * const teamMembers = await prisma.teamMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TeamMemberFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TeamMemberFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<TeamMemberPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a TeamMember.
     * @param {TeamMemberCreateArgs} args - Arguments to create a TeamMember.
     * @example
     * // Create one TeamMember
     * const TeamMember = await prisma.teamMember.create({
     *   data: {
     *     // ... data to create a TeamMember
     *   }
     * })
     * 
    **/
    create<T extends TeamMemberCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TeamMemberCreateArgs<ExtArgs>>
    ): Prisma__TeamMemberClient<$Types.GetResult<TeamMemberPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many TeamMembers.
     *     @param {TeamMemberCreateManyArgs} args - Arguments to create many TeamMembers.
     *     @example
     *     // Create many TeamMembers
     *     const teamMember = await prisma.teamMember.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TeamMemberCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TeamMemberCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TeamMember.
     * @param {TeamMemberDeleteArgs} args - Arguments to delete one TeamMember.
     * @example
     * // Delete one TeamMember
     * const TeamMember = await prisma.teamMember.delete({
     *   where: {
     *     // ... filter to delete one TeamMember
     *   }
     * })
     * 
    **/
    delete<T extends TeamMemberDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TeamMemberDeleteArgs<ExtArgs>>
    ): Prisma__TeamMemberClient<$Types.GetResult<TeamMemberPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one TeamMember.
     * @param {TeamMemberUpdateArgs} args - Arguments to update one TeamMember.
     * @example
     * // Update one TeamMember
     * const teamMember = await prisma.teamMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TeamMemberUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TeamMemberUpdateArgs<ExtArgs>>
    ): Prisma__TeamMemberClient<$Types.GetResult<TeamMemberPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more TeamMembers.
     * @param {TeamMemberDeleteManyArgs} args - Arguments to filter TeamMembers to delete.
     * @example
     * // Delete a few TeamMembers
     * const { count } = await prisma.teamMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TeamMemberDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TeamMemberDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamMembers
     * const teamMember = await prisma.teamMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TeamMemberUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TeamMemberUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TeamMember.
     * @param {TeamMemberUpsertArgs} args - Arguments to update or create a TeamMember.
     * @example
     * // Update or create a TeamMember
     * const teamMember = await prisma.teamMember.upsert({
     *   create: {
     *     // ... data to create a TeamMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamMember we want to update
     *   }
     * })
    **/
    upsert<T extends TeamMemberUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TeamMemberUpsertArgs<ExtArgs>>
    ): Prisma__TeamMemberClient<$Types.GetResult<TeamMemberPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberCountArgs} args - Arguments to filter TeamMembers to count.
     * @example
     * // Count the number of TeamMembers
     * const count = await prisma.teamMember.count({
     *   where: {
     *     // ... the filter for the TeamMembers we want to count
     *   }
     * })
    **/
    count<T extends TeamMemberCountArgs>(
      args?: Subset<T, TeamMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamMemberAggregateArgs>(args: Subset<T, TeamMemberAggregateArgs>): Prisma.PrismaPromise<GetTeamMemberAggregateType<T>>

    /**
     * Group by TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamMemberGroupByArgs['orderBy'] }
        : { orderBy?: TeamMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TeamMemberClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    team<T extends TeamArgs<ExtArgs> = {}>(args?: Subset<T, TeamArgs<ExtArgs>>): Prisma__TeamClient<$Types.GetResult<TeamPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TeamMember base type for findUnique actions
   */
  export type TeamMemberFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findUnique
   */
  export interface TeamMemberFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends TeamMemberFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TeamMember findUniqueOrThrow
   */
  export type TeamMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }


  /**
   * TeamMember base type for findFirst actions
   */
  export type TeamMemberFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: Enumerable<TeamMemberOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: Enumerable<TeamMemberScalarFieldEnum>
  }

  /**
   * TeamMember findFirst
   */
  export interface TeamMemberFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends TeamMemberFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TeamMember findFirstOrThrow
   */
  export type TeamMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: Enumerable<TeamMemberOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: Enumerable<TeamMemberScalarFieldEnum>
  }


  /**
   * TeamMember findMany
   */
  export type TeamMemberFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMembers to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: Enumerable<TeamMemberOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    distinct?: Enumerable<TeamMemberScalarFieldEnum>
  }


  /**
   * TeamMember create
   */
  export type TeamMemberCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamMember.
     */
    data: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
  }


  /**
   * TeamMember createMany
   */
  export type TeamMemberCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamMembers.
     */
    data: Enumerable<TeamMemberCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TeamMember update
   */
  export type TeamMemberUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamMember.
     */
    data: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
    /**
     * Choose, which TeamMember to update.
     */
    where: TeamMemberWhereUniqueInput
  }


  /**
   * TeamMember updateMany
   */
  export type TeamMemberUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamMembers.
     */
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyInput>
    /**
     * Filter which TeamMembers to update
     */
    where?: TeamMemberWhereInput
  }


  /**
   * TeamMember upsert
   */
  export type TeamMemberUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamMember to update in case it exists.
     */
    where: TeamMemberWhereUniqueInput
    /**
     * In case the TeamMember found by the `where` argument doesn't exist, create a new TeamMember with this data.
     */
    create: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
    /**
     * In case the TeamMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
  }


  /**
   * TeamMember delete
   */
  export type TeamMemberDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter which TeamMember to delete.
     */
    where: TeamMemberWhereUniqueInput
  }


  /**
   * TeamMember deleteMany
   */
  export type TeamMemberDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMembers to delete
     */
    where?: TeamMemberWhereInput
  }


  /**
   * TeamMember without action
   */
  export type TeamMemberArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamMemberInclude<ExtArgs> | null
  }



  /**
   * Model Invitation
   */


  export type AggregateInvitation = {
    _count: InvitationCountAggregateOutputType | null
    _min: InvitationMinAggregateOutputType | null
    _max: InvitationMaxAggregateOutputType | null
  }

  export type InvitationMinAggregateOutputType = {
    id: string | null
    teamId: string | null
    email: string | null
    token: string | null
    expireIn: Date | null
    invitedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeprecated: boolean | null
  }

  export type InvitationMaxAggregateOutputType = {
    id: string | null
    teamId: string | null
    email: string | null
    token: string | null
    expireIn: Date | null
    invitedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeprecated: boolean | null
  }

  export type InvitationCountAggregateOutputType = {
    id: number
    teamId: number
    email: number
    token: number
    expireIn: number
    invitedBy: number
    createdAt: number
    updatedAt: number
    isDeprecated: number
    _all: number
  }


  export type InvitationMinAggregateInputType = {
    id?: true
    teamId?: true
    email?: true
    token?: true
    expireIn?: true
    invitedBy?: true
    createdAt?: true
    updatedAt?: true
    isDeprecated?: true
  }

  export type InvitationMaxAggregateInputType = {
    id?: true
    teamId?: true
    email?: true
    token?: true
    expireIn?: true
    invitedBy?: true
    createdAt?: true
    updatedAt?: true
    isDeprecated?: true
  }

  export type InvitationCountAggregateInputType = {
    id?: true
    teamId?: true
    email?: true
    token?: true
    expireIn?: true
    invitedBy?: true
    createdAt?: true
    updatedAt?: true
    isDeprecated?: true
    _all?: true
  }

  export type InvitationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invitation to aggregate.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: Enumerable<InvitationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invitations
    **/
    _count?: true | InvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvitationMaxAggregateInputType
  }

  export type GetInvitationAggregateType<T extends InvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvitation[P]>
      : GetScalarType<T[P], AggregateInvitation[P]>
  }




  export type InvitationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: InvitationWhereInput
    orderBy?: Enumerable<InvitationOrderByWithAggregationInput>
    by: InvitationScalarFieldEnum[]
    having?: InvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvitationCountAggregateInputType | true
    _min?: InvitationMinAggregateInputType
    _max?: InvitationMaxAggregateInputType
  }


  export type InvitationGroupByOutputType = {
    id: string
    teamId: string
    email: string
    token: string
    expireIn: Date
    invitedBy: string
    createdAt: Date
    updatedAt: Date
    isDeprecated: boolean
    _count: InvitationCountAggregateOutputType | null
    _min: InvitationMinAggregateOutputType | null
    _max: InvitationMaxAggregateOutputType | null
  }

  type GetInvitationGroupByPayload<T extends InvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<InvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvitationGroupByOutputType[P]>
            : GetScalarType<T[P], InvitationGroupByOutputType[P]>
        }
      >
    >


  export type InvitationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    email?: boolean
    token?: boolean
    expireIn?: boolean
    invitedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeprecated?: boolean
    team?: boolean | TeamArgs<ExtArgs>
  }, ExtArgs["result"]["invitation"]>

  export type InvitationSelectScalar = {
    id?: boolean
    teamId?: boolean
    email?: boolean
    token?: boolean
    expireIn?: boolean
    invitedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeprecated?: boolean
  }

  export type InvitationInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    team?: boolean | TeamArgs<ExtArgs>
  }


  type InvitationGetPayload<S extends boolean | null | undefined | InvitationArgs> = $Types.GetResult<InvitationPayload, S>

  type InvitationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<InvitationFindManyArgs, 'select' | 'include'> & {
      select?: InvitationCountAggregateInputType | true
    }

  export interface InvitationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invitation'], meta: { name: 'Invitation' } }
    /**
     * Find zero or one Invitation that matches the filter.
     * @param {InvitationFindUniqueArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InvitationFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, InvitationFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Invitation'> extends True ? Prisma__InvitationClient<$Types.GetResult<InvitationPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__InvitationClient<$Types.GetResult<InvitationPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Invitation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InvitationFindUniqueOrThrowArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InvitationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InvitationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InvitationClient<$Types.GetResult<InvitationPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Invitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindFirstArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InvitationFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, InvitationFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Invitation'> extends True ? Prisma__InvitationClient<$Types.GetResult<InvitationPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__InvitationClient<$Types.GetResult<InvitationPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Invitation that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindFirstOrThrowArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InvitationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InvitationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InvitationClient<$Types.GetResult<InvitationPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Invitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invitations
     * const invitations = await prisma.invitation.findMany()
     * 
     * // Get first 10 Invitations
     * const invitations = await prisma.invitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invitationWithIdOnly = await prisma.invitation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InvitationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InvitationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<InvitationPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Invitation.
     * @param {InvitationCreateArgs} args - Arguments to create a Invitation.
     * @example
     * // Create one Invitation
     * const Invitation = await prisma.invitation.create({
     *   data: {
     *     // ... data to create a Invitation
     *   }
     * })
     * 
    **/
    create<T extends InvitationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InvitationCreateArgs<ExtArgs>>
    ): Prisma__InvitationClient<$Types.GetResult<InvitationPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Invitations.
     *     @param {InvitationCreateManyArgs} args - Arguments to create many Invitations.
     *     @example
     *     // Create many Invitations
     *     const invitation = await prisma.invitation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InvitationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InvitationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Invitation.
     * @param {InvitationDeleteArgs} args - Arguments to delete one Invitation.
     * @example
     * // Delete one Invitation
     * const Invitation = await prisma.invitation.delete({
     *   where: {
     *     // ... filter to delete one Invitation
     *   }
     * })
     * 
    **/
    delete<T extends InvitationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InvitationDeleteArgs<ExtArgs>>
    ): Prisma__InvitationClient<$Types.GetResult<InvitationPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Invitation.
     * @param {InvitationUpdateArgs} args - Arguments to update one Invitation.
     * @example
     * // Update one Invitation
     * const invitation = await prisma.invitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InvitationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InvitationUpdateArgs<ExtArgs>>
    ): Prisma__InvitationClient<$Types.GetResult<InvitationPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Invitations.
     * @param {InvitationDeleteManyArgs} args - Arguments to filter Invitations to delete.
     * @example
     * // Delete a few Invitations
     * const { count } = await prisma.invitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InvitationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InvitationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invitations
     * const invitation = await prisma.invitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InvitationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InvitationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invitation.
     * @param {InvitationUpsertArgs} args - Arguments to update or create a Invitation.
     * @example
     * // Update or create a Invitation
     * const invitation = await prisma.invitation.upsert({
     *   create: {
     *     // ... data to create a Invitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invitation we want to update
     *   }
     * })
    **/
    upsert<T extends InvitationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InvitationUpsertArgs<ExtArgs>>
    ): Prisma__InvitationClient<$Types.GetResult<InvitationPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationCountArgs} args - Arguments to filter Invitations to count.
     * @example
     * // Count the number of Invitations
     * const count = await prisma.invitation.count({
     *   where: {
     *     // ... the filter for the Invitations we want to count
     *   }
     * })
    **/
    count<T extends InvitationCountArgs>(
      args?: Subset<T, InvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvitationAggregateArgs>(args: Subset<T, InvitationAggregateArgs>): Prisma.PrismaPromise<GetInvitationAggregateType<T>>

    /**
     * Group by Invitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvitationGroupByArgs['orderBy'] }
        : { orderBy?: InvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Invitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__InvitationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    team<T extends TeamArgs<ExtArgs> = {}>(args?: Subset<T, TeamArgs<ExtArgs>>): Prisma__TeamClient<$Types.GetResult<TeamPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Invitation base type for findUnique actions
   */
  export type InvitationFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation findUnique
   */
  export interface InvitationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends InvitationFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Invitation findUniqueOrThrow
   */
  export type InvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where: InvitationWhereUniqueInput
  }


  /**
   * Invitation base type for findFirst actions
   */
  export type InvitationFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: Enumerable<InvitationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invitations.
     */
    distinct?: Enumerable<InvitationScalarFieldEnum>
  }

  /**
   * Invitation findFirst
   */
  export interface InvitationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends InvitationFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Invitation findFirstOrThrow
   */
  export type InvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: Enumerable<InvitationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invitations.
     */
    distinct?: Enumerable<InvitationScalarFieldEnum>
  }


  /**
   * Invitation findMany
   */
  export type InvitationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitations to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: Enumerable<InvitationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    distinct?: Enumerable<InvitationScalarFieldEnum>
  }


  /**
   * Invitation create
   */
  export type InvitationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a Invitation.
     */
    data: XOR<InvitationCreateInput, InvitationUncheckedCreateInput>
  }


  /**
   * Invitation createMany
   */
  export type InvitationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invitations.
     */
    data: Enumerable<InvitationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Invitation update
   */
  export type InvitationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a Invitation.
     */
    data: XOR<InvitationUpdateInput, InvitationUncheckedUpdateInput>
    /**
     * Choose, which Invitation to update.
     */
    where: InvitationWhereUniqueInput
  }


  /**
   * Invitation updateMany
   */
  export type InvitationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invitations.
     */
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyInput>
    /**
     * Filter which Invitations to update
     */
    where?: InvitationWhereInput
  }


  /**
   * Invitation upsert
   */
  export type InvitationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the Invitation to update in case it exists.
     */
    where: InvitationWhereUniqueInput
    /**
     * In case the Invitation found by the `where` argument doesn't exist, create a new Invitation with this data.
     */
    create: XOR<InvitationCreateInput, InvitationUncheckedCreateInput>
    /**
     * In case the Invitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvitationUpdateInput, InvitationUncheckedUpdateInput>
  }


  /**
   * Invitation delete
   */
  export type InvitationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter which Invitation to delete.
     */
    where: InvitationWhereUniqueInput
  }


  /**
   * Invitation deleteMany
   */
  export type InvitationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invitations to delete
     */
    where?: InvitationWhereInput
  }


  /**
   * Invitation without action
   */
  export type InvitationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvitationInclude<ExtArgs> | null
  }



  /**
   * Model Payment
   */


  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    provider: string | null
    transactionId: string | null
    status: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeprecated: boolean | null
    productRequestId: string | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    provider: string | null
    transactionId: string | null
    status: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeprecated: boolean | null
    productRequestId: string | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    provider: number
    transactionId: number
    status: number
    email: number
    createdAt: number
    updatedAt: number
    isDeprecated: number
    productRequestId: number
    _all: number
  }


  export type PaymentMinAggregateInputType = {
    id?: true
    provider?: true
    transactionId?: true
    status?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    isDeprecated?: true
    productRequestId?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    provider?: true
    transactionId?: true
    status?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    isDeprecated?: true
    productRequestId?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    provider?: true
    transactionId?: true
    status?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    isDeprecated?: true
    productRequestId?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: Enumerable<PaymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: Enumerable<PaymentOrderByWithAggregationInput>
    by: PaymentScalarFieldEnum[]
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }


  export type PaymentGroupByOutputType = {
    id: string
    provider: string
    transactionId: string
    status: string
    email: string
    createdAt: Date
    updatedAt: Date
    isDeprecated: boolean
    productRequestId: string
    _count: PaymentCountAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    transactionId?: boolean
    status?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeprecated?: boolean
    productRequestId?: boolean
    productRequests?: boolean | ProductRequestArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    provider?: boolean
    transactionId?: boolean
    status?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeprecated?: boolean
    productRequestId?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    productRequests?: boolean | ProductRequestArgs<ExtArgs>
  }


  type PaymentGetPayload<S extends boolean | null | undefined | PaymentArgs> = $Types.GetResult<PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PaymentFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Payment'> extends True ? Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PaymentFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Payment'> extends True ? Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PaymentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
    **/
    create<T extends PaymentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Payments.
     *     @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     *     @example
     *     // Create many Payments
     *     const payment = await prisma.payment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PaymentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
    **/
    delete<T extends PaymentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PaymentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PaymentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PaymentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
    **/
    upsert<T extends PaymentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    productRequests<T extends ProductRequestArgs<ExtArgs> = {}>(args?: Subset<T, ProductRequestArgs<ExtArgs>>): Prisma__ProductRequestClient<$Types.GetResult<ProductRequestPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Payment base type for findUnique actions
   */
  export type PaymentFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUnique
   */
  export interface PaymentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PaymentFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }


  /**
   * Payment base type for findFirst actions
   */
  export type PaymentFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: Enumerable<PaymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }

  /**
   * Payment findFirst
   */
  export interface PaymentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PaymentFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: Enumerable<PaymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }


  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: Enumerable<PaymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }


  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }


  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: Enumerable<PaymentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }


  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }


  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }


  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }


  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }


  /**
   * Payment without action
   */
  export type PaymentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
  }



  /**
   * Model Parter
   */


  export type AggregateParter = {
    _count: ParterCountAggregateOutputType | null
    _avg: ParterAvgAggregateOutputType | null
    _sum: ParterSumAggregateOutputType | null
    _min: ParterMinAggregateOutputType | null
    _max: ParterMaxAggregateOutputType | null
  }

  export type ParterAvgAggregateOutputType = {
    serviceScore: number | null
    paymentsMade: number | null
    paymentsDue: number | null
  }

  export type ParterSumAggregateOutputType = {
    serviceScore: number | null
    paymentsMade: number | null
    paymentsDue: number | null
  }

  export type ParterMinAggregateOutputType = {
    id: string | null
    isVerified: boolean | null
    serviceScore: number | null
    paymentsMade: number | null
    paymentsDue: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeprecated: boolean | null
  }

  export type ParterMaxAggregateOutputType = {
    id: string | null
    isVerified: boolean | null
    serviceScore: number | null
    paymentsMade: number | null
    paymentsDue: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeprecated: boolean | null
  }

  export type ParterCountAggregateOutputType = {
    id: number
    isVerified: number
    verificationDocument: number
    serviceScore: number
    paymentsMade: number
    paymentsDue: number
    paymentDetails: number
    countrySupported: number
    serviceSupported: number
    servicesAssigned: number
    servicesCompleted: number
    servicesDeclined: number
    createdAt: number
    updatedAt: number
    isDeprecated: number
    _all: number
  }


  export type ParterAvgAggregateInputType = {
    serviceScore?: true
    paymentsMade?: true
    paymentsDue?: true
  }

  export type ParterSumAggregateInputType = {
    serviceScore?: true
    paymentsMade?: true
    paymentsDue?: true
  }

  export type ParterMinAggregateInputType = {
    id?: true
    isVerified?: true
    serviceScore?: true
    paymentsMade?: true
    paymentsDue?: true
    createdAt?: true
    updatedAt?: true
    isDeprecated?: true
  }

  export type ParterMaxAggregateInputType = {
    id?: true
    isVerified?: true
    serviceScore?: true
    paymentsMade?: true
    paymentsDue?: true
    createdAt?: true
    updatedAt?: true
    isDeprecated?: true
  }

  export type ParterCountAggregateInputType = {
    id?: true
    isVerified?: true
    verificationDocument?: true
    serviceScore?: true
    paymentsMade?: true
    paymentsDue?: true
    paymentDetails?: true
    countrySupported?: true
    serviceSupported?: true
    servicesAssigned?: true
    servicesCompleted?: true
    servicesDeclined?: true
    createdAt?: true
    updatedAt?: true
    isDeprecated?: true
    _all?: true
  }

  export type ParterAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parter to aggregate.
     */
    where?: ParterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parters to fetch.
     */
    orderBy?: Enumerable<ParterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Parters
    **/
    _count?: true | ParterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParterMaxAggregateInputType
  }

  export type GetParterAggregateType<T extends ParterAggregateArgs> = {
        [P in keyof T & keyof AggregateParter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParter[P]>
      : GetScalarType<T[P], AggregateParter[P]>
  }




  export type ParterGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ParterWhereInput
    orderBy?: Enumerable<ParterOrderByWithAggregationInput>
    by: ParterScalarFieldEnum[]
    having?: ParterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParterCountAggregateInputType | true
    _avg?: ParterAvgAggregateInputType
    _sum?: ParterSumAggregateInputType
    _min?: ParterMinAggregateInputType
    _max?: ParterMaxAggregateInputType
  }


  export type ParterGroupByOutputType = {
    id: string
    isVerified: boolean
    verificationDocument: string[]
    serviceScore: number
    paymentsMade: number
    paymentsDue: number
    paymentDetails: string[]
    countrySupported: string[]
    serviceSupported: string[]
    servicesAssigned: string[]
    servicesCompleted: string[]
    servicesDeclined: string[]
    createdAt: Date
    updatedAt: Date
    isDeprecated: boolean
    _count: ParterCountAggregateOutputType | null
    _avg: ParterAvgAggregateOutputType | null
    _sum: ParterSumAggregateOutputType | null
    _min: ParterMinAggregateOutputType | null
    _max: ParterMaxAggregateOutputType | null
  }

  type GetParterGroupByPayload<T extends ParterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ParterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParterGroupByOutputType[P]>
            : GetScalarType<T[P], ParterGroupByOutputType[P]>
        }
      >
    >


  export type ParterSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isVerified?: boolean
    verificationDocument?: boolean
    serviceScore?: boolean
    paymentsMade?: boolean
    paymentsDue?: boolean
    paymentDetails?: boolean
    countrySupported?: boolean
    serviceSupported?: boolean
    servicesAssigned?: boolean
    servicesCompleted?: boolean
    servicesDeclined?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeprecated?: boolean
  }, ExtArgs["result"]["parter"]>

  export type ParterSelectScalar = {
    id?: boolean
    isVerified?: boolean
    verificationDocument?: boolean
    serviceScore?: boolean
    paymentsMade?: boolean
    paymentsDue?: boolean
    paymentDetails?: boolean
    countrySupported?: boolean
    serviceSupported?: boolean
    servicesAssigned?: boolean
    servicesCompleted?: boolean
    servicesDeclined?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeprecated?: boolean
  }


  type ParterGetPayload<S extends boolean | null | undefined | ParterArgs> = $Types.GetResult<ParterPayload, S>

  type ParterCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ParterFindManyArgs, 'select' | 'include'> & {
      select?: ParterCountAggregateInputType | true
    }

  export interface ParterDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Parter'], meta: { name: 'Parter' } }
    /**
     * Find zero or one Parter that matches the filter.
     * @param {ParterFindUniqueArgs} args - Arguments to find a Parter
     * @example
     * // Get one Parter
     * const parter = await prisma.parter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ParterFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ParterFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Parter'> extends True ? Prisma__ParterClient<$Types.GetResult<ParterPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ParterClient<$Types.GetResult<ParterPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Parter that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ParterFindUniqueOrThrowArgs} args - Arguments to find a Parter
     * @example
     * // Get one Parter
     * const parter = await prisma.parter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ParterFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ParterFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ParterClient<$Types.GetResult<ParterPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Parter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParterFindFirstArgs} args - Arguments to find a Parter
     * @example
     * // Get one Parter
     * const parter = await prisma.parter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ParterFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ParterFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Parter'> extends True ? Prisma__ParterClient<$Types.GetResult<ParterPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ParterClient<$Types.GetResult<ParterPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Parter that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParterFindFirstOrThrowArgs} args - Arguments to find a Parter
     * @example
     * // Get one Parter
     * const parter = await prisma.parter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ParterFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ParterFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ParterClient<$Types.GetResult<ParterPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Parters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParterFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parters
     * const parters = await prisma.parter.findMany()
     * 
     * // Get first 10 Parters
     * const parters = await prisma.parter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parterWithIdOnly = await prisma.parter.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ParterFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ParterFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ParterPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Parter.
     * @param {ParterCreateArgs} args - Arguments to create a Parter.
     * @example
     * // Create one Parter
     * const Parter = await prisma.parter.create({
     *   data: {
     *     // ... data to create a Parter
     *   }
     * })
     * 
    **/
    create<T extends ParterCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ParterCreateArgs<ExtArgs>>
    ): Prisma__ParterClient<$Types.GetResult<ParterPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Parters.
     *     @param {ParterCreateManyArgs} args - Arguments to create many Parters.
     *     @example
     *     // Create many Parters
     *     const parter = await prisma.parter.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ParterCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ParterCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Parter.
     * @param {ParterDeleteArgs} args - Arguments to delete one Parter.
     * @example
     * // Delete one Parter
     * const Parter = await prisma.parter.delete({
     *   where: {
     *     // ... filter to delete one Parter
     *   }
     * })
     * 
    **/
    delete<T extends ParterDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ParterDeleteArgs<ExtArgs>>
    ): Prisma__ParterClient<$Types.GetResult<ParterPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Parter.
     * @param {ParterUpdateArgs} args - Arguments to update one Parter.
     * @example
     * // Update one Parter
     * const parter = await prisma.parter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ParterUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ParterUpdateArgs<ExtArgs>>
    ): Prisma__ParterClient<$Types.GetResult<ParterPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Parters.
     * @param {ParterDeleteManyArgs} args - Arguments to filter Parters to delete.
     * @example
     * // Delete a few Parters
     * const { count } = await prisma.parter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ParterDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ParterDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parters
     * const parter = await prisma.parter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ParterUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ParterUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Parter.
     * @param {ParterUpsertArgs} args - Arguments to update or create a Parter.
     * @example
     * // Update or create a Parter
     * const parter = await prisma.parter.upsert({
     *   create: {
     *     // ... data to create a Parter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parter we want to update
     *   }
     * })
    **/
    upsert<T extends ParterUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ParterUpsertArgs<ExtArgs>>
    ): Prisma__ParterClient<$Types.GetResult<ParterPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Parters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParterCountArgs} args - Arguments to filter Parters to count.
     * @example
     * // Count the number of Parters
     * const count = await prisma.parter.count({
     *   where: {
     *     // ... the filter for the Parters we want to count
     *   }
     * })
    **/
    count<T extends ParterCountArgs>(
      args?: Subset<T, ParterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParterAggregateArgs>(args: Subset<T, ParterAggregateArgs>): Prisma.PrismaPromise<GetParterAggregateType<T>>

    /**
     * Group by Parter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParterGroupByArgs['orderBy'] }
        : { orderBy?: ParterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Parter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ParterClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Parter base type for findUnique actions
   */
  export type ParterFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parter
     */
    select?: ParterSelect<ExtArgs> | null
    /**
     * Filter, which Parter to fetch.
     */
    where: ParterWhereUniqueInput
  }

  /**
   * Parter findUnique
   */
  export interface ParterFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ParterFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Parter findUniqueOrThrow
   */
  export type ParterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parter
     */
    select?: ParterSelect<ExtArgs> | null
    /**
     * Filter, which Parter to fetch.
     */
    where: ParterWhereUniqueInput
  }


  /**
   * Parter base type for findFirst actions
   */
  export type ParterFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parter
     */
    select?: ParterSelect<ExtArgs> | null
    /**
     * Filter, which Parter to fetch.
     */
    where?: ParterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parters to fetch.
     */
    orderBy?: Enumerable<ParterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parters.
     */
    cursor?: ParterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parters.
     */
    distinct?: Enumerable<ParterScalarFieldEnum>
  }

  /**
   * Parter findFirst
   */
  export interface ParterFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ParterFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Parter findFirstOrThrow
   */
  export type ParterFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parter
     */
    select?: ParterSelect<ExtArgs> | null
    /**
     * Filter, which Parter to fetch.
     */
    where?: ParterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parters to fetch.
     */
    orderBy?: Enumerable<ParterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parters.
     */
    cursor?: ParterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parters.
     */
    distinct?: Enumerable<ParterScalarFieldEnum>
  }


  /**
   * Parter findMany
   */
  export type ParterFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parter
     */
    select?: ParterSelect<ExtArgs> | null
    /**
     * Filter, which Parters to fetch.
     */
    where?: ParterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parters to fetch.
     */
    orderBy?: Enumerable<ParterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Parters.
     */
    cursor?: ParterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parters.
     */
    skip?: number
    distinct?: Enumerable<ParterScalarFieldEnum>
  }


  /**
   * Parter create
   */
  export type ParterCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parter
     */
    select?: ParterSelect<ExtArgs> | null
    /**
     * The data needed to create a Parter.
     */
    data: XOR<ParterCreateInput, ParterUncheckedCreateInput>
  }


  /**
   * Parter createMany
   */
  export type ParterCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Parters.
     */
    data: Enumerable<ParterCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Parter update
   */
  export type ParterUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parter
     */
    select?: ParterSelect<ExtArgs> | null
    /**
     * The data needed to update a Parter.
     */
    data: XOR<ParterUpdateInput, ParterUncheckedUpdateInput>
    /**
     * Choose, which Parter to update.
     */
    where: ParterWhereUniqueInput
  }


  /**
   * Parter updateMany
   */
  export type ParterUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Parters.
     */
    data: XOR<ParterUpdateManyMutationInput, ParterUncheckedUpdateManyInput>
    /**
     * Filter which Parters to update
     */
    where?: ParterWhereInput
  }


  /**
   * Parter upsert
   */
  export type ParterUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parter
     */
    select?: ParterSelect<ExtArgs> | null
    /**
     * The filter to search for the Parter to update in case it exists.
     */
    where: ParterWhereUniqueInput
    /**
     * In case the Parter found by the `where` argument doesn't exist, create a new Parter with this data.
     */
    create: XOR<ParterCreateInput, ParterUncheckedCreateInput>
    /**
     * In case the Parter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParterUpdateInput, ParterUncheckedUpdateInput>
  }


  /**
   * Parter delete
   */
  export type ParterDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parter
     */
    select?: ParterSelect<ExtArgs> | null
    /**
     * Filter which Parter to delete.
     */
    where: ParterWhereUniqueInput
  }


  /**
   * Parter deleteMany
   */
  export type ParterDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parters to delete
     */
    where?: ParterWhereInput
  }


  /**
   * Parter without action
   */
  export type ParterArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parter
     */
    select?: ParterSelect<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const StaffScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    password: 'password',
    phone: 'phone',
    verified: 'verified',
    picture: 'picture',
    resetToken: 'resetToken',
    isDeprecated: 'isDeprecated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StaffScalarFieldEnum = (typeof StaffScalarFieldEnum)[keyof typeof StaffScalarFieldEnum]


  export const CollaboratorScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    password: 'password',
    phone: 'phone',
    picture: 'picture',
    verified: 'verified',
    isPartner: 'isPartner',
    resetToken: 'resetToken',
    isDeprecated: 'isDeprecated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CollaboratorScalarFieldEnum = (typeof CollaboratorScalarFieldEnum)[keyof typeof CollaboratorScalarFieldEnum]


  export const CollaboratorDocumentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    description: 'description',
    isDeprecated: 'isDeprecated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    collaboratorId: 'collaboratorId'
  };

  export type CollaboratorDocumentScalarFieldEnum = (typeof CollaboratorDocumentScalarFieldEnum)[keyof typeof CollaboratorDocumentScalarFieldEnum]


  export const RewardScalarFieldEnum: {
    id: 'id',
    name: 'name',
    url: 'url',
    descrition: 'descrition',
    image: 'image',
    isDeprecated: 'isDeprecated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RewardScalarFieldEnum = (typeof RewardScalarFieldEnum)[keyof typeof RewardScalarFieldEnum]


  export const CountryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    iso: 'iso',
    currency: 'currency',
    code: 'code',
    flagUrl: 'flagUrl',
    isDeprecated: 'isDeprecated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CountryScalarFieldEnum = (typeof CountryScalarFieldEnum)[keyof typeof CountryScalarFieldEnum]


  export const BankScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    url: 'url',
    image: 'image',
    isDeprecated: 'isDeprecated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BankScalarFieldEnum = (typeof BankScalarFieldEnum)[keyof typeof BankScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    body: 'body',
    readStatus: 'readStatus',
    isDeprecated: 'isDeprecated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    scope: 'scope',
    isDeprecated: 'isDeprecated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    fullName: 'fullName',
    username: 'username',
    email: 'email',
    password: 'password',
    googleId: 'googleId',
    phone: 'phone',
    picture: 'picture',
    isVerified: 'isVerified',
    referral: 'referral',
    country: 'country',
    resetToken: 'resetToken',
    isPartner: 'isPartner',
    isStaff: 'isStaff',
    isPhoneRegistered: 'isPhoneRegistered',
    isPhoneVerified: 'isPhoneVerified',
    isIdentificationRegistered: 'isIdentificationRegistered',
    isIdentificationVerified: 'isIdentificationVerified',
    partnerPermission: 'partnerPermission',
    staffPermission: 'staffPermission',
    userPermission: 'userPermission',
    isDeprecated: 'isDeprecated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserDocumentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    link: 'link',
    size: 'size',
    belongsTo: 'belongsTo',
    isDeprecated: 'isDeprecated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type UserDocumentScalarFieldEnum = (typeof UserDocumentScalarFieldEnum)[keyof typeof UserDocumentScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isDeprecated: 'isDeprecated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const ServiceFormScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    type: 'type',
    compulsory: 'compulsory',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeprecated: 'isDeprecated',
    serviceId: 'serviceId'
  };

  export type ServiceFormScalarFieldEnum = (typeof ServiceFormScalarFieldEnum)[keyof typeof ServiceFormScalarFieldEnum]


  export const ServiceSubFormScalarFieldEnum: {
    id: 'id',
    question: 'question',
    type: 'type',
    options: 'options',
    fileName: 'fileName',
    fileType: 'fileType',
    fileLink: 'fileLink',
    fileSize: 'fileSize',
    dependentField: 'dependentField',
    dependentOptions: 'dependentOptions',
    documentType: 'documentType',
    allowOther: 'allowOther',
    compulsory: 'compulsory',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeprecated: 'isDeprecated',
    formId: 'formId'
  };

  export type ServiceSubFormScalarFieldEnum = (typeof ServiceSubFormScalarFieldEnum)[keyof typeof ServiceSubFormScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    country: 'country',
    currency: 'currency',
    amount: 'amount',
    timeline: 'timeline',
    feature: 'feature',
    canAlsoDo: 'canAlsoDo',
    hasShares: 'hasShares',
    hasAgent: 'hasAgent',
    hasOwner: 'hasOwner',
    hasController: 'hasController',
    controllerIsCalled: 'controllerIsCalled',
    OwnerIsCalled: 'OwnerIsCalled',
    agentIsCalled: 'agentIsCalled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeprecated: 'isDeprecated',
    serviceId: 'serviceId'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ProductFormScalarFieldEnum: {
    id: 'id',
    title: 'title',
    type: 'type',
    description: 'description',
    compulsory: 'compulsory',
    createdAt: 'createdAt',
    isDeprecated: 'isDeprecated',
    updatedAt: 'updatedAt',
    productId: 'productId'
  };

  export type ProductFormScalarFieldEnum = (typeof ProductFormScalarFieldEnum)[keyof typeof ProductFormScalarFieldEnum]


  export const ProductSubFormScalarFieldEnum: {
    id: 'id',
    question: 'question',
    options: 'options',
    type: 'type',
    allowOther: 'allowOther',
    dependentField: 'dependentField',
    dependentOptions: 'dependentOptions',
    fileName: 'fileName',
    fileType: 'fileType',
    fileLink: 'fileLink',
    fileSize: 'fileSize',
    documentType: 'documentType',
    compulsory: 'compulsory',
    isDeprecated: 'isDeprecated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    formId: 'formId'
  };

  export type ProductSubFormScalarFieldEnum = (typeof ProductSubFormScalarFieldEnum)[keyof typeof ProductSubFormScalarFieldEnum]


  export const ProductRequestScalarFieldEnum: {
    id: 'id',
    email: 'email',
    address: 'address',
    paid: 'paid',
    completed: 'completed',
    status: 'status',
    currentState: 'currentState',
    createdAt: 'createdAt',
    isDeprecated: 'isDeprecated',
    updatedAt: 'updatedAt',
    productId: 'productId',
    userId: 'userId'
  };

  export type ProductRequestScalarFieldEnum = (typeof ProductRequestScalarFieldEnum)[keyof typeof ProductRequestScalarFieldEnum]


  export const ProductRequestQAScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    type: 'type',
    compulsory: 'compulsory',
    isGeneral: 'isGeneral',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeprecated: 'isDeprecated',
    requestId: 'requestId'
  };

  export type ProductRequestQAScalarFieldEnum = (typeof ProductRequestQAScalarFieldEnum)[keyof typeof ProductRequestQAScalarFieldEnum]


  export const ProductRequestQASubFormScalarFieldEnum: {
    id: 'id',
    question: 'question',
    answer: 'answer',
    type: 'type',
    fileName: 'fileName',
    fileType: 'fileType',
    fileLink: 'fileLink',
    fileSize: 'fileSize',
    compulsory: 'compulsory',
    isDeprecated: 'isDeprecated',
    requestQAId: 'requestQAId'
  };

  export type ProductRequestQASubFormScalarFieldEnum = (typeof ProductRequestQASubFormScalarFieldEnum)[keyof typeof ProductRequestQASubFormScalarFieldEnum]


  export const ClaimScalarFieldEnum: {
    id: 'id',
    value: 'value',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeprecated: 'isDeprecated'
  };

  export type ClaimScalarFieldEnum = (typeof ClaimScalarFieldEnum)[keyof typeof ClaimScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeprecated: 'isDeprecated',
    productRequestId: 'productRequestId'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const TeamMemberScalarFieldEnum: {
    id: 'id',
    isLaunchMember: 'isLaunchMember',
    isLaunchController: 'isLaunchController',
    isLaunchOwner: 'isLaunchOwner',
    launchOwnership: 'launchOwnership',
    teamId: 'teamId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeprecated: 'isDeprecated'
  };

  export type TeamMemberScalarFieldEnum = (typeof TeamMemberScalarFieldEnum)[keyof typeof TeamMemberScalarFieldEnum]


  export const InvitationScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    email: 'email',
    token: 'token',
    expireIn: 'expireIn',
    invitedBy: 'invitedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeprecated: 'isDeprecated'
  };

  export type InvitationScalarFieldEnum = (typeof InvitationScalarFieldEnum)[keyof typeof InvitationScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    provider: 'provider',
    transactionId: 'transactionId',
    status: 'status',
    email: 'email',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeprecated: 'isDeprecated',
    productRequestId: 'productRequestId'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const ParterScalarFieldEnum: {
    id: 'id',
    isVerified: 'isVerified',
    verificationDocument: 'verificationDocument',
    serviceScore: 'serviceScore',
    paymentsMade: 'paymentsMade',
    paymentsDue: 'paymentsDue',
    paymentDetails: 'paymentDetails',
    countrySupported: 'countrySupported',
    serviceSupported: 'serviceSupported',
    servicesAssigned: 'servicesAssigned',
    servicesCompleted: 'servicesCompleted',
    servicesDeclined: 'servicesDeclined',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeprecated: 'isDeprecated'
  };

  export type ParterScalarFieldEnum = (typeof ParterScalarFieldEnum)[keyof typeof ParterScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Deep Input Types
   */


  export type StaffWhereInput = {
    AND?: Enumerable<StaffWhereInput>
    OR?: Enumerable<StaffWhereInput>
    NOT?: Enumerable<StaffWhereInput>
    id?: StringFilter | string
    firstName?: StringFilter | string
    lastName?: StringFilter | string
    email?: StringFilter | string
    password?: StringFilter | string
    phone?: StringFilter | string
    verified?: BoolFilter | boolean
    picture?: StringNullableFilter | string | null
    resetToken?: StringNullableFilter | string | null
    isDeprecated?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type StaffOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    verified?: SortOrder
    picture?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffWhereUniqueInput = {
    id?: string
    email?: string
  }

  export type StaffOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    verified?: SortOrder
    picture?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StaffCountOrderByAggregateInput
    _max?: StaffMaxOrderByAggregateInput
    _min?: StaffMinOrderByAggregateInput
  }

  export type StaffScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StaffScalarWhereWithAggregatesInput>
    OR?: Enumerable<StaffScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StaffScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    firstName?: StringWithAggregatesFilter | string
    lastName?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    phone?: StringWithAggregatesFilter | string
    verified?: BoolWithAggregatesFilter | boolean
    picture?: StringNullableWithAggregatesFilter | string | null
    resetToken?: StringNullableWithAggregatesFilter | string | null
    isDeprecated?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CollaboratorWhereInput = {
    AND?: Enumerable<CollaboratorWhereInput>
    OR?: Enumerable<CollaboratorWhereInput>
    NOT?: Enumerable<CollaboratorWhereInput>
    id?: StringFilter | string
    firstName?: StringFilter | string
    lastName?: StringFilter | string
    email?: StringFilter | string
    password?: StringFilter | string
    phone?: StringFilter | string
    picture?: StringNullableFilter | string | null
    verified?: BoolFilter | boolean
    isPartner?: BoolFilter | boolean
    resetToken?: StringNullableFilter | string | null
    isDeprecated?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    collaboratorDocument?: CollaboratorDocumentListRelationFilter
  }

  export type CollaboratorOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    picture?: SortOrderInput | SortOrder
    verified?: SortOrder
    isPartner?: SortOrder
    resetToken?: SortOrderInput | SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    collaboratorDocument?: CollaboratorDocumentOrderByRelationAggregateInput
  }

  export type CollaboratorWhereUniqueInput = {
    id?: string
    email?: string
  }

  export type CollaboratorOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    picture?: SortOrderInput | SortOrder
    verified?: SortOrder
    isPartner?: SortOrder
    resetToken?: SortOrderInput | SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CollaboratorCountOrderByAggregateInput
    _max?: CollaboratorMaxOrderByAggregateInput
    _min?: CollaboratorMinOrderByAggregateInput
  }

  export type CollaboratorScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CollaboratorScalarWhereWithAggregatesInput>
    OR?: Enumerable<CollaboratorScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CollaboratorScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    firstName?: StringWithAggregatesFilter | string
    lastName?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    phone?: StringWithAggregatesFilter | string
    picture?: StringNullableWithAggregatesFilter | string | null
    verified?: BoolWithAggregatesFilter | boolean
    isPartner?: BoolWithAggregatesFilter | boolean
    resetToken?: StringNullableWithAggregatesFilter | string | null
    isDeprecated?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CollaboratorDocumentWhereInput = {
    AND?: Enumerable<CollaboratorDocumentWhereInput>
    OR?: Enumerable<CollaboratorDocumentWhereInput>
    NOT?: Enumerable<CollaboratorDocumentWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    type?: StringFilter | string
    description?: StringFilter | string
    isDeprecated?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    collaboratorId?: StringFilter | string
    collaborator?: XOR<CollaboratorRelationFilter, CollaboratorWhereInput>
  }

  export type CollaboratorDocumentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    collaboratorId?: SortOrder
    collaborator?: CollaboratorOrderByWithRelationInput
  }

  export type CollaboratorDocumentWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type CollaboratorDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    collaboratorId?: SortOrder
    _count?: CollaboratorDocumentCountOrderByAggregateInput
    _max?: CollaboratorDocumentMaxOrderByAggregateInput
    _min?: CollaboratorDocumentMinOrderByAggregateInput
  }

  export type CollaboratorDocumentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CollaboratorDocumentScalarWhereWithAggregatesInput>
    OR?: Enumerable<CollaboratorDocumentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CollaboratorDocumentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    isDeprecated?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    collaboratorId?: StringWithAggregatesFilter | string
  }

  export type RewardWhereInput = {
    AND?: Enumerable<RewardWhereInput>
    OR?: Enumerable<RewardWhereInput>
    NOT?: Enumerable<RewardWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    url?: StringFilter | string
    descrition?: StringFilter | string
    image?: StringFilter | string
    isDeprecated?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type RewardOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    descrition?: SortOrder
    image?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RewardWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type RewardOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    descrition?: SortOrder
    image?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RewardCountOrderByAggregateInput
    _max?: RewardMaxOrderByAggregateInput
    _min?: RewardMinOrderByAggregateInput
  }

  export type RewardScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RewardScalarWhereWithAggregatesInput>
    OR?: Enumerable<RewardScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RewardScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    url?: StringWithAggregatesFilter | string
    descrition?: StringWithAggregatesFilter | string
    image?: StringWithAggregatesFilter | string
    isDeprecated?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CountryWhereInput = {
    AND?: Enumerable<CountryWhereInput>
    OR?: Enumerable<CountryWhereInput>
    NOT?: Enumerable<CountryWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    iso?: StringFilter | string
    currency?: StringFilter | string
    code?: StringFilter | string
    flagUrl?: StringFilter | string
    isDeprecated?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type CountryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    iso?: SortOrder
    currency?: SortOrder
    code?: SortOrder
    flagUrl?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CountryWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type CountryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    iso?: SortOrder
    currency?: SortOrder
    code?: SortOrder
    flagUrl?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CountryCountOrderByAggregateInput
    _max?: CountryMaxOrderByAggregateInput
    _min?: CountryMinOrderByAggregateInput
  }

  export type CountryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CountryScalarWhereWithAggregatesInput>
    OR?: Enumerable<CountryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CountryScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    iso?: StringWithAggregatesFilter | string
    currency?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    flagUrl?: StringWithAggregatesFilter | string
    isDeprecated?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type BankWhereInput = {
    AND?: Enumerable<BankWhereInput>
    OR?: Enumerable<BankWhereInput>
    NOT?: Enumerable<BankWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    code?: StringFilter | string
    url?: StringFilter | string
    image?: StringFilter | string
    isDeprecated?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type BankOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    url?: SortOrder
    image?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type BankOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    url?: SortOrder
    image?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BankCountOrderByAggregateInput
    _max?: BankMaxOrderByAggregateInput
    _min?: BankMinOrderByAggregateInput
  }

  export type BankScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BankScalarWhereWithAggregatesInput>
    OR?: Enumerable<BankScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BankScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    url?: StringWithAggregatesFilter | string
    image?: StringWithAggregatesFilter | string
    isDeprecated?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type NotificationWhereInput = {
    AND?: Enumerable<NotificationWhereInput>
    OR?: Enumerable<NotificationWhereInput>
    NOT?: Enumerable<NotificationWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    body?: StringFilter | string
    readStatus?: BoolFilter | boolean
    isDeprecated?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    body?: SortOrder
    readStatus?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationWhereUniqueInput = {
    id?: string
  }

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    body?: SortOrder
    readStatus?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<NotificationScalarWhereWithAggregatesInput>
    OR?: Enumerable<NotificationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<NotificationScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    body?: StringWithAggregatesFilter | string
    readStatus?: BoolWithAggregatesFilter | boolean
    isDeprecated?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AccountWhereInput = {
    AND?: Enumerable<AccountWhereInput>
    OR?: Enumerable<AccountWhereInput>
    NOT?: Enumerable<AccountWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    type?: StringFilter | string
    provider?: StringFilter | string
    scope?: StringFilter | string
    isDeprecated?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    scope?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = {
    id?: string
  }

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    scope?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AccountScalarWhereWithAggregatesInput>
    OR?: Enumerable<AccountScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AccountScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    provider?: StringWithAggregatesFilter | string
    scope?: StringWithAggregatesFilter | string
    isDeprecated?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    fullName?: StringFilter | string
    username?: StringNullableFilter | string | null
    email?: StringFilter | string
    password?: StringNullableFilter | string | null
    googleId?: StringNullableFilter | string | null
    phone?: StringNullableFilter | string | null
    picture?: StringNullableFilter | string | null
    isVerified?: BoolFilter | boolean
    referral?: StringNullableFilter | string | null
    country?: StringNullableFilter | string | null
    resetToken?: StringNullableFilter | string | null
    isPartner?: BoolFilter | boolean
    isStaff?: BoolFilter | boolean
    isPhoneRegistered?: BoolFilter | boolean
    isPhoneVerified?: BoolFilter | boolean
    isIdentificationRegistered?: BoolFilter | boolean
    isIdentificationVerified?: BoolFilter | boolean
    partnerPermission?: StringNullableListFilter
    staffPermission?: StringNullableListFilter
    userPermission?: StringNullableListFilter
    isDeprecated?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    teamMember?: TeamMemberListRelationFilter
    account?: AccountListRelationFilter
    productRequest?: ProductRequestListRelationFilter
    document?: UserDocumentListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    fullName?: SortOrder
    username?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    googleId?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    picture?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    referral?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    isPartner?: SortOrder
    isStaff?: SortOrder
    isPhoneRegistered?: SortOrder
    isPhoneVerified?: SortOrder
    isIdentificationRegistered?: SortOrder
    isIdentificationVerified?: SortOrder
    partnerPermission?: SortOrder
    staffPermission?: SortOrder
    userPermission?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teamMember?: TeamMemberOrderByRelationAggregateInput
    account?: AccountOrderByRelationAggregateInput
    productRequest?: ProductRequestOrderByRelationAggregateInput
    document?: UserDocumentOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: string
    email?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    fullName?: SortOrder
    username?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    googleId?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    picture?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    referral?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    isPartner?: SortOrder
    isStaff?: SortOrder
    isPhoneRegistered?: SortOrder
    isPhoneVerified?: SortOrder
    isIdentificationRegistered?: SortOrder
    isIdentificationVerified?: SortOrder
    partnerPermission?: SortOrder
    staffPermission?: SortOrder
    userPermission?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    fullName?: StringWithAggregatesFilter | string
    username?: StringNullableWithAggregatesFilter | string | null
    email?: StringWithAggregatesFilter | string
    password?: StringNullableWithAggregatesFilter | string | null
    googleId?: StringNullableWithAggregatesFilter | string | null
    phone?: StringNullableWithAggregatesFilter | string | null
    picture?: StringNullableWithAggregatesFilter | string | null
    isVerified?: BoolWithAggregatesFilter | boolean
    referral?: StringNullableWithAggregatesFilter | string | null
    country?: StringNullableWithAggregatesFilter | string | null
    resetToken?: StringNullableWithAggregatesFilter | string | null
    isPartner?: BoolWithAggregatesFilter | boolean
    isStaff?: BoolWithAggregatesFilter | boolean
    isPhoneRegistered?: BoolWithAggregatesFilter | boolean
    isPhoneVerified?: BoolWithAggregatesFilter | boolean
    isIdentificationRegistered?: BoolWithAggregatesFilter | boolean
    isIdentificationVerified?: BoolWithAggregatesFilter | boolean
    partnerPermission?: StringNullableListFilter
    staffPermission?: StringNullableListFilter
    userPermission?: StringNullableListFilter
    isDeprecated?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserDocumentWhereInput = {
    AND?: Enumerable<UserDocumentWhereInput>
    OR?: Enumerable<UserDocumentWhereInput>
    NOT?: Enumerable<UserDocumentWhereInput>
    id?: StringFilter | string
    name?: StringNullableFilter | string | null
    type?: StringNullableFilter | string | null
    link?: StringNullableFilter | string | null
    size?: StringNullableFilter | string | null
    belongsTo?: StringNullableFilter | string | null
    isDeprecated?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    userId?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserDocumentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    belongsTo?: SortOrderInput | SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserDocumentWhereUniqueInput = {
    id?: string
  }

  export type UserDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    belongsTo?: SortOrderInput | SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    _count?: UserDocumentCountOrderByAggregateInput
    _max?: UserDocumentMaxOrderByAggregateInput
    _min?: UserDocumentMinOrderByAggregateInput
  }

  export type UserDocumentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserDocumentScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserDocumentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserDocumentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringNullableWithAggregatesFilter | string | null
    type?: StringNullableWithAggregatesFilter | string | null
    link?: StringNullableWithAggregatesFilter | string | null
    size?: StringNullableWithAggregatesFilter | string | null
    belongsTo?: StringNullableWithAggregatesFilter | string | null
    isDeprecated?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    userId?: StringWithAggregatesFilter | string
  }

  export type ServiceWhereInput = {
    AND?: Enumerable<ServiceWhereInput>
    OR?: Enumerable<ServiceWhereInput>
    NOT?: Enumerable<ServiceWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    description?: StringFilter | string
    isDeprecated?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    products?: ProductListRelationFilter
    form?: ServiceFormListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    products?: ProductOrderByRelationAggregateInput
    form?: ServiceFormOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ServiceScalarWhereWithAggregatesInput>
    OR?: Enumerable<ServiceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ServiceScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    isDeprecated?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ServiceFormWhereInput = {
    AND?: Enumerable<ServiceFormWhereInput>
    OR?: Enumerable<ServiceFormWhereInput>
    NOT?: Enumerable<ServiceFormWhereInput>
    id?: StringFilter | string
    title?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    type?: StringNullableFilter | string | null
    compulsory?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeprecated?: BoolFilter | boolean
    serviceId?: StringFilter | string
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
    subForm?: ServiceSubFormListRelationFilter
  }

  export type ServiceFormOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    compulsory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
    serviceId?: SortOrder
    service?: ServiceOrderByWithRelationInput
    subForm?: ServiceSubFormOrderByRelationAggregateInput
  }

  export type ServiceFormWhereUniqueInput = {
    id?: string
  }

  export type ServiceFormOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    compulsory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
    serviceId?: SortOrder
    _count?: ServiceFormCountOrderByAggregateInput
    _max?: ServiceFormMaxOrderByAggregateInput
    _min?: ServiceFormMinOrderByAggregateInput
  }

  export type ServiceFormScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ServiceFormScalarWhereWithAggregatesInput>
    OR?: Enumerable<ServiceFormScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ServiceFormScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    title?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    type?: StringNullableWithAggregatesFilter | string | null
    compulsory?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeprecated?: BoolWithAggregatesFilter | boolean
    serviceId?: StringWithAggregatesFilter | string
  }

  export type ServiceSubFormWhereInput = {
    AND?: Enumerable<ServiceSubFormWhereInput>
    OR?: Enumerable<ServiceSubFormWhereInput>
    NOT?: Enumerable<ServiceSubFormWhereInput>
    id?: StringFilter | string
    question?: StringNullableFilter | string | null
    type?: StringNullableFilter | string | null
    options?: StringNullableListFilter
    fileName?: StringNullableFilter | string | null
    fileType?: StringNullableFilter | string | null
    fileLink?: StringNullableFilter | string | null
    fileSize?: StringNullableFilter | string | null
    dependentField?: StringNullableFilter | string | null
    dependentOptions?: StringNullableListFilter
    documentType?: StringNullableFilter | string | null
    allowOther?: BoolFilter | boolean
    compulsory?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeprecated?: BoolFilter | boolean
    formId?: StringFilter | string
    form?: XOR<ServiceFormRelationFilter, ServiceFormWhereInput>
  }

  export type ServiceSubFormOrderByWithRelationInput = {
    id?: SortOrder
    question?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    options?: SortOrder
    fileName?: SortOrderInput | SortOrder
    fileType?: SortOrderInput | SortOrder
    fileLink?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    dependentField?: SortOrderInput | SortOrder
    dependentOptions?: SortOrder
    documentType?: SortOrderInput | SortOrder
    allowOther?: SortOrder
    compulsory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
    formId?: SortOrder
    form?: ServiceFormOrderByWithRelationInput
  }

  export type ServiceSubFormWhereUniqueInput = {
    id?: string
  }

  export type ServiceSubFormOrderByWithAggregationInput = {
    id?: SortOrder
    question?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    options?: SortOrder
    fileName?: SortOrderInput | SortOrder
    fileType?: SortOrderInput | SortOrder
    fileLink?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    dependentField?: SortOrderInput | SortOrder
    dependentOptions?: SortOrder
    documentType?: SortOrderInput | SortOrder
    allowOther?: SortOrder
    compulsory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
    formId?: SortOrder
    _count?: ServiceSubFormCountOrderByAggregateInput
    _max?: ServiceSubFormMaxOrderByAggregateInput
    _min?: ServiceSubFormMinOrderByAggregateInput
  }

  export type ServiceSubFormScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ServiceSubFormScalarWhereWithAggregatesInput>
    OR?: Enumerable<ServiceSubFormScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ServiceSubFormScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    question?: StringNullableWithAggregatesFilter | string | null
    type?: StringNullableWithAggregatesFilter | string | null
    options?: StringNullableListFilter
    fileName?: StringNullableWithAggregatesFilter | string | null
    fileType?: StringNullableWithAggregatesFilter | string | null
    fileLink?: StringNullableWithAggregatesFilter | string | null
    fileSize?: StringNullableWithAggregatesFilter | string | null
    dependentField?: StringNullableWithAggregatesFilter | string | null
    dependentOptions?: StringNullableListFilter
    documentType?: StringNullableWithAggregatesFilter | string | null
    allowOther?: BoolWithAggregatesFilter | boolean
    compulsory?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeprecated?: BoolWithAggregatesFilter | boolean
    formId?: StringWithAggregatesFilter | string
  }

  export type ProductWhereInput = {
    AND?: Enumerable<ProductWhereInput>
    OR?: Enumerable<ProductWhereInput>
    NOT?: Enumerable<ProductWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    description?: StringFilter | string
    country?: StringFilter | string
    currency?: StringFilter | string
    amount?: IntFilter | number
    timeline?: StringFilter | string
    feature?: StringNullableListFilter
    canAlsoDo?: StringNullableListFilter
    hasShares?: BoolFilter | boolean
    hasAgent?: BoolFilter | boolean
    hasOwner?: BoolFilter | boolean
    hasController?: BoolFilter | boolean
    controllerIsCalled?: StringNullableFilter | string | null
    OwnerIsCalled?: StringNullableFilter | string | null
    agentIsCalled?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeprecated?: BoolFilter | boolean
    serviceId?: StringFilter | string
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
    request?: ProductRequestListRelationFilter
    form?: ProductFormListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    country?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    timeline?: SortOrder
    feature?: SortOrder
    canAlsoDo?: SortOrder
    hasShares?: SortOrder
    hasAgent?: SortOrder
    hasOwner?: SortOrder
    hasController?: SortOrder
    controllerIsCalled?: SortOrderInput | SortOrder
    OwnerIsCalled?: SortOrderInput | SortOrder
    agentIsCalled?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
    serviceId?: SortOrder
    service?: ServiceOrderByWithRelationInput
    request?: ProductRequestOrderByRelationAggregateInput
    form?: ProductFormOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = {
    id?: string
  }

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    country?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    timeline?: SortOrder
    feature?: SortOrder
    canAlsoDo?: SortOrder
    hasShares?: SortOrder
    hasAgent?: SortOrder
    hasOwner?: SortOrder
    hasController?: SortOrder
    controllerIsCalled?: SortOrderInput | SortOrder
    OwnerIsCalled?: SortOrderInput | SortOrder
    agentIsCalled?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
    serviceId?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    country?: StringWithAggregatesFilter | string
    currency?: StringWithAggregatesFilter | string
    amount?: IntWithAggregatesFilter | number
    timeline?: StringWithAggregatesFilter | string
    feature?: StringNullableListFilter
    canAlsoDo?: StringNullableListFilter
    hasShares?: BoolWithAggregatesFilter | boolean
    hasAgent?: BoolWithAggregatesFilter | boolean
    hasOwner?: BoolWithAggregatesFilter | boolean
    hasController?: BoolWithAggregatesFilter | boolean
    controllerIsCalled?: StringNullableWithAggregatesFilter | string | null
    OwnerIsCalled?: StringNullableWithAggregatesFilter | string | null
    agentIsCalled?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeprecated?: BoolWithAggregatesFilter | boolean
    serviceId?: StringWithAggregatesFilter | string
  }

  export type ProductFormWhereInput = {
    AND?: Enumerable<ProductFormWhereInput>
    OR?: Enumerable<ProductFormWhereInput>
    NOT?: Enumerable<ProductFormWhereInput>
    id?: StringFilter | string
    title?: StringNullableFilter | string | null
    type?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    compulsory?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    isDeprecated?: BoolFilter | boolean
    updatedAt?: DateTimeFilter | Date | string
    productId?: StringFilter | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    productSubForm?: ProductSubFormListRelationFilter
  }

  export type ProductFormOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    compulsory?: SortOrder
    createdAt?: SortOrder
    isDeprecated?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
    product?: ProductOrderByWithRelationInput
    productSubForm?: ProductSubFormOrderByRelationAggregateInput
  }

  export type ProductFormWhereUniqueInput = {
    id?: string
  }

  export type ProductFormOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    compulsory?: SortOrder
    createdAt?: SortOrder
    isDeprecated?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
    _count?: ProductFormCountOrderByAggregateInput
    _max?: ProductFormMaxOrderByAggregateInput
    _min?: ProductFormMinOrderByAggregateInput
  }

  export type ProductFormScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductFormScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductFormScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductFormScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    title?: StringNullableWithAggregatesFilter | string | null
    type?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    compulsory?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    isDeprecated?: BoolWithAggregatesFilter | boolean
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    productId?: StringWithAggregatesFilter | string
  }

  export type ProductSubFormWhereInput = {
    AND?: Enumerable<ProductSubFormWhereInput>
    OR?: Enumerable<ProductSubFormWhereInput>
    NOT?: Enumerable<ProductSubFormWhereInput>
    id?: StringFilter | string
    question?: StringNullableFilter | string | null
    options?: StringNullableListFilter
    type?: StringNullableFilter | string | null
    allowOther?: BoolFilter | boolean
    dependentField?: StringNullableFilter | string | null
    dependentOptions?: StringNullableListFilter
    fileName?: StringNullableFilter | string | null
    fileType?: StringNullableFilter | string | null
    fileLink?: StringNullableFilter | string | null
    fileSize?: StringNullableFilter | string | null
    documentType?: StringNullableFilter | string | null
    compulsory?: BoolFilter | boolean
    isDeprecated?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    formId?: StringFilter | string
    form?: XOR<ProductFormRelationFilter, ProductFormWhereInput>
  }

  export type ProductSubFormOrderByWithRelationInput = {
    id?: SortOrder
    question?: SortOrderInput | SortOrder
    options?: SortOrder
    type?: SortOrderInput | SortOrder
    allowOther?: SortOrder
    dependentField?: SortOrderInput | SortOrder
    dependentOptions?: SortOrder
    fileName?: SortOrderInput | SortOrder
    fileType?: SortOrderInput | SortOrder
    fileLink?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    documentType?: SortOrderInput | SortOrder
    compulsory?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    formId?: SortOrder
    form?: ProductFormOrderByWithRelationInput
  }

  export type ProductSubFormWhereUniqueInput = {
    id?: string
  }

  export type ProductSubFormOrderByWithAggregationInput = {
    id?: SortOrder
    question?: SortOrderInput | SortOrder
    options?: SortOrder
    type?: SortOrderInput | SortOrder
    allowOther?: SortOrder
    dependentField?: SortOrderInput | SortOrder
    dependentOptions?: SortOrder
    fileName?: SortOrderInput | SortOrder
    fileType?: SortOrderInput | SortOrder
    fileLink?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    documentType?: SortOrderInput | SortOrder
    compulsory?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    formId?: SortOrder
    _count?: ProductSubFormCountOrderByAggregateInput
    _max?: ProductSubFormMaxOrderByAggregateInput
    _min?: ProductSubFormMinOrderByAggregateInput
  }

  export type ProductSubFormScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductSubFormScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductSubFormScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductSubFormScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    question?: StringNullableWithAggregatesFilter | string | null
    options?: StringNullableListFilter
    type?: StringNullableWithAggregatesFilter | string | null
    allowOther?: BoolWithAggregatesFilter | boolean
    dependentField?: StringNullableWithAggregatesFilter | string | null
    dependentOptions?: StringNullableListFilter
    fileName?: StringNullableWithAggregatesFilter | string | null
    fileType?: StringNullableWithAggregatesFilter | string | null
    fileLink?: StringNullableWithAggregatesFilter | string | null
    fileSize?: StringNullableWithAggregatesFilter | string | null
    documentType?: StringNullableWithAggregatesFilter | string | null
    compulsory?: BoolWithAggregatesFilter | boolean
    isDeprecated?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    formId?: StringWithAggregatesFilter | string
  }

  export type ProductRequestWhereInput = {
    AND?: Enumerable<ProductRequestWhereInput>
    OR?: Enumerable<ProductRequestWhereInput>
    NOT?: Enumerable<ProductRequestWhereInput>
    id?: StringFilter | string
    email?: StringNullableFilter | string | null
    address?: StringNullableFilter | string | null
    paid?: BoolFilter | boolean
    completed?: BoolFilter | boolean
    status?: StringFilter | string
    currentState?: EnumProductActivityStageFilter | ProductActivityStage
    createdAt?: DateTimeFilter | Date | string
    isDeprecated?: BoolFilter | boolean
    updatedAt?: DateTimeFilter | Date | string
    productId?: StringNullableFilter | string | null
    userId?: StringFilter | string
    Team?: TeamListRelationFilter
    product?: XOR<ProductRelationFilter, ProductWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    Payment?: PaymentListRelationFilter
    requestQA?: ProductRequestQAListRelationFilter
  }

  export type ProductRequestOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    paid?: SortOrder
    completed?: SortOrder
    status?: SortOrder
    currentState?: SortOrder
    createdAt?: SortOrder
    isDeprecated?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrderInput | SortOrder
    userId?: SortOrder
    Team?: TeamOrderByRelationAggregateInput
    product?: ProductOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    Payment?: PaymentOrderByRelationAggregateInput
    requestQA?: ProductRequestQAOrderByRelationAggregateInput
  }

  export type ProductRequestWhereUniqueInput = {
    id?: string
  }

  export type ProductRequestOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    paid?: SortOrder
    completed?: SortOrder
    status?: SortOrder
    currentState?: SortOrder
    createdAt?: SortOrder
    isDeprecated?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrderInput | SortOrder
    userId?: SortOrder
    _count?: ProductRequestCountOrderByAggregateInput
    _max?: ProductRequestMaxOrderByAggregateInput
    _min?: ProductRequestMinOrderByAggregateInput
  }

  export type ProductRequestScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductRequestScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductRequestScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductRequestScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    email?: StringNullableWithAggregatesFilter | string | null
    address?: StringNullableWithAggregatesFilter | string | null
    paid?: BoolWithAggregatesFilter | boolean
    completed?: BoolWithAggregatesFilter | boolean
    status?: StringWithAggregatesFilter | string
    currentState?: EnumProductActivityStageWithAggregatesFilter | ProductActivityStage
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    isDeprecated?: BoolWithAggregatesFilter | boolean
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    productId?: StringNullableWithAggregatesFilter | string | null
    userId?: StringWithAggregatesFilter | string
  }

  export type ProductRequestQAWhereInput = {
    AND?: Enumerable<ProductRequestQAWhereInput>
    OR?: Enumerable<ProductRequestQAWhereInput>
    NOT?: Enumerable<ProductRequestQAWhereInput>
    id?: StringFilter | string
    title?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    type?: StringNullableFilter | string | null
    compulsory?: BoolFilter | boolean
    isGeneral?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeprecated?: BoolFilter | boolean
    requestId?: StringFilter | string
    request?: XOR<ProductRequestRelationFilter, ProductRequestWhereInput>
    subForm?: ProductRequestQASubFormListRelationFilter
  }

  export type ProductRequestQAOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    compulsory?: SortOrder
    isGeneral?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
    requestId?: SortOrder
    request?: ProductRequestOrderByWithRelationInput
    subForm?: ProductRequestQASubFormOrderByRelationAggregateInput
  }

  export type ProductRequestQAWhereUniqueInput = {
    id?: string
  }

  export type ProductRequestQAOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    compulsory?: SortOrder
    isGeneral?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
    requestId?: SortOrder
    _count?: ProductRequestQACountOrderByAggregateInput
    _max?: ProductRequestQAMaxOrderByAggregateInput
    _min?: ProductRequestQAMinOrderByAggregateInput
  }

  export type ProductRequestQAScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductRequestQAScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductRequestQAScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductRequestQAScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    title?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    type?: StringNullableWithAggregatesFilter | string | null
    compulsory?: BoolWithAggregatesFilter | boolean
    isGeneral?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeprecated?: BoolWithAggregatesFilter | boolean
    requestId?: StringWithAggregatesFilter | string
  }

  export type ProductRequestQASubFormWhereInput = {
    AND?: Enumerable<ProductRequestQASubFormWhereInput>
    OR?: Enumerable<ProductRequestQASubFormWhereInput>
    NOT?: Enumerable<ProductRequestQASubFormWhereInput>
    id?: StringFilter | string
    question?: StringNullableFilter | string | null
    answer?: StringNullableListFilter
    type?: StringNullableFilter | string | null
    fileName?: StringNullableFilter | string | null
    fileType?: StringNullableFilter | string | null
    fileLink?: StringNullableFilter | string | null
    fileSize?: StringNullableFilter | string | null
    compulsory?: BoolFilter | boolean
    isDeprecated?: BoolFilter | boolean
    requestQAId?: StringFilter | string
    requestQA?: XOR<ProductRequestQARelationFilter, ProductRequestQAWhereInput>
  }

  export type ProductRequestQASubFormOrderByWithRelationInput = {
    id?: SortOrder
    question?: SortOrderInput | SortOrder
    answer?: SortOrder
    type?: SortOrderInput | SortOrder
    fileName?: SortOrderInput | SortOrder
    fileType?: SortOrderInput | SortOrder
    fileLink?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    compulsory?: SortOrder
    isDeprecated?: SortOrder
    requestQAId?: SortOrder
    requestQA?: ProductRequestQAOrderByWithRelationInput
  }

  export type ProductRequestQASubFormWhereUniqueInput = {
    id?: string
  }

  export type ProductRequestQASubFormOrderByWithAggregationInput = {
    id?: SortOrder
    question?: SortOrderInput | SortOrder
    answer?: SortOrder
    type?: SortOrderInput | SortOrder
    fileName?: SortOrderInput | SortOrder
    fileType?: SortOrderInput | SortOrder
    fileLink?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    compulsory?: SortOrder
    isDeprecated?: SortOrder
    requestQAId?: SortOrder
    _count?: ProductRequestQASubFormCountOrderByAggregateInput
    _max?: ProductRequestQASubFormMaxOrderByAggregateInput
    _min?: ProductRequestQASubFormMinOrderByAggregateInput
  }

  export type ProductRequestQASubFormScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductRequestQASubFormScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductRequestQASubFormScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductRequestQASubFormScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    question?: StringNullableWithAggregatesFilter | string | null
    answer?: StringNullableListFilter
    type?: StringNullableWithAggregatesFilter | string | null
    fileName?: StringNullableWithAggregatesFilter | string | null
    fileType?: StringNullableWithAggregatesFilter | string | null
    fileLink?: StringNullableWithAggregatesFilter | string | null
    fileSize?: StringNullableWithAggregatesFilter | string | null
    compulsory?: BoolWithAggregatesFilter | boolean
    isDeprecated?: BoolWithAggregatesFilter | boolean
    requestQAId?: StringWithAggregatesFilter | string
  }

  export type ClaimWhereInput = {
    AND?: Enumerable<ClaimWhereInput>
    OR?: Enumerable<ClaimWhereInput>
    NOT?: Enumerable<ClaimWhereInput>
    id?: StringFilter | string
    value?: StringFilter | string
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeprecated?: BoolFilter | boolean
  }

  export type ClaimOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
  }

  export type ClaimWhereUniqueInput = {
    id?: string
  }

  export type ClaimOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
    _count?: ClaimCountOrderByAggregateInput
    _max?: ClaimMaxOrderByAggregateInput
    _min?: ClaimMinOrderByAggregateInput
  }

  export type ClaimScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ClaimScalarWhereWithAggregatesInput>
    OR?: Enumerable<ClaimScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ClaimScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    value?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeprecated?: BoolWithAggregatesFilter | boolean
  }

  export type TeamWhereInput = {
    AND?: Enumerable<TeamWhereInput>
    OR?: Enumerable<TeamWhereInput>
    NOT?: Enumerable<TeamWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    slug?: StringFilter | string
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeprecated?: BoolFilter | boolean
    productRequestId?: StringFilter | string
    productRequest?: XOR<ProductRequestRelationFilter, ProductRequestWhereInput>
    invitation?: InvitationListRelationFilter
    teamMember?: TeamMemberListRelationFilter
  }

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
    productRequestId?: SortOrder
    productRequest?: ProductRequestOrderByWithRelationInput
    invitation?: InvitationOrderByRelationAggregateInput
    teamMember?: TeamMemberOrderByRelationAggregateInput
  }

  export type TeamWhereUniqueInput = {
    id?: string
  }

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
    productRequestId?: SortOrder
    _count?: TeamCountOrderByAggregateInput
    _max?: TeamMaxOrderByAggregateInput
    _min?: TeamMinOrderByAggregateInput
  }

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TeamScalarWhereWithAggregatesInput>
    OR?: Enumerable<TeamScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TeamScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeprecated?: BoolWithAggregatesFilter | boolean
    productRequestId?: StringWithAggregatesFilter | string
  }

  export type TeamMemberWhereInput = {
    AND?: Enumerable<TeamMemberWhereInput>
    OR?: Enumerable<TeamMemberWhereInput>
    NOT?: Enumerable<TeamMemberWhereInput>
    id?: StringFilter | string
    isLaunchMember?: BoolFilter | boolean
    isLaunchController?: BoolFilter | boolean
    isLaunchOwner?: BoolFilter | boolean
    launchOwnership?: IntFilter | number
    teamId?: StringFilter | string
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeprecated?: BoolFilter | boolean
    team?: XOR<TeamRelationFilter, TeamWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TeamMemberOrderByWithRelationInput = {
    id?: SortOrder
    isLaunchMember?: SortOrder
    isLaunchController?: SortOrder
    isLaunchOwner?: SortOrder
    launchOwnership?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
    team?: TeamOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TeamMemberWhereUniqueInput = {
    id?: string
  }

  export type TeamMemberOrderByWithAggregationInput = {
    id?: SortOrder
    isLaunchMember?: SortOrder
    isLaunchController?: SortOrder
    isLaunchOwner?: SortOrder
    launchOwnership?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
    _count?: TeamMemberCountOrderByAggregateInput
    _avg?: TeamMemberAvgOrderByAggregateInput
    _max?: TeamMemberMaxOrderByAggregateInput
    _min?: TeamMemberMinOrderByAggregateInput
    _sum?: TeamMemberSumOrderByAggregateInput
  }

  export type TeamMemberScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TeamMemberScalarWhereWithAggregatesInput>
    OR?: Enumerable<TeamMemberScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TeamMemberScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    isLaunchMember?: BoolWithAggregatesFilter | boolean
    isLaunchController?: BoolWithAggregatesFilter | boolean
    isLaunchOwner?: BoolWithAggregatesFilter | boolean
    launchOwnership?: IntWithAggregatesFilter | number
    teamId?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeprecated?: BoolWithAggregatesFilter | boolean
  }

  export type InvitationWhereInput = {
    AND?: Enumerable<InvitationWhereInput>
    OR?: Enumerable<InvitationWhereInput>
    NOT?: Enumerable<InvitationWhereInput>
    id?: StringFilter | string
    teamId?: StringFilter | string
    email?: StringFilter | string
    token?: StringFilter | string
    expireIn?: DateTimeFilter | Date | string
    invitedBy?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeprecated?: BoolFilter | boolean
    team?: XOR<TeamRelationFilter, TeamWhereInput>
  }

  export type InvitationOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expireIn?: SortOrder
    invitedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
    team?: TeamOrderByWithRelationInput
  }

  export type InvitationWhereUniqueInput = {
    id?: string
  }

  export type InvitationOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expireIn?: SortOrder
    invitedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
    _count?: InvitationCountOrderByAggregateInput
    _max?: InvitationMaxOrderByAggregateInput
    _min?: InvitationMinOrderByAggregateInput
  }

  export type InvitationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<InvitationScalarWhereWithAggregatesInput>
    OR?: Enumerable<InvitationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<InvitationScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    teamId?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    token?: StringWithAggregatesFilter | string
    expireIn?: DateTimeWithAggregatesFilter | Date | string
    invitedBy?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeprecated?: BoolWithAggregatesFilter | boolean
  }

  export type PaymentWhereInput = {
    AND?: Enumerable<PaymentWhereInput>
    OR?: Enumerable<PaymentWhereInput>
    NOT?: Enumerable<PaymentWhereInput>
    id?: StringFilter | string
    provider?: StringFilter | string
    transactionId?: StringFilter | string
    status?: StringFilter | string
    email?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeprecated?: BoolFilter | boolean
    productRequestId?: StringFilter | string
    productRequests?: XOR<ProductRequestRelationFilter, ProductRequestWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    provider?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
    productRequestId?: SortOrder
    productRequests?: ProductRequestOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = {
    id?: string
  }

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    provider?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
    productRequestId?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PaymentScalarWhereWithAggregatesInput>
    OR?: Enumerable<PaymentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PaymentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    provider?: StringWithAggregatesFilter | string
    transactionId?: StringWithAggregatesFilter | string
    status?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeprecated?: BoolWithAggregatesFilter | boolean
    productRequestId?: StringWithAggregatesFilter | string
  }

  export type ParterWhereInput = {
    AND?: Enumerable<ParterWhereInput>
    OR?: Enumerable<ParterWhereInput>
    NOT?: Enumerable<ParterWhereInput>
    id?: StringFilter | string
    isVerified?: BoolFilter | boolean
    verificationDocument?: StringNullableListFilter
    serviceScore?: IntFilter | number
    paymentsMade?: IntFilter | number
    paymentsDue?: IntFilter | number
    paymentDetails?: StringNullableListFilter
    countrySupported?: StringNullableListFilter
    serviceSupported?: StringNullableListFilter
    servicesAssigned?: StringNullableListFilter
    servicesCompleted?: StringNullableListFilter
    servicesDeclined?: StringNullableListFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeprecated?: BoolFilter | boolean
  }

  export type ParterOrderByWithRelationInput = {
    id?: SortOrder
    isVerified?: SortOrder
    verificationDocument?: SortOrder
    serviceScore?: SortOrder
    paymentsMade?: SortOrder
    paymentsDue?: SortOrder
    paymentDetails?: SortOrder
    countrySupported?: SortOrder
    serviceSupported?: SortOrder
    servicesAssigned?: SortOrder
    servicesCompleted?: SortOrder
    servicesDeclined?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
  }

  export type ParterWhereUniqueInput = {
    id?: string
  }

  export type ParterOrderByWithAggregationInput = {
    id?: SortOrder
    isVerified?: SortOrder
    verificationDocument?: SortOrder
    serviceScore?: SortOrder
    paymentsMade?: SortOrder
    paymentsDue?: SortOrder
    paymentDetails?: SortOrder
    countrySupported?: SortOrder
    serviceSupported?: SortOrder
    servicesAssigned?: SortOrder
    servicesCompleted?: SortOrder
    servicesDeclined?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
    _count?: ParterCountOrderByAggregateInput
    _avg?: ParterAvgOrderByAggregateInput
    _max?: ParterMaxOrderByAggregateInput
    _min?: ParterMinOrderByAggregateInput
    _sum?: ParterSumOrderByAggregateInput
  }

  export type ParterScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ParterScalarWhereWithAggregatesInput>
    OR?: Enumerable<ParterScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ParterScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    isVerified?: BoolWithAggregatesFilter | boolean
    verificationDocument?: StringNullableListFilter
    serviceScore?: IntWithAggregatesFilter | number
    paymentsMade?: IntWithAggregatesFilter | number
    paymentsDue?: IntWithAggregatesFilter | number
    paymentDetails?: StringNullableListFilter
    countrySupported?: StringNullableListFilter
    serviceSupported?: StringNullableListFilter
    servicesAssigned?: StringNullableListFilter
    servicesCompleted?: StringNullableListFilter
    servicesDeclined?: StringNullableListFilter
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeprecated?: BoolWithAggregatesFilter | boolean
  }

  export type StaffCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    password: string
    phone: string
    verified: boolean
    picture?: string | null
    resetToken?: string | null
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    password: string
    phone: string
    verified: boolean
    picture?: string | null
    resetToken?: string | null
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffCreateManyInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    password: string
    phone: string
    verified: boolean
    picture?: string | null
    resetToken?: string | null
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollaboratorCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    password: string
    phone: string
    picture?: string | null
    verified: boolean
    isPartner: boolean
    resetToken?: string | null
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    collaboratorDocument?: CollaboratorDocumentCreateNestedManyWithoutCollaboratorInput
  }

  export type CollaboratorUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    password: string
    phone: string
    picture?: string | null
    verified: boolean
    isPartner: boolean
    resetToken?: string | null
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    collaboratorDocument?: CollaboratorDocumentUncheckedCreateNestedManyWithoutCollaboratorInput
  }

  export type CollaboratorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collaboratorDocument?: CollaboratorDocumentUpdateManyWithoutCollaboratorNestedInput
  }

  export type CollaboratorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collaboratorDocument?: CollaboratorDocumentUncheckedUpdateManyWithoutCollaboratorNestedInput
  }

  export type CollaboratorCreateManyInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    password: string
    phone: string
    picture?: string | null
    verified: boolean
    isPartner: boolean
    resetToken?: string | null
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CollaboratorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollaboratorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollaboratorDocumentCreateInput = {
    id?: string
    name: string
    type: string
    description: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    collaborator: CollaboratorCreateNestedOneWithoutCollaboratorDocumentInput
  }

  export type CollaboratorDocumentUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    description: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    collaboratorId: string
  }

  export type CollaboratorDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collaborator?: CollaboratorUpdateOneRequiredWithoutCollaboratorDocumentNestedInput
  }

  export type CollaboratorDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collaboratorId?: StringFieldUpdateOperationsInput | string
  }

  export type CollaboratorDocumentCreateManyInput = {
    id?: string
    name: string
    type: string
    description: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    collaboratorId: string
  }

  export type CollaboratorDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollaboratorDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collaboratorId?: StringFieldUpdateOperationsInput | string
  }

  export type RewardCreateInput = {
    id?: string
    name: string
    url: string
    descrition: string
    image: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RewardUncheckedCreateInput = {
    id?: string
    name: string
    url: string
    descrition: string
    image: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RewardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    descrition?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    descrition?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardCreateManyInput = {
    id?: string
    name: string
    url: string
    descrition: string
    image: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RewardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    descrition?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    descrition?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryCreateInput = {
    id?: string
    name: string
    iso: string
    currency: string
    code: string
    flagUrl: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CountryUncheckedCreateInput = {
    id?: string
    name: string
    iso: string
    currency: string
    code: string
    flagUrl: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CountryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iso?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    flagUrl?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iso?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    flagUrl?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryCreateManyInput = {
    id?: string
    name: string
    iso: string
    currency: string
    code: string
    flagUrl: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CountryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iso?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    flagUrl?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iso?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    flagUrl?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankCreateInput = {
    id?: string
    name: string
    code: string
    url: string
    image: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    url: string
    image: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankCreateManyInput = {
    id?: string
    name: string
    code: string
    url: string
    image: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    body: string
    readStatus: boolean
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    title: string
    body: string
    readStatus: boolean
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    title: string
    body: string
    readStatus: boolean
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    scope: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccountInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    scope: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    scope: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    fullName: string
    username?: string | null
    email: string
    password?: string | null
    googleId?: string | null
    phone?: string | null
    picture?: string | null
    isVerified?: boolean
    referral?: string | null
    country?: string | null
    resetToken?: string | null
    isPartner?: boolean
    isStaff?: boolean
    isPhoneRegistered?: boolean
    isPhoneVerified?: boolean
    isIdentificationRegistered?: boolean
    isIdentificationVerified?: boolean
    partnerPermission?: UserCreatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserCreatestaffPermissionInput | Enumerable<string>
    userPermission?: UserCreateuserPermissionInput | Enumerable<string>
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamMember?: TeamMemberCreateNestedManyWithoutUserInput
    account?: AccountCreateNestedManyWithoutUserInput
    productRequest?: ProductRequestCreateNestedManyWithoutUserInput
    document?: UserDocumentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    fullName: string
    username?: string | null
    email: string
    password?: string | null
    googleId?: string | null
    phone?: string | null
    picture?: string | null
    isVerified?: boolean
    referral?: string | null
    country?: string | null
    resetToken?: string | null
    isPartner?: boolean
    isStaff?: boolean
    isPhoneRegistered?: boolean
    isPhoneVerified?: boolean
    isIdentificationRegistered?: boolean
    isIdentificationVerified?: boolean
    partnerPermission?: UserCreatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserCreatestaffPermissionInput | Enumerable<string>
    userPermission?: UserCreateuserPermissionInput | Enumerable<string>
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamMember?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    account?: AccountUncheckedCreateNestedManyWithoutUserInput
    productRequest?: ProductRequestUncheckedCreateNestedManyWithoutUserInput
    document?: UserDocumentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    isStaff?: BoolFieldUpdateOperationsInput | boolean
    isPhoneRegistered?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationRegistered?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationVerified?: BoolFieldUpdateOperationsInput | boolean
    partnerPermission?: UserUpdatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserUpdatestaffPermissionInput | Enumerable<string>
    userPermission?: UserUpdateuserPermissionInput | Enumerable<string>
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMember?: TeamMemberUpdateManyWithoutUserNestedInput
    account?: AccountUpdateManyWithoutUserNestedInput
    productRequest?: ProductRequestUpdateManyWithoutUserNestedInput
    document?: UserDocumentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    isStaff?: BoolFieldUpdateOperationsInput | boolean
    isPhoneRegistered?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationRegistered?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationVerified?: BoolFieldUpdateOperationsInput | boolean
    partnerPermission?: UserUpdatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserUpdatestaffPermissionInput | Enumerable<string>
    userPermission?: UserUpdateuserPermissionInput | Enumerable<string>
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMember?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    account?: AccountUncheckedUpdateManyWithoutUserNestedInput
    productRequest?: ProductRequestUncheckedUpdateManyWithoutUserNestedInput
    document?: UserDocumentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    fullName: string
    username?: string | null
    email: string
    password?: string | null
    googleId?: string | null
    phone?: string | null
    picture?: string | null
    isVerified?: boolean
    referral?: string | null
    country?: string | null
    resetToken?: string | null
    isPartner?: boolean
    isStaff?: boolean
    isPhoneRegistered?: boolean
    isPhoneVerified?: boolean
    isIdentificationRegistered?: boolean
    isIdentificationVerified?: boolean
    partnerPermission?: UserCreatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserCreatestaffPermissionInput | Enumerable<string>
    userPermission?: UserCreateuserPermissionInput | Enumerable<string>
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    isStaff?: BoolFieldUpdateOperationsInput | boolean
    isPhoneRegistered?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationRegistered?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationVerified?: BoolFieldUpdateOperationsInput | boolean
    partnerPermission?: UserUpdatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserUpdatestaffPermissionInput | Enumerable<string>
    userPermission?: UserUpdateuserPermissionInput | Enumerable<string>
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    isStaff?: BoolFieldUpdateOperationsInput | boolean
    isPhoneRegistered?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationRegistered?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationVerified?: BoolFieldUpdateOperationsInput | boolean
    partnerPermission?: UserUpdatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserUpdatestaffPermissionInput | Enumerable<string>
    userPermission?: UserUpdateuserPermissionInput | Enumerable<string>
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserDocumentCreateInput = {
    id?: string
    name?: string | null
    type?: string | null
    link?: string | null
    size?: string | null
    belongsTo?: string | null
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDocumentInput
  }

  export type UserDocumentUncheckedCreateInput = {
    id?: string
    name?: string | null
    type?: string | null
    link?: string | null
    size?: string | null
    belongsTo?: string | null
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type UserDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    belongsTo?: NullableStringFieldUpdateOperationsInput | string | null
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDocumentNestedInput
  }

  export type UserDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    belongsTo?: NullableStringFieldUpdateOperationsInput | string | null
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserDocumentCreateManyInput = {
    id?: string
    name?: string | null
    type?: string | null
    link?: string | null
    size?: string | null
    belongsTo?: string | null
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type UserDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    belongsTo?: NullableStringFieldUpdateOperationsInput | string | null
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    belongsTo?: NullableStringFieldUpdateOperationsInput | string | null
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceCreateInput = {
    id?: string
    name: string
    description: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutServiceInput
    form?: ServiceFormCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutServiceInput
    form?: ServiceFormUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutServiceNestedInput
    form?: ServiceFormUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutServiceNestedInput
    form?: ServiceFormUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: string
    name: string
    description: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceFormCreateInput = {
    id?: string
    title?: string | null
    description?: string | null
    type?: string | null
    compulsory?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    service: ServiceCreateNestedOneWithoutFormInput
    subForm?: ServiceSubFormCreateNestedManyWithoutFormInput
  }

  export type ServiceFormUncheckedCreateInput = {
    id?: string
    title?: string | null
    description?: string | null
    type?: string | null
    compulsory?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    serviceId: string
    subForm?: ServiceSubFormUncheckedCreateNestedManyWithoutFormInput
  }

  export type ServiceFormUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    service?: ServiceUpdateOneRequiredWithoutFormNestedInput
    subForm?: ServiceSubFormUpdateManyWithoutFormNestedInput
  }

  export type ServiceFormUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    serviceId?: StringFieldUpdateOperationsInput | string
    subForm?: ServiceSubFormUncheckedUpdateManyWithoutFormNestedInput
  }

  export type ServiceFormCreateManyInput = {
    id?: string
    title?: string | null
    description?: string | null
    type?: string | null
    compulsory?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    serviceId: string
  }

  export type ServiceFormUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ServiceFormUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceSubFormCreateInput = {
    id?: string
    question?: string | null
    type?: string | null
    options?: ServiceSubFormCreateoptionsInput | Enumerable<string>
    fileName?: string | null
    fileType?: string | null
    fileLink?: string | null
    fileSize?: string | null
    dependentField?: string | null
    dependentOptions?: ServiceSubFormCreatedependentOptionsInput | Enumerable<string>
    documentType?: string | null
    allowOther?: boolean
    compulsory?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    form: ServiceFormCreateNestedOneWithoutSubFormInput
  }

  export type ServiceSubFormUncheckedCreateInput = {
    id?: string
    question?: string | null
    type?: string | null
    options?: ServiceSubFormCreateoptionsInput | Enumerable<string>
    fileName?: string | null
    fileType?: string | null
    fileLink?: string | null
    fileSize?: string | null
    dependentField?: string | null
    dependentOptions?: ServiceSubFormCreatedependentOptionsInput | Enumerable<string>
    documentType?: string | null
    allowOther?: boolean
    compulsory?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    formId: string
  }

  export type ServiceSubFormUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    options?: ServiceSubFormUpdateoptionsInput | Enumerable<string>
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileLink?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableStringFieldUpdateOperationsInput | string | null
    dependentField?: NullableStringFieldUpdateOperationsInput | string | null
    dependentOptions?: ServiceSubFormUpdatedependentOptionsInput | Enumerable<string>
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    allowOther?: BoolFieldUpdateOperationsInput | boolean
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    form?: ServiceFormUpdateOneRequiredWithoutSubFormNestedInput
  }

  export type ServiceSubFormUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    options?: ServiceSubFormUpdateoptionsInput | Enumerable<string>
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileLink?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableStringFieldUpdateOperationsInput | string | null
    dependentField?: NullableStringFieldUpdateOperationsInput | string | null
    dependentOptions?: ServiceSubFormUpdatedependentOptionsInput | Enumerable<string>
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    allowOther?: BoolFieldUpdateOperationsInput | boolean
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    formId?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceSubFormCreateManyInput = {
    id?: string
    question?: string | null
    type?: string | null
    options?: ServiceSubFormCreateoptionsInput | Enumerable<string>
    fileName?: string | null
    fileType?: string | null
    fileLink?: string | null
    fileSize?: string | null
    dependentField?: string | null
    dependentOptions?: ServiceSubFormCreatedependentOptionsInput | Enumerable<string>
    documentType?: string | null
    allowOther?: boolean
    compulsory?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    formId: string
  }

  export type ServiceSubFormUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    options?: ServiceSubFormUpdateoptionsInput | Enumerable<string>
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileLink?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableStringFieldUpdateOperationsInput | string | null
    dependentField?: NullableStringFieldUpdateOperationsInput | string | null
    dependentOptions?: ServiceSubFormUpdatedependentOptionsInput | Enumerable<string>
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    allowOther?: BoolFieldUpdateOperationsInput | boolean
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ServiceSubFormUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    options?: ServiceSubFormUpdateoptionsInput | Enumerable<string>
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileLink?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableStringFieldUpdateOperationsInput | string | null
    dependentField?: NullableStringFieldUpdateOperationsInput | string | null
    dependentOptions?: ServiceSubFormUpdatedependentOptionsInput | Enumerable<string>
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    allowOther?: BoolFieldUpdateOperationsInput | boolean
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    formId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductCreateInput = {
    id?: string
    name: string
    description: string
    country: string
    currency: string
    amount: number
    timeline: string
    feature?: ProductCreatefeatureInput | Enumerable<string>
    canAlsoDo?: ProductCreatecanAlsoDoInput | Enumerable<string>
    hasShares?: boolean
    hasAgent?: boolean
    hasOwner?: boolean
    hasController?: boolean
    controllerIsCalled?: string | null
    OwnerIsCalled?: string | null
    agentIsCalled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    service: ServiceCreateNestedOneWithoutProductsInput
    request?: ProductRequestCreateNestedManyWithoutProductInput
    form?: ProductFormCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    country: string
    currency: string
    amount: number
    timeline: string
    feature?: ProductCreatefeatureInput | Enumerable<string>
    canAlsoDo?: ProductCreatecanAlsoDoInput | Enumerable<string>
    hasShares?: boolean
    hasAgent?: boolean
    hasOwner?: boolean
    hasController?: boolean
    controllerIsCalled?: string | null
    OwnerIsCalled?: string | null
    agentIsCalled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    serviceId: string
    request?: ProductRequestUncheckedCreateNestedManyWithoutProductInput
    form?: ProductFormUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    timeline?: StringFieldUpdateOperationsInput | string
    feature?: ProductUpdatefeatureInput | Enumerable<string>
    canAlsoDo?: ProductUpdatecanAlsoDoInput | Enumerable<string>
    hasShares?: BoolFieldUpdateOperationsInput | boolean
    hasAgent?: BoolFieldUpdateOperationsInput | boolean
    hasOwner?: BoolFieldUpdateOperationsInput | boolean
    hasController?: BoolFieldUpdateOperationsInput | boolean
    controllerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    agentIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    service?: ServiceUpdateOneRequiredWithoutProductsNestedInput
    request?: ProductRequestUpdateManyWithoutProductNestedInput
    form?: ProductFormUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    timeline?: StringFieldUpdateOperationsInput | string
    feature?: ProductUpdatefeatureInput | Enumerable<string>
    canAlsoDo?: ProductUpdatecanAlsoDoInput | Enumerable<string>
    hasShares?: BoolFieldUpdateOperationsInput | boolean
    hasAgent?: BoolFieldUpdateOperationsInput | boolean
    hasOwner?: BoolFieldUpdateOperationsInput | boolean
    hasController?: BoolFieldUpdateOperationsInput | boolean
    controllerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    agentIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    serviceId?: StringFieldUpdateOperationsInput | string
    request?: ProductRequestUncheckedUpdateManyWithoutProductNestedInput
    form?: ProductFormUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    name: string
    description: string
    country: string
    currency: string
    amount: number
    timeline: string
    feature?: ProductCreatefeatureInput | Enumerable<string>
    canAlsoDo?: ProductCreatecanAlsoDoInput | Enumerable<string>
    hasShares?: boolean
    hasAgent?: boolean
    hasOwner?: boolean
    hasController?: boolean
    controllerIsCalled?: string | null
    OwnerIsCalled?: string | null
    agentIsCalled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    serviceId: string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    timeline?: StringFieldUpdateOperationsInput | string
    feature?: ProductUpdatefeatureInput | Enumerable<string>
    canAlsoDo?: ProductUpdatecanAlsoDoInput | Enumerable<string>
    hasShares?: BoolFieldUpdateOperationsInput | boolean
    hasAgent?: BoolFieldUpdateOperationsInput | boolean
    hasOwner?: BoolFieldUpdateOperationsInput | boolean
    hasController?: BoolFieldUpdateOperationsInput | boolean
    controllerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    agentIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    timeline?: StringFieldUpdateOperationsInput | string
    feature?: ProductUpdatefeatureInput | Enumerable<string>
    canAlsoDo?: ProductUpdatecanAlsoDoInput | Enumerable<string>
    hasShares?: BoolFieldUpdateOperationsInput | boolean
    hasAgent?: BoolFieldUpdateOperationsInput | boolean
    hasOwner?: BoolFieldUpdateOperationsInput | boolean
    hasController?: BoolFieldUpdateOperationsInput | boolean
    controllerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    agentIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductFormCreateInput = {
    id?: string
    title?: string | null
    type?: string | null
    description?: string | null
    compulsory?: boolean
    createdAt?: Date | string
    isDeprecated?: boolean
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutFormInput
    productSubForm?: ProductSubFormCreateNestedManyWithoutFormInput
  }

  export type ProductFormUncheckedCreateInput = {
    id?: string
    title?: string | null
    type?: string | null
    description?: string | null
    compulsory?: boolean
    createdAt?: Date | string
    isDeprecated?: boolean
    updatedAt?: Date | string
    productId: string
    productSubForm?: ProductSubFormUncheckedCreateNestedManyWithoutFormInput
  }

  export type ProductFormUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutFormNestedInput
    productSubForm?: ProductSubFormUpdateManyWithoutFormNestedInput
  }

  export type ProductFormUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: StringFieldUpdateOperationsInput | string
    productSubForm?: ProductSubFormUncheckedUpdateManyWithoutFormNestedInput
  }

  export type ProductFormCreateManyInput = {
    id?: string
    title?: string | null
    type?: string | null
    description?: string | null
    compulsory?: boolean
    createdAt?: Date | string
    isDeprecated?: boolean
    updatedAt?: Date | string
    productId: string
  }

  export type ProductFormUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductFormUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductSubFormCreateInput = {
    id?: string
    question?: string | null
    options?: ProductSubFormCreateoptionsInput | Enumerable<string>
    type?: string | null
    allowOther?: boolean
    dependentField?: string | null
    dependentOptions?: ProductSubFormCreatedependentOptionsInput | Enumerable<string>
    fileName?: string | null
    fileType?: string | null
    fileLink?: string | null
    fileSize?: string | null
    documentType?: string | null
    compulsory?: boolean
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    form: ProductFormCreateNestedOneWithoutProductSubFormInput
  }

  export type ProductSubFormUncheckedCreateInput = {
    id?: string
    question?: string | null
    options?: ProductSubFormCreateoptionsInput | Enumerable<string>
    type?: string | null
    allowOther?: boolean
    dependentField?: string | null
    dependentOptions?: ProductSubFormCreatedependentOptionsInput | Enumerable<string>
    fileName?: string | null
    fileType?: string | null
    fileLink?: string | null
    fileSize?: string | null
    documentType?: string | null
    compulsory?: boolean
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    formId: string
  }

  export type ProductSubFormUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: NullableStringFieldUpdateOperationsInput | string | null
    options?: ProductSubFormUpdateoptionsInput | Enumerable<string>
    type?: NullableStringFieldUpdateOperationsInput | string | null
    allowOther?: BoolFieldUpdateOperationsInput | boolean
    dependentField?: NullableStringFieldUpdateOperationsInput | string | null
    dependentOptions?: ProductSubFormUpdatedependentOptionsInput | Enumerable<string>
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileLink?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: ProductFormUpdateOneRequiredWithoutProductSubFormNestedInput
  }

  export type ProductSubFormUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: NullableStringFieldUpdateOperationsInput | string | null
    options?: ProductSubFormUpdateoptionsInput | Enumerable<string>
    type?: NullableStringFieldUpdateOperationsInput | string | null
    allowOther?: BoolFieldUpdateOperationsInput | boolean
    dependentField?: NullableStringFieldUpdateOperationsInput | string | null
    dependentOptions?: ProductSubFormUpdatedependentOptionsInput | Enumerable<string>
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileLink?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductSubFormCreateManyInput = {
    id?: string
    question?: string | null
    options?: ProductSubFormCreateoptionsInput | Enumerable<string>
    type?: string | null
    allowOther?: boolean
    dependentField?: string | null
    dependentOptions?: ProductSubFormCreatedependentOptionsInput | Enumerable<string>
    fileName?: string | null
    fileType?: string | null
    fileLink?: string | null
    fileSize?: string | null
    documentType?: string | null
    compulsory?: boolean
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    formId: string
  }

  export type ProductSubFormUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: NullableStringFieldUpdateOperationsInput | string | null
    options?: ProductSubFormUpdateoptionsInput | Enumerable<string>
    type?: NullableStringFieldUpdateOperationsInput | string | null
    allowOther?: BoolFieldUpdateOperationsInput | boolean
    dependentField?: NullableStringFieldUpdateOperationsInput | string | null
    dependentOptions?: ProductSubFormUpdatedependentOptionsInput | Enumerable<string>
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileLink?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductSubFormUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: NullableStringFieldUpdateOperationsInput | string | null
    options?: ProductSubFormUpdateoptionsInput | Enumerable<string>
    type?: NullableStringFieldUpdateOperationsInput | string | null
    allowOther?: BoolFieldUpdateOperationsInput | boolean
    dependentField?: NullableStringFieldUpdateOperationsInput | string | null
    dependentOptions?: ProductSubFormUpdatedependentOptionsInput | Enumerable<string>
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileLink?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductRequestCreateInput = {
    id?: string
    email?: string | null
    address?: string | null
    paid?: boolean
    completed?: boolean
    status?: string
    currentState?: ProductActivityStage
    createdAt?: Date | string
    isDeprecated?: boolean
    updatedAt?: Date | string
    Team?: TeamCreateNestedManyWithoutProductRequestInput
    product?: ProductCreateNestedOneWithoutRequestInput
    user: UserCreateNestedOneWithoutProductRequestInput
    Payment?: PaymentCreateNestedManyWithoutProductRequestsInput
    requestQA?: ProductRequestQACreateNestedManyWithoutRequestInput
  }

  export type ProductRequestUncheckedCreateInput = {
    id?: string
    email?: string | null
    address?: string | null
    paid?: boolean
    completed?: boolean
    status?: string
    currentState?: ProductActivityStage
    createdAt?: Date | string
    isDeprecated?: boolean
    updatedAt?: Date | string
    productId?: string | null
    userId: string
    Team?: TeamUncheckedCreateNestedManyWithoutProductRequestInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutProductRequestsInput
    requestQA?: ProductRequestQAUncheckedCreateNestedManyWithoutRequestInput
  }

  export type ProductRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    currentState?: EnumProductActivityStageFieldUpdateOperationsInput | ProductActivityStage
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Team?: TeamUpdateManyWithoutProductRequestNestedInput
    product?: ProductUpdateOneWithoutRequestNestedInput
    user?: UserUpdateOneRequiredWithoutProductRequestNestedInput
    Payment?: PaymentUpdateManyWithoutProductRequestsNestedInput
    requestQA?: ProductRequestQAUpdateManyWithoutRequestNestedInput
  }

  export type ProductRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    currentState?: EnumProductActivityStageFieldUpdateOperationsInput | ProductActivityStage
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    Team?: TeamUncheckedUpdateManyWithoutProductRequestNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutProductRequestsNestedInput
    requestQA?: ProductRequestQAUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type ProductRequestCreateManyInput = {
    id?: string
    email?: string | null
    address?: string | null
    paid?: boolean
    completed?: boolean
    status?: string
    currentState?: ProductActivityStage
    createdAt?: Date | string
    isDeprecated?: boolean
    updatedAt?: Date | string
    productId?: string | null
    userId: string
  }

  export type ProductRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    currentState?: EnumProductActivityStageFieldUpdateOperationsInput | ProductActivityStage
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    currentState?: EnumProductActivityStageFieldUpdateOperationsInput | ProductActivityStage
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductRequestQACreateInput = {
    id?: string
    title?: string | null
    description?: string | null
    type?: string | null
    compulsory?: boolean
    isGeneral?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    request: ProductRequestCreateNestedOneWithoutRequestQAInput
    subForm?: ProductRequestQASubFormCreateNestedManyWithoutRequestQAInput
  }

  export type ProductRequestQAUncheckedCreateInput = {
    id?: string
    title?: string | null
    description?: string | null
    type?: string | null
    compulsory?: boolean
    isGeneral?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    requestId: string
    subForm?: ProductRequestQASubFormUncheckedCreateNestedManyWithoutRequestQAInput
  }

  export type ProductRequestQAUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    isGeneral?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    request?: ProductRequestUpdateOneRequiredWithoutRequestQANestedInput
    subForm?: ProductRequestQASubFormUpdateManyWithoutRequestQANestedInput
  }

  export type ProductRequestQAUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    isGeneral?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    requestId?: StringFieldUpdateOperationsInput | string
    subForm?: ProductRequestQASubFormUncheckedUpdateManyWithoutRequestQANestedInput
  }

  export type ProductRequestQACreateManyInput = {
    id?: string
    title?: string | null
    description?: string | null
    type?: string | null
    compulsory?: boolean
    isGeneral?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    requestId: string
  }

  export type ProductRequestQAUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    isGeneral?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductRequestQAUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    isGeneral?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    requestId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductRequestQASubFormCreateInput = {
    id?: string
    question?: string | null
    answer?: ProductRequestQASubFormCreateanswerInput | Enumerable<string>
    type?: string | null
    fileName?: string | null
    fileType?: string | null
    fileLink?: string | null
    fileSize?: string | null
    compulsory?: boolean
    isDeprecated?: boolean
    requestQA: ProductRequestQACreateNestedOneWithoutSubFormInput
  }

  export type ProductRequestQASubFormUncheckedCreateInput = {
    id?: string
    question?: string | null
    answer?: ProductRequestQASubFormCreateanswerInput | Enumerable<string>
    type?: string | null
    fileName?: string | null
    fileType?: string | null
    fileLink?: string | null
    fileSize?: string | null
    compulsory?: boolean
    isDeprecated?: boolean
    requestQAId: string
  }

  export type ProductRequestQASubFormUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: NullableStringFieldUpdateOperationsInput | string | null
    answer?: ProductRequestQASubFormUpdateanswerInput | Enumerable<string>
    type?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileLink?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableStringFieldUpdateOperationsInput | string | null
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    requestQA?: ProductRequestQAUpdateOneRequiredWithoutSubFormNestedInput
  }

  export type ProductRequestQASubFormUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: NullableStringFieldUpdateOperationsInput | string | null
    answer?: ProductRequestQASubFormUpdateanswerInput | Enumerable<string>
    type?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileLink?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableStringFieldUpdateOperationsInput | string | null
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    requestQAId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductRequestQASubFormCreateManyInput = {
    id?: string
    question?: string | null
    answer?: ProductRequestQASubFormCreateanswerInput | Enumerable<string>
    type?: string | null
    fileName?: string | null
    fileType?: string | null
    fileLink?: string | null
    fileSize?: string | null
    compulsory?: boolean
    isDeprecated?: boolean
    requestQAId: string
  }

  export type ProductRequestQASubFormUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: NullableStringFieldUpdateOperationsInput | string | null
    answer?: ProductRequestQASubFormUpdateanswerInput | Enumerable<string>
    type?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileLink?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableStringFieldUpdateOperationsInput | string | null
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductRequestQASubFormUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: NullableStringFieldUpdateOperationsInput | string | null
    answer?: ProductRequestQASubFormUpdateanswerInput | Enumerable<string>
    type?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileLink?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableStringFieldUpdateOperationsInput | string | null
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    requestQAId?: StringFieldUpdateOperationsInput | string
  }

  export type ClaimCreateInput = {
    id?: string
    value: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
  }

  export type ClaimUncheckedCreateInput = {
    id?: string
    value: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
  }

  export type ClaimUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClaimUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClaimCreateManyInput = {
    id?: string
    value: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
  }

  export type ClaimUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClaimUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TeamCreateInput = {
    id?: string
    name: string
    slug: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    productRequest: ProductRequestCreateNestedOneWithoutTeamInput
    invitation?: InvitationCreateNestedManyWithoutTeamInput
    teamMember?: TeamMemberCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    productRequestId: string
    invitation?: InvitationUncheckedCreateNestedManyWithoutTeamInput
    teamMember?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    productRequest?: ProductRequestUpdateOneRequiredWithoutTeamNestedInput
    invitation?: InvitationUpdateManyWithoutTeamNestedInput
    teamMember?: TeamMemberUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    productRequestId?: StringFieldUpdateOperationsInput | string
    invitation?: InvitationUncheckedUpdateManyWithoutTeamNestedInput
    teamMember?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamCreateManyInput = {
    id?: string
    name: string
    slug: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    productRequestId: string
  }

  export type TeamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TeamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    productRequestId?: StringFieldUpdateOperationsInput | string
  }

  export type TeamMemberCreateInput = {
    id?: string
    isLaunchMember: boolean
    isLaunchController: boolean
    isLaunchOwner: boolean
    launchOwnership: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    team: TeamCreateNestedOneWithoutTeamMemberInput
    user: UserCreateNestedOneWithoutTeamMemberInput
  }

  export type TeamMemberUncheckedCreateInput = {
    id?: string
    isLaunchMember: boolean
    isLaunchController: boolean
    isLaunchOwner: boolean
    launchOwnership: number
    teamId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
  }

  export type TeamMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isLaunchMember?: BoolFieldUpdateOperationsInput | boolean
    isLaunchController?: BoolFieldUpdateOperationsInput | boolean
    isLaunchOwner?: BoolFieldUpdateOperationsInput | boolean
    launchOwnership?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    team?: TeamUpdateOneRequiredWithoutTeamMemberNestedInput
    user?: UserUpdateOneRequiredWithoutTeamMemberNestedInput
  }

  export type TeamMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isLaunchMember?: BoolFieldUpdateOperationsInput | boolean
    isLaunchController?: BoolFieldUpdateOperationsInput | boolean
    isLaunchOwner?: BoolFieldUpdateOperationsInput | boolean
    launchOwnership?: IntFieldUpdateOperationsInput | number
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TeamMemberCreateManyInput = {
    id?: string
    isLaunchMember: boolean
    isLaunchController: boolean
    isLaunchOwner: boolean
    launchOwnership: number
    teamId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
  }

  export type TeamMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isLaunchMember?: BoolFieldUpdateOperationsInput | boolean
    isLaunchController?: BoolFieldUpdateOperationsInput | boolean
    isLaunchOwner?: BoolFieldUpdateOperationsInput | boolean
    launchOwnership?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TeamMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isLaunchMember?: BoolFieldUpdateOperationsInput | boolean
    isLaunchController?: BoolFieldUpdateOperationsInput | boolean
    isLaunchOwner?: BoolFieldUpdateOperationsInput | boolean
    launchOwnership?: IntFieldUpdateOperationsInput | number
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvitationCreateInput = {
    id?: string
    email: string
    token: string
    expireIn: Date | string
    invitedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    team: TeamCreateNestedOneWithoutInvitationInput
  }

  export type InvitationUncheckedCreateInput = {
    id?: string
    teamId: string
    email: string
    token: string
    expireIn: Date | string
    invitedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
  }

  export type InvitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expireIn?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    team?: TeamUpdateOneRequiredWithoutInvitationNestedInput
  }

  export type InvitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expireIn?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvitationCreateManyInput = {
    id?: string
    teamId: string
    email: string
    token: string
    expireIn: Date | string
    invitedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
  }

  export type InvitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expireIn?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expireIn?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PaymentCreateInput = {
    id?: string
    provider: string
    transactionId: string
    status: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    productRequests: ProductRequestCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    provider: string
    transactionId: string
    status: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    productRequestId: string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    productRequests?: ProductRequestUpdateOneRequiredWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    productRequestId?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    provider: string
    transactionId: string
    status: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    productRequestId: string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    productRequestId?: StringFieldUpdateOperationsInput | string
  }

  export type ParterCreateInput = {
    id?: string
    isVerified: boolean
    verificationDocument?: ParterCreateverificationDocumentInput | Enumerable<string>
    serviceScore: number
    paymentsMade: number
    paymentsDue: number
    paymentDetails?: ParterCreatepaymentDetailsInput | Enumerable<string>
    countrySupported?: ParterCreatecountrySupportedInput | Enumerable<string>
    serviceSupported?: ParterCreateserviceSupportedInput | Enumerable<string>
    servicesAssigned?: ParterCreateservicesAssignedInput | Enumerable<string>
    servicesCompleted?: ParterCreateservicesCompletedInput | Enumerable<string>
    servicesDeclined?: ParterCreateservicesDeclinedInput | Enumerable<string>
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
  }

  export type ParterUncheckedCreateInput = {
    id?: string
    isVerified: boolean
    verificationDocument?: ParterCreateverificationDocumentInput | Enumerable<string>
    serviceScore: number
    paymentsMade: number
    paymentsDue: number
    paymentDetails?: ParterCreatepaymentDetailsInput | Enumerable<string>
    countrySupported?: ParterCreatecountrySupportedInput | Enumerable<string>
    serviceSupported?: ParterCreateserviceSupportedInput | Enumerable<string>
    servicesAssigned?: ParterCreateservicesAssignedInput | Enumerable<string>
    servicesCompleted?: ParterCreateservicesCompletedInput | Enumerable<string>
    servicesDeclined?: ParterCreateservicesDeclinedInput | Enumerable<string>
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
  }

  export type ParterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationDocument?: ParterUpdateverificationDocumentInput | Enumerable<string>
    serviceScore?: IntFieldUpdateOperationsInput | number
    paymentsMade?: IntFieldUpdateOperationsInput | number
    paymentsDue?: IntFieldUpdateOperationsInput | number
    paymentDetails?: ParterUpdatepaymentDetailsInput | Enumerable<string>
    countrySupported?: ParterUpdatecountrySupportedInput | Enumerable<string>
    serviceSupported?: ParterUpdateserviceSupportedInput | Enumerable<string>
    servicesAssigned?: ParterUpdateservicesAssignedInput | Enumerable<string>
    servicesCompleted?: ParterUpdateservicesCompletedInput | Enumerable<string>
    servicesDeclined?: ParterUpdateservicesDeclinedInput | Enumerable<string>
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ParterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationDocument?: ParterUpdateverificationDocumentInput | Enumerable<string>
    serviceScore?: IntFieldUpdateOperationsInput | number
    paymentsMade?: IntFieldUpdateOperationsInput | number
    paymentsDue?: IntFieldUpdateOperationsInput | number
    paymentDetails?: ParterUpdatepaymentDetailsInput | Enumerable<string>
    countrySupported?: ParterUpdatecountrySupportedInput | Enumerable<string>
    serviceSupported?: ParterUpdateserviceSupportedInput | Enumerable<string>
    servicesAssigned?: ParterUpdateservicesAssignedInput | Enumerable<string>
    servicesCompleted?: ParterUpdateservicesCompletedInput | Enumerable<string>
    servicesDeclined?: ParterUpdateservicesDeclinedInput | Enumerable<string>
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ParterCreateManyInput = {
    id?: string
    isVerified: boolean
    verificationDocument?: ParterCreateverificationDocumentInput | Enumerable<string>
    serviceScore: number
    paymentsMade: number
    paymentsDue: number
    paymentDetails?: ParterCreatepaymentDetailsInput | Enumerable<string>
    countrySupported?: ParterCreatecountrySupportedInput | Enumerable<string>
    serviceSupported?: ParterCreateserviceSupportedInput | Enumerable<string>
    servicesAssigned?: ParterCreateservicesAssignedInput | Enumerable<string>
    servicesCompleted?: ParterCreateservicesCompletedInput | Enumerable<string>
    servicesDeclined?: ParterCreateservicesDeclinedInput | Enumerable<string>
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
  }

  export type ParterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationDocument?: ParterUpdateverificationDocumentInput | Enumerable<string>
    serviceScore?: IntFieldUpdateOperationsInput | number
    paymentsMade?: IntFieldUpdateOperationsInput | number
    paymentsDue?: IntFieldUpdateOperationsInput | number
    paymentDetails?: ParterUpdatepaymentDetailsInput | Enumerable<string>
    countrySupported?: ParterUpdatecountrySupportedInput | Enumerable<string>
    serviceSupported?: ParterUpdateserviceSupportedInput | Enumerable<string>
    servicesAssigned?: ParterUpdateservicesAssignedInput | Enumerable<string>
    servicesCompleted?: ParterUpdateservicesCompletedInput | Enumerable<string>
    servicesDeclined?: ParterUpdateservicesDeclinedInput | Enumerable<string>
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ParterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationDocument?: ParterUpdateverificationDocumentInput | Enumerable<string>
    serviceScore?: IntFieldUpdateOperationsInput | number
    paymentsMade?: IntFieldUpdateOperationsInput | number
    paymentsDue?: IntFieldUpdateOperationsInput | number
    paymentDetails?: ParterUpdatepaymentDetailsInput | Enumerable<string>
    countrySupported?: ParterUpdatecountrySupportedInput | Enumerable<string>
    serviceSupported?: ParterUpdateserviceSupportedInput | Enumerable<string>
    servicesAssigned?: ParterUpdateservicesAssignedInput | Enumerable<string>
    servicesCompleted?: ParterUpdateservicesCompletedInput | Enumerable<string>
    servicesDeclined?: ParterUpdateservicesDeclinedInput | Enumerable<string>
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type StaffCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    verified?: SortOrder
    picture?: SortOrder
    resetToken?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    verified?: SortOrder
    picture?: SortOrder
    resetToken?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    verified?: SortOrder
    picture?: SortOrder
    resetToken?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type CollaboratorDocumentListRelationFilter = {
    every?: CollaboratorDocumentWhereInput
    some?: CollaboratorDocumentWhereInput
    none?: CollaboratorDocumentWhereInput
  }

  export type CollaboratorDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CollaboratorCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    picture?: SortOrder
    verified?: SortOrder
    isPartner?: SortOrder
    resetToken?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CollaboratorMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    picture?: SortOrder
    verified?: SortOrder
    isPartner?: SortOrder
    resetToken?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CollaboratorMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    picture?: SortOrder
    verified?: SortOrder
    isPartner?: SortOrder
    resetToken?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CollaboratorRelationFilter = {
    is?: CollaboratorWhereInput | null
    isNot?: CollaboratorWhereInput | null
  }

  export type CollaboratorDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    collaboratorId?: SortOrder
  }

  export type CollaboratorDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    collaboratorId?: SortOrder
  }

  export type CollaboratorDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    collaboratorId?: SortOrder
  }

  export type RewardCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    descrition?: SortOrder
    image?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RewardMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    descrition?: SortOrder
    image?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RewardMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    descrition?: SortOrder
    image?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CountryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    iso?: SortOrder
    currency?: SortOrder
    code?: SortOrder
    flagUrl?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CountryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    iso?: SortOrder
    currency?: SortOrder
    code?: SortOrder
    flagUrl?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CountryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    iso?: SortOrder
    currency?: SortOrder
    code?: SortOrder
    flagUrl?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    url?: SortOrder
    image?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    url?: SortOrder
    image?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    url?: SortOrder
    image?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    body?: SortOrder
    readStatus?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    body?: SortOrder
    readStatus?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    body?: SortOrder
    readStatus?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    scope?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    scope?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    scope?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableListFilter = {
    equals?: Enumerable<string> | null
    has?: string | null
    hasEvery?: Enumerable<string>
    hasSome?: Enumerable<string>
    isEmpty?: boolean
  }

  export type TeamMemberListRelationFilter = {
    every?: TeamMemberWhereInput
    some?: TeamMemberWhereInput
    none?: TeamMemberWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type ProductRequestListRelationFilter = {
    every?: ProductRequestWhereInput
    some?: ProductRequestWhereInput
    none?: ProductRequestWhereInput
  }

  export type UserDocumentListRelationFilter = {
    every?: UserDocumentWhereInput
    some?: UserDocumentWhereInput
    none?: UserDocumentWhereInput
  }

  export type TeamMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    googleId?: SortOrder
    phone?: SortOrder
    picture?: SortOrder
    isVerified?: SortOrder
    referral?: SortOrder
    country?: SortOrder
    resetToken?: SortOrder
    isPartner?: SortOrder
    isStaff?: SortOrder
    isPhoneRegistered?: SortOrder
    isPhoneVerified?: SortOrder
    isIdentificationRegistered?: SortOrder
    isIdentificationVerified?: SortOrder
    partnerPermission?: SortOrder
    staffPermission?: SortOrder
    userPermission?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    googleId?: SortOrder
    phone?: SortOrder
    picture?: SortOrder
    isVerified?: SortOrder
    referral?: SortOrder
    country?: SortOrder
    resetToken?: SortOrder
    isPartner?: SortOrder
    isStaff?: SortOrder
    isPhoneRegistered?: SortOrder
    isPhoneVerified?: SortOrder
    isIdentificationRegistered?: SortOrder
    isIdentificationVerified?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    googleId?: SortOrder
    phone?: SortOrder
    picture?: SortOrder
    isVerified?: SortOrder
    referral?: SortOrder
    country?: SortOrder
    resetToken?: SortOrder
    isPartner?: SortOrder
    isStaff?: SortOrder
    isPhoneRegistered?: SortOrder
    isPhoneVerified?: SortOrder
    isIdentificationRegistered?: SortOrder
    isIdentificationVerified?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    link?: SortOrder
    size?: SortOrder
    belongsTo?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type UserDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    link?: SortOrder
    size?: SortOrder
    belongsTo?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type UserDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    link?: SortOrder
    size?: SortOrder
    belongsTo?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type ServiceFormListRelationFilter = {
    every?: ServiceFormWhereInput
    some?: ServiceFormWhereInput
    none?: ServiceFormWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceFormOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceRelationFilter = {
    is?: ServiceWhereInput | null
    isNot?: ServiceWhereInput | null
  }

  export type ServiceSubFormListRelationFilter = {
    every?: ServiceSubFormWhereInput
    some?: ServiceSubFormWhereInput
    none?: ServiceSubFormWhereInput
  }

  export type ServiceSubFormOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceFormCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    compulsory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
    serviceId?: SortOrder
  }

  export type ServiceFormMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    compulsory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
    serviceId?: SortOrder
  }

  export type ServiceFormMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    compulsory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
    serviceId?: SortOrder
  }

  export type ServiceFormRelationFilter = {
    is?: ServiceFormWhereInput | null
    isNot?: ServiceFormWhereInput | null
  }

  export type ServiceSubFormCountOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    type?: SortOrder
    options?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    fileLink?: SortOrder
    fileSize?: SortOrder
    dependentField?: SortOrder
    dependentOptions?: SortOrder
    documentType?: SortOrder
    allowOther?: SortOrder
    compulsory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
    formId?: SortOrder
  }

  export type ServiceSubFormMaxOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    type?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    fileLink?: SortOrder
    fileSize?: SortOrder
    dependentField?: SortOrder
    documentType?: SortOrder
    allowOther?: SortOrder
    compulsory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
    formId?: SortOrder
  }

  export type ServiceSubFormMinOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    type?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    fileLink?: SortOrder
    fileSize?: SortOrder
    dependentField?: SortOrder
    documentType?: SortOrder
    allowOther?: SortOrder
    compulsory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
    formId?: SortOrder
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type ProductFormListRelationFilter = {
    every?: ProductFormWhereInput
    some?: ProductFormWhereInput
    none?: ProductFormWhereInput
  }

  export type ProductFormOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    country?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    timeline?: SortOrder
    feature?: SortOrder
    canAlsoDo?: SortOrder
    hasShares?: SortOrder
    hasAgent?: SortOrder
    hasOwner?: SortOrder
    hasController?: SortOrder
    controllerIsCalled?: SortOrder
    OwnerIsCalled?: SortOrder
    agentIsCalled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
    serviceId?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    country?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    timeline?: SortOrder
    hasShares?: SortOrder
    hasAgent?: SortOrder
    hasOwner?: SortOrder
    hasController?: SortOrder
    controllerIsCalled?: SortOrder
    OwnerIsCalled?: SortOrder
    agentIsCalled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
    serviceId?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    country?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    timeline?: SortOrder
    hasShares?: SortOrder
    hasAgent?: SortOrder
    hasOwner?: SortOrder
    hasController?: SortOrder
    controllerIsCalled?: SortOrder
    OwnerIsCalled?: SortOrder
    agentIsCalled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
    serviceId?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type ProductRelationFilter = {
    is?: ProductWhereInput | null
    isNot?: ProductWhereInput | null
  }

  export type ProductSubFormListRelationFilter = {
    every?: ProductSubFormWhereInput
    some?: ProductSubFormWhereInput
    none?: ProductSubFormWhereInput
  }

  export type ProductSubFormOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductFormCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    description?: SortOrder
    compulsory?: SortOrder
    createdAt?: SortOrder
    isDeprecated?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type ProductFormMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    description?: SortOrder
    compulsory?: SortOrder
    createdAt?: SortOrder
    isDeprecated?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type ProductFormMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    description?: SortOrder
    compulsory?: SortOrder
    createdAt?: SortOrder
    isDeprecated?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type ProductFormRelationFilter = {
    is?: ProductFormWhereInput | null
    isNot?: ProductFormWhereInput | null
  }

  export type ProductSubFormCountOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    options?: SortOrder
    type?: SortOrder
    allowOther?: SortOrder
    dependentField?: SortOrder
    dependentOptions?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    fileLink?: SortOrder
    fileSize?: SortOrder
    documentType?: SortOrder
    compulsory?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    formId?: SortOrder
  }

  export type ProductSubFormMaxOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    type?: SortOrder
    allowOther?: SortOrder
    dependentField?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    fileLink?: SortOrder
    fileSize?: SortOrder
    documentType?: SortOrder
    compulsory?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    formId?: SortOrder
  }

  export type ProductSubFormMinOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    type?: SortOrder
    allowOther?: SortOrder
    dependentField?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    fileLink?: SortOrder
    fileSize?: SortOrder
    documentType?: SortOrder
    compulsory?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    formId?: SortOrder
  }

  export type EnumProductActivityStageFilter = {
    equals?: ProductActivityStage
    in?: Enumerable<ProductActivityStage>
    notIn?: Enumerable<ProductActivityStage>
    not?: NestedEnumProductActivityStageFilter | ProductActivityStage
  }

  export type TeamListRelationFilter = {
    every?: TeamWhereInput
    some?: TeamWhereInput
    none?: TeamWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type ProductRequestQAListRelationFilter = {
    every?: ProductRequestQAWhereInput
    some?: ProductRequestQAWhereInput
    none?: ProductRequestQAWhereInput
  }

  export type TeamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductRequestQAOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductRequestCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    address?: SortOrder
    paid?: SortOrder
    completed?: SortOrder
    status?: SortOrder
    currentState?: SortOrder
    createdAt?: SortOrder
    isDeprecated?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
  }

  export type ProductRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    address?: SortOrder
    paid?: SortOrder
    completed?: SortOrder
    status?: SortOrder
    currentState?: SortOrder
    createdAt?: SortOrder
    isDeprecated?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
  }

  export type ProductRequestMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    address?: SortOrder
    paid?: SortOrder
    completed?: SortOrder
    status?: SortOrder
    currentState?: SortOrder
    createdAt?: SortOrder
    isDeprecated?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
  }

  export type EnumProductActivityStageWithAggregatesFilter = {
    equals?: ProductActivityStage
    in?: Enumerable<ProductActivityStage>
    notIn?: Enumerable<ProductActivityStage>
    not?: NestedEnumProductActivityStageWithAggregatesFilter | ProductActivityStage
    _count?: NestedIntFilter
    _min?: NestedEnumProductActivityStageFilter
    _max?: NestedEnumProductActivityStageFilter
  }

  export type ProductRequestRelationFilter = {
    is?: ProductRequestWhereInput | null
    isNot?: ProductRequestWhereInput | null
  }

  export type ProductRequestQASubFormListRelationFilter = {
    every?: ProductRequestQASubFormWhereInput
    some?: ProductRequestQASubFormWhereInput
    none?: ProductRequestQASubFormWhereInput
  }

  export type ProductRequestQASubFormOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductRequestQACountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    compulsory?: SortOrder
    isGeneral?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
    requestId?: SortOrder
  }

  export type ProductRequestQAMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    compulsory?: SortOrder
    isGeneral?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
    requestId?: SortOrder
  }

  export type ProductRequestQAMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    compulsory?: SortOrder
    isGeneral?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
    requestId?: SortOrder
  }

  export type ProductRequestQARelationFilter = {
    is?: ProductRequestQAWhereInput | null
    isNot?: ProductRequestQAWhereInput | null
  }

  export type ProductRequestQASubFormCountOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    type?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    fileLink?: SortOrder
    fileSize?: SortOrder
    compulsory?: SortOrder
    isDeprecated?: SortOrder
    requestQAId?: SortOrder
  }

  export type ProductRequestQASubFormMaxOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    type?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    fileLink?: SortOrder
    fileSize?: SortOrder
    compulsory?: SortOrder
    isDeprecated?: SortOrder
    requestQAId?: SortOrder
  }

  export type ProductRequestQASubFormMinOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    type?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    fileLink?: SortOrder
    fileSize?: SortOrder
    compulsory?: SortOrder
    isDeprecated?: SortOrder
    requestQAId?: SortOrder
  }

  export type ClaimCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
  }

  export type ClaimMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
  }

  export type ClaimMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
  }

  export type InvitationListRelationFilter = {
    every?: InvitationWhereInput
    some?: InvitationWhereInput
    none?: InvitationWhereInput
  }

  export type InvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
    productRequestId?: SortOrder
  }

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
    productRequestId?: SortOrder
  }

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
    productRequestId?: SortOrder
  }

  export type TeamRelationFilter = {
    is?: TeamWhereInput | null
    isNot?: TeamWhereInput | null
  }

  export type TeamMemberCountOrderByAggregateInput = {
    id?: SortOrder
    isLaunchMember?: SortOrder
    isLaunchController?: SortOrder
    isLaunchOwner?: SortOrder
    launchOwnership?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
  }

  export type TeamMemberAvgOrderByAggregateInput = {
    launchOwnership?: SortOrder
  }

  export type TeamMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    isLaunchMember?: SortOrder
    isLaunchController?: SortOrder
    isLaunchOwner?: SortOrder
    launchOwnership?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
  }

  export type TeamMemberMinOrderByAggregateInput = {
    id?: SortOrder
    isLaunchMember?: SortOrder
    isLaunchController?: SortOrder
    isLaunchOwner?: SortOrder
    launchOwnership?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
  }

  export type TeamMemberSumOrderByAggregateInput = {
    launchOwnership?: SortOrder
  }

  export type InvitationCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expireIn?: SortOrder
    invitedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
  }

  export type InvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expireIn?: SortOrder
    invitedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
  }

  export type InvitationMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expireIn?: SortOrder
    invitedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
    productRequestId?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
    productRequestId?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
    productRequestId?: SortOrder
  }

  export type ParterCountOrderByAggregateInput = {
    id?: SortOrder
    isVerified?: SortOrder
    verificationDocument?: SortOrder
    serviceScore?: SortOrder
    paymentsMade?: SortOrder
    paymentsDue?: SortOrder
    paymentDetails?: SortOrder
    countrySupported?: SortOrder
    serviceSupported?: SortOrder
    servicesAssigned?: SortOrder
    servicesCompleted?: SortOrder
    servicesDeclined?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
  }

  export type ParterAvgOrderByAggregateInput = {
    serviceScore?: SortOrder
    paymentsMade?: SortOrder
    paymentsDue?: SortOrder
  }

  export type ParterMaxOrderByAggregateInput = {
    id?: SortOrder
    isVerified?: SortOrder
    serviceScore?: SortOrder
    paymentsMade?: SortOrder
    paymentsDue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
  }

  export type ParterMinOrderByAggregateInput = {
    id?: SortOrder
    isVerified?: SortOrder
    serviceScore?: SortOrder
    paymentsMade?: SortOrder
    paymentsDue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeprecated?: SortOrder
  }

  export type ParterSumOrderByAggregateInput = {
    serviceScore?: SortOrder
    paymentsMade?: SortOrder
    paymentsDue?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CollaboratorDocumentCreateNestedManyWithoutCollaboratorInput = {
    create?: XOR<Enumerable<CollaboratorDocumentCreateWithoutCollaboratorInput>, Enumerable<CollaboratorDocumentUncheckedCreateWithoutCollaboratorInput>>
    connectOrCreate?: Enumerable<CollaboratorDocumentCreateOrConnectWithoutCollaboratorInput>
    createMany?: CollaboratorDocumentCreateManyCollaboratorInputEnvelope
    connect?: Enumerable<CollaboratorDocumentWhereUniqueInput>
  }

  export type CollaboratorDocumentUncheckedCreateNestedManyWithoutCollaboratorInput = {
    create?: XOR<Enumerable<CollaboratorDocumentCreateWithoutCollaboratorInput>, Enumerable<CollaboratorDocumentUncheckedCreateWithoutCollaboratorInput>>
    connectOrCreate?: Enumerable<CollaboratorDocumentCreateOrConnectWithoutCollaboratorInput>
    createMany?: CollaboratorDocumentCreateManyCollaboratorInputEnvelope
    connect?: Enumerable<CollaboratorDocumentWhereUniqueInput>
  }

  export type CollaboratorDocumentUpdateManyWithoutCollaboratorNestedInput = {
    create?: XOR<Enumerable<CollaboratorDocumentCreateWithoutCollaboratorInput>, Enumerable<CollaboratorDocumentUncheckedCreateWithoutCollaboratorInput>>
    connectOrCreate?: Enumerable<CollaboratorDocumentCreateOrConnectWithoutCollaboratorInput>
    upsert?: Enumerable<CollaboratorDocumentUpsertWithWhereUniqueWithoutCollaboratorInput>
    createMany?: CollaboratorDocumentCreateManyCollaboratorInputEnvelope
    set?: Enumerable<CollaboratorDocumentWhereUniqueInput>
    disconnect?: Enumerable<CollaboratorDocumentWhereUniqueInput>
    delete?: Enumerable<CollaboratorDocumentWhereUniqueInput>
    connect?: Enumerable<CollaboratorDocumentWhereUniqueInput>
    update?: Enumerable<CollaboratorDocumentUpdateWithWhereUniqueWithoutCollaboratorInput>
    updateMany?: Enumerable<CollaboratorDocumentUpdateManyWithWhereWithoutCollaboratorInput>
    deleteMany?: Enumerable<CollaboratorDocumentScalarWhereInput>
  }

  export type CollaboratorDocumentUncheckedUpdateManyWithoutCollaboratorNestedInput = {
    create?: XOR<Enumerable<CollaboratorDocumentCreateWithoutCollaboratorInput>, Enumerable<CollaboratorDocumentUncheckedCreateWithoutCollaboratorInput>>
    connectOrCreate?: Enumerable<CollaboratorDocumentCreateOrConnectWithoutCollaboratorInput>
    upsert?: Enumerable<CollaboratorDocumentUpsertWithWhereUniqueWithoutCollaboratorInput>
    createMany?: CollaboratorDocumentCreateManyCollaboratorInputEnvelope
    set?: Enumerable<CollaboratorDocumentWhereUniqueInput>
    disconnect?: Enumerable<CollaboratorDocumentWhereUniqueInput>
    delete?: Enumerable<CollaboratorDocumentWhereUniqueInput>
    connect?: Enumerable<CollaboratorDocumentWhereUniqueInput>
    update?: Enumerable<CollaboratorDocumentUpdateWithWhereUniqueWithoutCollaboratorInput>
    updateMany?: Enumerable<CollaboratorDocumentUpdateManyWithWhereWithoutCollaboratorInput>
    deleteMany?: Enumerable<CollaboratorDocumentScalarWhereInput>
  }

  export type CollaboratorCreateNestedOneWithoutCollaboratorDocumentInput = {
    create?: XOR<CollaboratorCreateWithoutCollaboratorDocumentInput, CollaboratorUncheckedCreateWithoutCollaboratorDocumentInput>
    connectOrCreate?: CollaboratorCreateOrConnectWithoutCollaboratorDocumentInput
    connect?: CollaboratorWhereUniqueInput
  }

  export type CollaboratorUpdateOneRequiredWithoutCollaboratorDocumentNestedInput = {
    create?: XOR<CollaboratorCreateWithoutCollaboratorDocumentInput, CollaboratorUncheckedCreateWithoutCollaboratorDocumentInput>
    connectOrCreate?: CollaboratorCreateOrConnectWithoutCollaboratorDocumentInput
    upsert?: CollaboratorUpsertWithoutCollaboratorDocumentInput
    connect?: CollaboratorWhereUniqueInput
    update?: XOR<CollaboratorUpdateWithoutCollaboratorDocumentInput, CollaboratorUncheckedUpdateWithoutCollaboratorDocumentInput>
  }

  export type UserCreateNestedOneWithoutAccountInput = {
    create?: XOR<UserCreateWithoutAccountInput, UserUncheckedCreateWithoutAccountInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccountNestedInput = {
    create?: XOR<UserCreateWithoutAccountInput, UserUncheckedCreateWithoutAccountInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountInput
    upsert?: UserUpsertWithoutAccountInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAccountInput, UserUncheckedUpdateWithoutAccountInput>
  }

  export type UserCreatepartnerPermissionInput = {
    set: Enumerable<string>
  }

  export type UserCreatestaffPermissionInput = {
    set: Enumerable<string>
  }

  export type UserCreateuserPermissionInput = {
    set: Enumerable<string>
  }

  export type TeamMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TeamMemberCreateWithoutUserInput>, Enumerable<TeamMemberUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TeamMemberCreateOrConnectWithoutUserInput>
    createMany?: TeamMemberCreateManyUserInputEnvelope
    connect?: Enumerable<TeamMemberWhereUniqueInput>
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: Enumerable<AccountWhereUniqueInput>
  }

  export type ProductRequestCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ProductRequestCreateWithoutUserInput>, Enumerable<ProductRequestUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProductRequestCreateOrConnectWithoutUserInput>
    createMany?: ProductRequestCreateManyUserInputEnvelope
    connect?: Enumerable<ProductRequestWhereUniqueInput>
  }

  export type UserDocumentCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserDocumentCreateWithoutUserInput>, Enumerable<UserDocumentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserDocumentCreateOrConnectWithoutUserInput>
    createMany?: UserDocumentCreateManyUserInputEnvelope
    connect?: Enumerable<UserDocumentWhereUniqueInput>
  }

  export type TeamMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TeamMemberCreateWithoutUserInput>, Enumerable<TeamMemberUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TeamMemberCreateOrConnectWithoutUserInput>
    createMany?: TeamMemberCreateManyUserInputEnvelope
    connect?: Enumerable<TeamMemberWhereUniqueInput>
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: Enumerable<AccountWhereUniqueInput>
  }

  export type ProductRequestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ProductRequestCreateWithoutUserInput>, Enumerable<ProductRequestUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProductRequestCreateOrConnectWithoutUserInput>
    createMany?: ProductRequestCreateManyUserInputEnvelope
    connect?: Enumerable<ProductRequestWhereUniqueInput>
  }

  export type UserDocumentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserDocumentCreateWithoutUserInput>, Enumerable<UserDocumentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserDocumentCreateOrConnectWithoutUserInput>
    createMany?: UserDocumentCreateManyUserInputEnvelope
    connect?: Enumerable<UserDocumentWhereUniqueInput>
  }

  export type UserUpdatepartnerPermissionInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type UserUpdatestaffPermissionInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type UserUpdateuserPermissionInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type TeamMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<TeamMemberCreateWithoutUserInput>, Enumerable<TeamMemberUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TeamMemberCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TeamMemberUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TeamMemberCreateManyUserInputEnvelope
    set?: Enumerable<TeamMemberWhereUniqueInput>
    disconnect?: Enumerable<TeamMemberWhereUniqueInput>
    delete?: Enumerable<TeamMemberWhereUniqueInput>
    connect?: Enumerable<TeamMemberWhereUniqueInput>
    update?: Enumerable<TeamMemberUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TeamMemberUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TeamMemberScalarWhereInput>
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AccountUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    set?: Enumerable<AccountWhereUniqueInput>
    disconnect?: Enumerable<AccountWhereUniqueInput>
    delete?: Enumerable<AccountWhereUniqueInput>
    connect?: Enumerable<AccountWhereUniqueInput>
    update?: Enumerable<AccountUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AccountUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AccountScalarWhereInput>
  }

  export type ProductRequestUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ProductRequestCreateWithoutUserInput>, Enumerable<ProductRequestUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProductRequestCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ProductRequestUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ProductRequestCreateManyUserInputEnvelope
    set?: Enumerable<ProductRequestWhereUniqueInput>
    disconnect?: Enumerable<ProductRequestWhereUniqueInput>
    delete?: Enumerable<ProductRequestWhereUniqueInput>
    connect?: Enumerable<ProductRequestWhereUniqueInput>
    update?: Enumerable<ProductRequestUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ProductRequestUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ProductRequestScalarWhereInput>
  }

  export type UserDocumentUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserDocumentCreateWithoutUserInput>, Enumerable<UserDocumentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserDocumentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserDocumentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserDocumentCreateManyUserInputEnvelope
    set?: Enumerable<UserDocumentWhereUniqueInput>
    disconnect?: Enumerable<UserDocumentWhereUniqueInput>
    delete?: Enumerable<UserDocumentWhereUniqueInput>
    connect?: Enumerable<UserDocumentWhereUniqueInput>
    update?: Enumerable<UserDocumentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserDocumentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserDocumentScalarWhereInput>
  }

  export type TeamMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<TeamMemberCreateWithoutUserInput>, Enumerable<TeamMemberUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TeamMemberCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TeamMemberUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TeamMemberCreateManyUserInputEnvelope
    set?: Enumerable<TeamMemberWhereUniqueInput>
    disconnect?: Enumerable<TeamMemberWhereUniqueInput>
    delete?: Enumerable<TeamMemberWhereUniqueInput>
    connect?: Enumerable<TeamMemberWhereUniqueInput>
    update?: Enumerable<TeamMemberUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TeamMemberUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TeamMemberScalarWhereInput>
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AccountUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    set?: Enumerable<AccountWhereUniqueInput>
    disconnect?: Enumerable<AccountWhereUniqueInput>
    delete?: Enumerable<AccountWhereUniqueInput>
    connect?: Enumerable<AccountWhereUniqueInput>
    update?: Enumerable<AccountUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AccountUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AccountScalarWhereInput>
  }

  export type ProductRequestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ProductRequestCreateWithoutUserInput>, Enumerable<ProductRequestUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProductRequestCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ProductRequestUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ProductRequestCreateManyUserInputEnvelope
    set?: Enumerable<ProductRequestWhereUniqueInput>
    disconnect?: Enumerable<ProductRequestWhereUniqueInput>
    delete?: Enumerable<ProductRequestWhereUniqueInput>
    connect?: Enumerable<ProductRequestWhereUniqueInput>
    update?: Enumerable<ProductRequestUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ProductRequestUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ProductRequestScalarWhereInput>
  }

  export type UserDocumentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserDocumentCreateWithoutUserInput>, Enumerable<UserDocumentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserDocumentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserDocumentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserDocumentCreateManyUserInputEnvelope
    set?: Enumerable<UserDocumentWhereUniqueInput>
    disconnect?: Enumerable<UserDocumentWhereUniqueInput>
    delete?: Enumerable<UserDocumentWhereUniqueInput>
    connect?: Enumerable<UserDocumentWhereUniqueInput>
    update?: Enumerable<UserDocumentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserDocumentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserDocumentScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutDocumentInput = {
    create?: XOR<UserCreateWithoutDocumentInput, UserUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDocumentNestedInput = {
    create?: XOR<UserCreateWithoutDocumentInput, UserUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentInput
    upsert?: UserUpsertWithoutDocumentInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutDocumentInput, UserUncheckedUpdateWithoutDocumentInput>
  }

  export type ProductCreateNestedManyWithoutServiceInput = {
    create?: XOR<Enumerable<ProductCreateWithoutServiceInput>, Enumerable<ProductUncheckedCreateWithoutServiceInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutServiceInput>
    createMany?: ProductCreateManyServiceInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type ServiceFormCreateNestedManyWithoutServiceInput = {
    create?: XOR<Enumerable<ServiceFormCreateWithoutServiceInput>, Enumerable<ServiceFormUncheckedCreateWithoutServiceInput>>
    connectOrCreate?: Enumerable<ServiceFormCreateOrConnectWithoutServiceInput>
    createMany?: ServiceFormCreateManyServiceInputEnvelope
    connect?: Enumerable<ServiceFormWhereUniqueInput>
  }

  export type ProductUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<Enumerable<ProductCreateWithoutServiceInput>, Enumerable<ProductUncheckedCreateWithoutServiceInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutServiceInput>
    createMany?: ProductCreateManyServiceInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type ServiceFormUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<Enumerable<ServiceFormCreateWithoutServiceInput>, Enumerable<ServiceFormUncheckedCreateWithoutServiceInput>>
    connectOrCreate?: Enumerable<ServiceFormCreateOrConnectWithoutServiceInput>
    createMany?: ServiceFormCreateManyServiceInputEnvelope
    connect?: Enumerable<ServiceFormWhereUniqueInput>
  }

  export type ProductUpdateManyWithoutServiceNestedInput = {
    create?: XOR<Enumerable<ProductCreateWithoutServiceInput>, Enumerable<ProductUncheckedCreateWithoutServiceInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutServiceInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutServiceInput>
    createMany?: ProductCreateManyServiceInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutServiceInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutServiceInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type ServiceFormUpdateManyWithoutServiceNestedInput = {
    create?: XOR<Enumerable<ServiceFormCreateWithoutServiceInput>, Enumerable<ServiceFormUncheckedCreateWithoutServiceInput>>
    connectOrCreate?: Enumerable<ServiceFormCreateOrConnectWithoutServiceInput>
    upsert?: Enumerable<ServiceFormUpsertWithWhereUniqueWithoutServiceInput>
    createMany?: ServiceFormCreateManyServiceInputEnvelope
    set?: Enumerable<ServiceFormWhereUniqueInput>
    disconnect?: Enumerable<ServiceFormWhereUniqueInput>
    delete?: Enumerable<ServiceFormWhereUniqueInput>
    connect?: Enumerable<ServiceFormWhereUniqueInput>
    update?: Enumerable<ServiceFormUpdateWithWhereUniqueWithoutServiceInput>
    updateMany?: Enumerable<ServiceFormUpdateManyWithWhereWithoutServiceInput>
    deleteMany?: Enumerable<ServiceFormScalarWhereInput>
  }

  export type ProductUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<Enumerable<ProductCreateWithoutServiceInput>, Enumerable<ProductUncheckedCreateWithoutServiceInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutServiceInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutServiceInput>
    createMany?: ProductCreateManyServiceInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutServiceInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutServiceInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type ServiceFormUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<Enumerable<ServiceFormCreateWithoutServiceInput>, Enumerable<ServiceFormUncheckedCreateWithoutServiceInput>>
    connectOrCreate?: Enumerable<ServiceFormCreateOrConnectWithoutServiceInput>
    upsert?: Enumerable<ServiceFormUpsertWithWhereUniqueWithoutServiceInput>
    createMany?: ServiceFormCreateManyServiceInputEnvelope
    set?: Enumerable<ServiceFormWhereUniqueInput>
    disconnect?: Enumerable<ServiceFormWhereUniqueInput>
    delete?: Enumerable<ServiceFormWhereUniqueInput>
    connect?: Enumerable<ServiceFormWhereUniqueInput>
    update?: Enumerable<ServiceFormUpdateWithWhereUniqueWithoutServiceInput>
    updateMany?: Enumerable<ServiceFormUpdateManyWithWhereWithoutServiceInput>
    deleteMany?: Enumerable<ServiceFormScalarWhereInput>
  }

  export type ServiceCreateNestedOneWithoutFormInput = {
    create?: XOR<ServiceCreateWithoutFormInput, ServiceUncheckedCreateWithoutFormInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutFormInput
    connect?: ServiceWhereUniqueInput
  }

  export type ServiceSubFormCreateNestedManyWithoutFormInput = {
    create?: XOR<Enumerable<ServiceSubFormCreateWithoutFormInput>, Enumerable<ServiceSubFormUncheckedCreateWithoutFormInput>>
    connectOrCreate?: Enumerable<ServiceSubFormCreateOrConnectWithoutFormInput>
    createMany?: ServiceSubFormCreateManyFormInputEnvelope
    connect?: Enumerable<ServiceSubFormWhereUniqueInput>
  }

  export type ServiceSubFormUncheckedCreateNestedManyWithoutFormInput = {
    create?: XOR<Enumerable<ServiceSubFormCreateWithoutFormInput>, Enumerable<ServiceSubFormUncheckedCreateWithoutFormInput>>
    connectOrCreate?: Enumerable<ServiceSubFormCreateOrConnectWithoutFormInput>
    createMany?: ServiceSubFormCreateManyFormInputEnvelope
    connect?: Enumerable<ServiceSubFormWhereUniqueInput>
  }

  export type ServiceUpdateOneRequiredWithoutFormNestedInput = {
    create?: XOR<ServiceCreateWithoutFormInput, ServiceUncheckedCreateWithoutFormInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutFormInput
    upsert?: ServiceUpsertWithoutFormInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<ServiceUpdateWithoutFormInput, ServiceUncheckedUpdateWithoutFormInput>
  }

  export type ServiceSubFormUpdateManyWithoutFormNestedInput = {
    create?: XOR<Enumerable<ServiceSubFormCreateWithoutFormInput>, Enumerable<ServiceSubFormUncheckedCreateWithoutFormInput>>
    connectOrCreate?: Enumerable<ServiceSubFormCreateOrConnectWithoutFormInput>
    upsert?: Enumerable<ServiceSubFormUpsertWithWhereUniqueWithoutFormInput>
    createMany?: ServiceSubFormCreateManyFormInputEnvelope
    set?: Enumerable<ServiceSubFormWhereUniqueInput>
    disconnect?: Enumerable<ServiceSubFormWhereUniqueInput>
    delete?: Enumerable<ServiceSubFormWhereUniqueInput>
    connect?: Enumerable<ServiceSubFormWhereUniqueInput>
    update?: Enumerable<ServiceSubFormUpdateWithWhereUniqueWithoutFormInput>
    updateMany?: Enumerable<ServiceSubFormUpdateManyWithWhereWithoutFormInput>
    deleteMany?: Enumerable<ServiceSubFormScalarWhereInput>
  }

  export type ServiceSubFormUncheckedUpdateManyWithoutFormNestedInput = {
    create?: XOR<Enumerable<ServiceSubFormCreateWithoutFormInput>, Enumerable<ServiceSubFormUncheckedCreateWithoutFormInput>>
    connectOrCreate?: Enumerable<ServiceSubFormCreateOrConnectWithoutFormInput>
    upsert?: Enumerable<ServiceSubFormUpsertWithWhereUniqueWithoutFormInput>
    createMany?: ServiceSubFormCreateManyFormInputEnvelope
    set?: Enumerable<ServiceSubFormWhereUniqueInput>
    disconnect?: Enumerable<ServiceSubFormWhereUniqueInput>
    delete?: Enumerable<ServiceSubFormWhereUniqueInput>
    connect?: Enumerable<ServiceSubFormWhereUniqueInput>
    update?: Enumerable<ServiceSubFormUpdateWithWhereUniqueWithoutFormInput>
    updateMany?: Enumerable<ServiceSubFormUpdateManyWithWhereWithoutFormInput>
    deleteMany?: Enumerable<ServiceSubFormScalarWhereInput>
  }

  export type ServiceSubFormCreateoptionsInput = {
    set: Enumerable<string>
  }

  export type ServiceSubFormCreatedependentOptionsInput = {
    set: Enumerable<string>
  }

  export type ServiceFormCreateNestedOneWithoutSubFormInput = {
    create?: XOR<ServiceFormCreateWithoutSubFormInput, ServiceFormUncheckedCreateWithoutSubFormInput>
    connectOrCreate?: ServiceFormCreateOrConnectWithoutSubFormInput
    connect?: ServiceFormWhereUniqueInput
  }

  export type ServiceSubFormUpdateoptionsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ServiceSubFormUpdatedependentOptionsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ServiceFormUpdateOneRequiredWithoutSubFormNestedInput = {
    create?: XOR<ServiceFormCreateWithoutSubFormInput, ServiceFormUncheckedCreateWithoutSubFormInput>
    connectOrCreate?: ServiceFormCreateOrConnectWithoutSubFormInput
    upsert?: ServiceFormUpsertWithoutSubFormInput
    connect?: ServiceFormWhereUniqueInput
    update?: XOR<ServiceFormUpdateWithoutSubFormInput, ServiceFormUncheckedUpdateWithoutSubFormInput>
  }

  export type ProductCreatefeatureInput = {
    set: Enumerable<string>
  }

  export type ProductCreatecanAlsoDoInput = {
    set: Enumerable<string>
  }

  export type ServiceCreateNestedOneWithoutProductsInput = {
    create?: XOR<ServiceCreateWithoutProductsInput, ServiceUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutProductsInput
    connect?: ServiceWhereUniqueInput
  }

  export type ProductRequestCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<ProductRequestCreateWithoutProductInput>, Enumerable<ProductRequestUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductRequestCreateOrConnectWithoutProductInput>
    createMany?: ProductRequestCreateManyProductInputEnvelope
    connect?: Enumerable<ProductRequestWhereUniqueInput>
  }

  export type ProductFormCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<ProductFormCreateWithoutProductInput>, Enumerable<ProductFormUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductFormCreateOrConnectWithoutProductInput>
    createMany?: ProductFormCreateManyProductInputEnvelope
    connect?: Enumerable<ProductFormWhereUniqueInput>
  }

  export type ProductRequestUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<ProductRequestCreateWithoutProductInput>, Enumerable<ProductRequestUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductRequestCreateOrConnectWithoutProductInput>
    createMany?: ProductRequestCreateManyProductInputEnvelope
    connect?: Enumerable<ProductRequestWhereUniqueInput>
  }

  export type ProductFormUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<ProductFormCreateWithoutProductInput>, Enumerable<ProductFormUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductFormCreateOrConnectWithoutProductInput>
    createMany?: ProductFormCreateManyProductInputEnvelope
    connect?: Enumerable<ProductFormWhereUniqueInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProductUpdatefeatureInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ProductUpdatecanAlsoDoInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ServiceUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<ServiceCreateWithoutProductsInput, ServiceUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutProductsInput
    upsert?: ServiceUpsertWithoutProductsInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<ServiceUpdateWithoutProductsInput, ServiceUncheckedUpdateWithoutProductsInput>
  }

  export type ProductRequestUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<ProductRequestCreateWithoutProductInput>, Enumerable<ProductRequestUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductRequestCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<ProductRequestUpsertWithWhereUniqueWithoutProductInput>
    createMany?: ProductRequestCreateManyProductInputEnvelope
    set?: Enumerable<ProductRequestWhereUniqueInput>
    disconnect?: Enumerable<ProductRequestWhereUniqueInput>
    delete?: Enumerable<ProductRequestWhereUniqueInput>
    connect?: Enumerable<ProductRequestWhereUniqueInput>
    update?: Enumerable<ProductRequestUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<ProductRequestUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<ProductRequestScalarWhereInput>
  }

  export type ProductFormUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<ProductFormCreateWithoutProductInput>, Enumerable<ProductFormUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductFormCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<ProductFormUpsertWithWhereUniqueWithoutProductInput>
    createMany?: ProductFormCreateManyProductInputEnvelope
    set?: Enumerable<ProductFormWhereUniqueInput>
    disconnect?: Enumerable<ProductFormWhereUniqueInput>
    delete?: Enumerable<ProductFormWhereUniqueInput>
    connect?: Enumerable<ProductFormWhereUniqueInput>
    update?: Enumerable<ProductFormUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<ProductFormUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<ProductFormScalarWhereInput>
  }

  export type ProductRequestUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<ProductRequestCreateWithoutProductInput>, Enumerable<ProductRequestUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductRequestCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<ProductRequestUpsertWithWhereUniqueWithoutProductInput>
    createMany?: ProductRequestCreateManyProductInputEnvelope
    set?: Enumerable<ProductRequestWhereUniqueInput>
    disconnect?: Enumerable<ProductRequestWhereUniqueInput>
    delete?: Enumerable<ProductRequestWhereUniqueInput>
    connect?: Enumerable<ProductRequestWhereUniqueInput>
    update?: Enumerable<ProductRequestUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<ProductRequestUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<ProductRequestScalarWhereInput>
  }

  export type ProductFormUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<ProductFormCreateWithoutProductInput>, Enumerable<ProductFormUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductFormCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<ProductFormUpsertWithWhereUniqueWithoutProductInput>
    createMany?: ProductFormCreateManyProductInputEnvelope
    set?: Enumerable<ProductFormWhereUniqueInput>
    disconnect?: Enumerable<ProductFormWhereUniqueInput>
    delete?: Enumerable<ProductFormWhereUniqueInput>
    connect?: Enumerable<ProductFormWhereUniqueInput>
    update?: Enumerable<ProductFormUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<ProductFormUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<ProductFormScalarWhereInput>
  }

  export type ProductCreateNestedOneWithoutFormInput = {
    create?: XOR<ProductCreateWithoutFormInput, ProductUncheckedCreateWithoutFormInput>
    connectOrCreate?: ProductCreateOrConnectWithoutFormInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductSubFormCreateNestedManyWithoutFormInput = {
    create?: XOR<Enumerable<ProductSubFormCreateWithoutFormInput>, Enumerable<ProductSubFormUncheckedCreateWithoutFormInput>>
    connectOrCreate?: Enumerable<ProductSubFormCreateOrConnectWithoutFormInput>
    createMany?: ProductSubFormCreateManyFormInputEnvelope
    connect?: Enumerable<ProductSubFormWhereUniqueInput>
  }

  export type ProductSubFormUncheckedCreateNestedManyWithoutFormInput = {
    create?: XOR<Enumerable<ProductSubFormCreateWithoutFormInput>, Enumerable<ProductSubFormUncheckedCreateWithoutFormInput>>
    connectOrCreate?: Enumerable<ProductSubFormCreateOrConnectWithoutFormInput>
    createMany?: ProductSubFormCreateManyFormInputEnvelope
    connect?: Enumerable<ProductSubFormWhereUniqueInput>
  }

  export type ProductUpdateOneRequiredWithoutFormNestedInput = {
    create?: XOR<ProductCreateWithoutFormInput, ProductUncheckedCreateWithoutFormInput>
    connectOrCreate?: ProductCreateOrConnectWithoutFormInput
    upsert?: ProductUpsertWithoutFormInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutFormInput, ProductUncheckedUpdateWithoutFormInput>
  }

  export type ProductSubFormUpdateManyWithoutFormNestedInput = {
    create?: XOR<Enumerable<ProductSubFormCreateWithoutFormInput>, Enumerable<ProductSubFormUncheckedCreateWithoutFormInput>>
    connectOrCreate?: Enumerable<ProductSubFormCreateOrConnectWithoutFormInput>
    upsert?: Enumerable<ProductSubFormUpsertWithWhereUniqueWithoutFormInput>
    createMany?: ProductSubFormCreateManyFormInputEnvelope
    set?: Enumerable<ProductSubFormWhereUniqueInput>
    disconnect?: Enumerable<ProductSubFormWhereUniqueInput>
    delete?: Enumerable<ProductSubFormWhereUniqueInput>
    connect?: Enumerable<ProductSubFormWhereUniqueInput>
    update?: Enumerable<ProductSubFormUpdateWithWhereUniqueWithoutFormInput>
    updateMany?: Enumerable<ProductSubFormUpdateManyWithWhereWithoutFormInput>
    deleteMany?: Enumerable<ProductSubFormScalarWhereInput>
  }

  export type ProductSubFormUncheckedUpdateManyWithoutFormNestedInput = {
    create?: XOR<Enumerable<ProductSubFormCreateWithoutFormInput>, Enumerable<ProductSubFormUncheckedCreateWithoutFormInput>>
    connectOrCreate?: Enumerable<ProductSubFormCreateOrConnectWithoutFormInput>
    upsert?: Enumerable<ProductSubFormUpsertWithWhereUniqueWithoutFormInput>
    createMany?: ProductSubFormCreateManyFormInputEnvelope
    set?: Enumerable<ProductSubFormWhereUniqueInput>
    disconnect?: Enumerable<ProductSubFormWhereUniqueInput>
    delete?: Enumerable<ProductSubFormWhereUniqueInput>
    connect?: Enumerable<ProductSubFormWhereUniqueInput>
    update?: Enumerable<ProductSubFormUpdateWithWhereUniqueWithoutFormInput>
    updateMany?: Enumerable<ProductSubFormUpdateManyWithWhereWithoutFormInput>
    deleteMany?: Enumerable<ProductSubFormScalarWhereInput>
  }

  export type ProductSubFormCreateoptionsInput = {
    set: Enumerable<string>
  }

  export type ProductSubFormCreatedependentOptionsInput = {
    set: Enumerable<string>
  }

  export type ProductFormCreateNestedOneWithoutProductSubFormInput = {
    create?: XOR<ProductFormCreateWithoutProductSubFormInput, ProductFormUncheckedCreateWithoutProductSubFormInput>
    connectOrCreate?: ProductFormCreateOrConnectWithoutProductSubFormInput
    connect?: ProductFormWhereUniqueInput
  }

  export type ProductSubFormUpdateoptionsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ProductSubFormUpdatedependentOptionsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ProductFormUpdateOneRequiredWithoutProductSubFormNestedInput = {
    create?: XOR<ProductFormCreateWithoutProductSubFormInput, ProductFormUncheckedCreateWithoutProductSubFormInput>
    connectOrCreate?: ProductFormCreateOrConnectWithoutProductSubFormInput
    upsert?: ProductFormUpsertWithoutProductSubFormInput
    connect?: ProductFormWhereUniqueInput
    update?: XOR<ProductFormUpdateWithoutProductSubFormInput, ProductFormUncheckedUpdateWithoutProductSubFormInput>
  }

  export type TeamCreateNestedManyWithoutProductRequestInput = {
    create?: XOR<Enumerable<TeamCreateWithoutProductRequestInput>, Enumerable<TeamUncheckedCreateWithoutProductRequestInput>>
    connectOrCreate?: Enumerable<TeamCreateOrConnectWithoutProductRequestInput>
    createMany?: TeamCreateManyProductRequestInputEnvelope
    connect?: Enumerable<TeamWhereUniqueInput>
  }

  export type ProductCreateNestedOneWithoutRequestInput = {
    create?: XOR<ProductCreateWithoutRequestInput, ProductUncheckedCreateWithoutRequestInput>
    connectOrCreate?: ProductCreateOrConnectWithoutRequestInput
    connect?: ProductWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProductRequestInput = {
    create?: XOR<UserCreateWithoutProductRequestInput, UserUncheckedCreateWithoutProductRequestInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductRequestInput
    connect?: UserWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutProductRequestsInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutProductRequestsInput>, Enumerable<PaymentUncheckedCreateWithoutProductRequestsInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutProductRequestsInput>
    createMany?: PaymentCreateManyProductRequestsInputEnvelope
    connect?: Enumerable<PaymentWhereUniqueInput>
  }

  export type ProductRequestQACreateNestedManyWithoutRequestInput = {
    create?: XOR<Enumerable<ProductRequestQACreateWithoutRequestInput>, Enumerable<ProductRequestQAUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<ProductRequestQACreateOrConnectWithoutRequestInput>
    createMany?: ProductRequestQACreateManyRequestInputEnvelope
    connect?: Enumerable<ProductRequestQAWhereUniqueInput>
  }

  export type TeamUncheckedCreateNestedManyWithoutProductRequestInput = {
    create?: XOR<Enumerable<TeamCreateWithoutProductRequestInput>, Enumerable<TeamUncheckedCreateWithoutProductRequestInput>>
    connectOrCreate?: Enumerable<TeamCreateOrConnectWithoutProductRequestInput>
    createMany?: TeamCreateManyProductRequestInputEnvelope
    connect?: Enumerable<TeamWhereUniqueInput>
  }

  export type PaymentUncheckedCreateNestedManyWithoutProductRequestsInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutProductRequestsInput>, Enumerable<PaymentUncheckedCreateWithoutProductRequestsInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutProductRequestsInput>
    createMany?: PaymentCreateManyProductRequestsInputEnvelope
    connect?: Enumerable<PaymentWhereUniqueInput>
  }

  export type ProductRequestQAUncheckedCreateNestedManyWithoutRequestInput = {
    create?: XOR<Enumerable<ProductRequestQACreateWithoutRequestInput>, Enumerable<ProductRequestQAUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<ProductRequestQACreateOrConnectWithoutRequestInput>
    createMany?: ProductRequestQACreateManyRequestInputEnvelope
    connect?: Enumerable<ProductRequestQAWhereUniqueInput>
  }

  export type EnumProductActivityStageFieldUpdateOperationsInput = {
    set?: ProductActivityStage
  }

  export type TeamUpdateManyWithoutProductRequestNestedInput = {
    create?: XOR<Enumerable<TeamCreateWithoutProductRequestInput>, Enumerable<TeamUncheckedCreateWithoutProductRequestInput>>
    connectOrCreate?: Enumerable<TeamCreateOrConnectWithoutProductRequestInput>
    upsert?: Enumerable<TeamUpsertWithWhereUniqueWithoutProductRequestInput>
    createMany?: TeamCreateManyProductRequestInputEnvelope
    set?: Enumerable<TeamWhereUniqueInput>
    disconnect?: Enumerable<TeamWhereUniqueInput>
    delete?: Enumerable<TeamWhereUniqueInput>
    connect?: Enumerable<TeamWhereUniqueInput>
    update?: Enumerable<TeamUpdateWithWhereUniqueWithoutProductRequestInput>
    updateMany?: Enumerable<TeamUpdateManyWithWhereWithoutProductRequestInput>
    deleteMany?: Enumerable<TeamScalarWhereInput>
  }

  export type ProductUpdateOneWithoutRequestNestedInput = {
    create?: XOR<ProductCreateWithoutRequestInput, ProductUncheckedCreateWithoutRequestInput>
    connectOrCreate?: ProductCreateOrConnectWithoutRequestInput
    upsert?: ProductUpsertWithoutRequestInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutRequestInput, ProductUncheckedUpdateWithoutRequestInput>
  }

  export type UserUpdateOneRequiredWithoutProductRequestNestedInput = {
    create?: XOR<UserCreateWithoutProductRequestInput, UserUncheckedCreateWithoutProductRequestInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductRequestInput
    upsert?: UserUpsertWithoutProductRequestInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutProductRequestInput, UserUncheckedUpdateWithoutProductRequestInput>
  }

  export type PaymentUpdateManyWithoutProductRequestsNestedInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutProductRequestsInput>, Enumerable<PaymentUncheckedCreateWithoutProductRequestsInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutProductRequestsInput>
    upsert?: Enumerable<PaymentUpsertWithWhereUniqueWithoutProductRequestsInput>
    createMany?: PaymentCreateManyProductRequestsInputEnvelope
    set?: Enumerable<PaymentWhereUniqueInput>
    disconnect?: Enumerable<PaymentWhereUniqueInput>
    delete?: Enumerable<PaymentWhereUniqueInput>
    connect?: Enumerable<PaymentWhereUniqueInput>
    update?: Enumerable<PaymentUpdateWithWhereUniqueWithoutProductRequestsInput>
    updateMany?: Enumerable<PaymentUpdateManyWithWhereWithoutProductRequestsInput>
    deleteMany?: Enumerable<PaymentScalarWhereInput>
  }

  export type ProductRequestQAUpdateManyWithoutRequestNestedInput = {
    create?: XOR<Enumerable<ProductRequestQACreateWithoutRequestInput>, Enumerable<ProductRequestQAUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<ProductRequestQACreateOrConnectWithoutRequestInput>
    upsert?: Enumerable<ProductRequestQAUpsertWithWhereUniqueWithoutRequestInput>
    createMany?: ProductRequestQACreateManyRequestInputEnvelope
    set?: Enumerable<ProductRequestQAWhereUniqueInput>
    disconnect?: Enumerable<ProductRequestQAWhereUniqueInput>
    delete?: Enumerable<ProductRequestQAWhereUniqueInput>
    connect?: Enumerable<ProductRequestQAWhereUniqueInput>
    update?: Enumerable<ProductRequestQAUpdateWithWhereUniqueWithoutRequestInput>
    updateMany?: Enumerable<ProductRequestQAUpdateManyWithWhereWithoutRequestInput>
    deleteMany?: Enumerable<ProductRequestQAScalarWhereInput>
  }

  export type TeamUncheckedUpdateManyWithoutProductRequestNestedInput = {
    create?: XOR<Enumerable<TeamCreateWithoutProductRequestInput>, Enumerable<TeamUncheckedCreateWithoutProductRequestInput>>
    connectOrCreate?: Enumerable<TeamCreateOrConnectWithoutProductRequestInput>
    upsert?: Enumerable<TeamUpsertWithWhereUniqueWithoutProductRequestInput>
    createMany?: TeamCreateManyProductRequestInputEnvelope
    set?: Enumerable<TeamWhereUniqueInput>
    disconnect?: Enumerable<TeamWhereUniqueInput>
    delete?: Enumerable<TeamWhereUniqueInput>
    connect?: Enumerable<TeamWhereUniqueInput>
    update?: Enumerable<TeamUpdateWithWhereUniqueWithoutProductRequestInput>
    updateMany?: Enumerable<TeamUpdateManyWithWhereWithoutProductRequestInput>
    deleteMany?: Enumerable<TeamScalarWhereInput>
  }

  export type PaymentUncheckedUpdateManyWithoutProductRequestsNestedInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutProductRequestsInput>, Enumerable<PaymentUncheckedCreateWithoutProductRequestsInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutProductRequestsInput>
    upsert?: Enumerable<PaymentUpsertWithWhereUniqueWithoutProductRequestsInput>
    createMany?: PaymentCreateManyProductRequestsInputEnvelope
    set?: Enumerable<PaymentWhereUniqueInput>
    disconnect?: Enumerable<PaymentWhereUniqueInput>
    delete?: Enumerable<PaymentWhereUniqueInput>
    connect?: Enumerable<PaymentWhereUniqueInput>
    update?: Enumerable<PaymentUpdateWithWhereUniqueWithoutProductRequestsInput>
    updateMany?: Enumerable<PaymentUpdateManyWithWhereWithoutProductRequestsInput>
    deleteMany?: Enumerable<PaymentScalarWhereInput>
  }

  export type ProductRequestQAUncheckedUpdateManyWithoutRequestNestedInput = {
    create?: XOR<Enumerable<ProductRequestQACreateWithoutRequestInput>, Enumerable<ProductRequestQAUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<ProductRequestQACreateOrConnectWithoutRequestInput>
    upsert?: Enumerable<ProductRequestQAUpsertWithWhereUniqueWithoutRequestInput>
    createMany?: ProductRequestQACreateManyRequestInputEnvelope
    set?: Enumerable<ProductRequestQAWhereUniqueInput>
    disconnect?: Enumerable<ProductRequestQAWhereUniqueInput>
    delete?: Enumerable<ProductRequestQAWhereUniqueInput>
    connect?: Enumerable<ProductRequestQAWhereUniqueInput>
    update?: Enumerable<ProductRequestQAUpdateWithWhereUniqueWithoutRequestInput>
    updateMany?: Enumerable<ProductRequestQAUpdateManyWithWhereWithoutRequestInput>
    deleteMany?: Enumerable<ProductRequestQAScalarWhereInput>
  }

  export type ProductRequestCreateNestedOneWithoutRequestQAInput = {
    create?: XOR<ProductRequestCreateWithoutRequestQAInput, ProductRequestUncheckedCreateWithoutRequestQAInput>
    connectOrCreate?: ProductRequestCreateOrConnectWithoutRequestQAInput
    connect?: ProductRequestWhereUniqueInput
  }

  export type ProductRequestQASubFormCreateNestedManyWithoutRequestQAInput = {
    create?: XOR<Enumerable<ProductRequestQASubFormCreateWithoutRequestQAInput>, Enumerable<ProductRequestQASubFormUncheckedCreateWithoutRequestQAInput>>
    connectOrCreate?: Enumerable<ProductRequestQASubFormCreateOrConnectWithoutRequestQAInput>
    createMany?: ProductRequestQASubFormCreateManyRequestQAInputEnvelope
    connect?: Enumerable<ProductRequestQASubFormWhereUniqueInput>
  }

  export type ProductRequestQASubFormUncheckedCreateNestedManyWithoutRequestQAInput = {
    create?: XOR<Enumerable<ProductRequestQASubFormCreateWithoutRequestQAInput>, Enumerable<ProductRequestQASubFormUncheckedCreateWithoutRequestQAInput>>
    connectOrCreate?: Enumerable<ProductRequestQASubFormCreateOrConnectWithoutRequestQAInput>
    createMany?: ProductRequestQASubFormCreateManyRequestQAInputEnvelope
    connect?: Enumerable<ProductRequestQASubFormWhereUniqueInput>
  }

  export type ProductRequestUpdateOneRequiredWithoutRequestQANestedInput = {
    create?: XOR<ProductRequestCreateWithoutRequestQAInput, ProductRequestUncheckedCreateWithoutRequestQAInput>
    connectOrCreate?: ProductRequestCreateOrConnectWithoutRequestQAInput
    upsert?: ProductRequestUpsertWithoutRequestQAInput
    connect?: ProductRequestWhereUniqueInput
    update?: XOR<ProductRequestUpdateWithoutRequestQAInput, ProductRequestUncheckedUpdateWithoutRequestQAInput>
  }

  export type ProductRequestQASubFormUpdateManyWithoutRequestQANestedInput = {
    create?: XOR<Enumerable<ProductRequestQASubFormCreateWithoutRequestQAInput>, Enumerable<ProductRequestQASubFormUncheckedCreateWithoutRequestQAInput>>
    connectOrCreate?: Enumerable<ProductRequestQASubFormCreateOrConnectWithoutRequestQAInput>
    upsert?: Enumerable<ProductRequestQASubFormUpsertWithWhereUniqueWithoutRequestQAInput>
    createMany?: ProductRequestQASubFormCreateManyRequestQAInputEnvelope
    set?: Enumerable<ProductRequestQASubFormWhereUniqueInput>
    disconnect?: Enumerable<ProductRequestQASubFormWhereUniqueInput>
    delete?: Enumerable<ProductRequestQASubFormWhereUniqueInput>
    connect?: Enumerable<ProductRequestQASubFormWhereUniqueInput>
    update?: Enumerable<ProductRequestQASubFormUpdateWithWhereUniqueWithoutRequestQAInput>
    updateMany?: Enumerable<ProductRequestQASubFormUpdateManyWithWhereWithoutRequestQAInput>
    deleteMany?: Enumerable<ProductRequestQASubFormScalarWhereInput>
  }

  export type ProductRequestQASubFormUncheckedUpdateManyWithoutRequestQANestedInput = {
    create?: XOR<Enumerable<ProductRequestQASubFormCreateWithoutRequestQAInput>, Enumerable<ProductRequestQASubFormUncheckedCreateWithoutRequestQAInput>>
    connectOrCreate?: Enumerable<ProductRequestQASubFormCreateOrConnectWithoutRequestQAInput>
    upsert?: Enumerable<ProductRequestQASubFormUpsertWithWhereUniqueWithoutRequestQAInput>
    createMany?: ProductRequestQASubFormCreateManyRequestQAInputEnvelope
    set?: Enumerable<ProductRequestQASubFormWhereUniqueInput>
    disconnect?: Enumerable<ProductRequestQASubFormWhereUniqueInput>
    delete?: Enumerable<ProductRequestQASubFormWhereUniqueInput>
    connect?: Enumerable<ProductRequestQASubFormWhereUniqueInput>
    update?: Enumerable<ProductRequestQASubFormUpdateWithWhereUniqueWithoutRequestQAInput>
    updateMany?: Enumerable<ProductRequestQASubFormUpdateManyWithWhereWithoutRequestQAInput>
    deleteMany?: Enumerable<ProductRequestQASubFormScalarWhereInput>
  }

  export type ProductRequestQASubFormCreateanswerInput = {
    set: Enumerable<string>
  }

  export type ProductRequestQACreateNestedOneWithoutSubFormInput = {
    create?: XOR<ProductRequestQACreateWithoutSubFormInput, ProductRequestQAUncheckedCreateWithoutSubFormInput>
    connectOrCreate?: ProductRequestQACreateOrConnectWithoutSubFormInput
    connect?: ProductRequestQAWhereUniqueInput
  }

  export type ProductRequestQASubFormUpdateanswerInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ProductRequestQAUpdateOneRequiredWithoutSubFormNestedInput = {
    create?: XOR<ProductRequestQACreateWithoutSubFormInput, ProductRequestQAUncheckedCreateWithoutSubFormInput>
    connectOrCreate?: ProductRequestQACreateOrConnectWithoutSubFormInput
    upsert?: ProductRequestQAUpsertWithoutSubFormInput
    connect?: ProductRequestQAWhereUniqueInput
    update?: XOR<ProductRequestQAUpdateWithoutSubFormInput, ProductRequestQAUncheckedUpdateWithoutSubFormInput>
  }

  export type ProductRequestCreateNestedOneWithoutTeamInput = {
    create?: XOR<ProductRequestCreateWithoutTeamInput, ProductRequestUncheckedCreateWithoutTeamInput>
    connectOrCreate?: ProductRequestCreateOrConnectWithoutTeamInput
    connect?: ProductRequestWhereUniqueInput
  }

  export type InvitationCreateNestedManyWithoutTeamInput = {
    create?: XOR<Enumerable<InvitationCreateWithoutTeamInput>, Enumerable<InvitationUncheckedCreateWithoutTeamInput>>
    connectOrCreate?: Enumerable<InvitationCreateOrConnectWithoutTeamInput>
    createMany?: InvitationCreateManyTeamInputEnvelope
    connect?: Enumerable<InvitationWhereUniqueInput>
  }

  export type TeamMemberCreateNestedManyWithoutTeamInput = {
    create?: XOR<Enumerable<TeamMemberCreateWithoutTeamInput>, Enumerable<TeamMemberUncheckedCreateWithoutTeamInput>>
    connectOrCreate?: Enumerable<TeamMemberCreateOrConnectWithoutTeamInput>
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    connect?: Enumerable<TeamMemberWhereUniqueInput>
  }

  export type InvitationUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<Enumerable<InvitationCreateWithoutTeamInput>, Enumerable<InvitationUncheckedCreateWithoutTeamInput>>
    connectOrCreate?: Enumerable<InvitationCreateOrConnectWithoutTeamInput>
    createMany?: InvitationCreateManyTeamInputEnvelope
    connect?: Enumerable<InvitationWhereUniqueInput>
  }

  export type TeamMemberUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<Enumerable<TeamMemberCreateWithoutTeamInput>, Enumerable<TeamMemberUncheckedCreateWithoutTeamInput>>
    connectOrCreate?: Enumerable<TeamMemberCreateOrConnectWithoutTeamInput>
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    connect?: Enumerable<TeamMemberWhereUniqueInput>
  }

  export type ProductRequestUpdateOneRequiredWithoutTeamNestedInput = {
    create?: XOR<ProductRequestCreateWithoutTeamInput, ProductRequestUncheckedCreateWithoutTeamInput>
    connectOrCreate?: ProductRequestCreateOrConnectWithoutTeamInput
    upsert?: ProductRequestUpsertWithoutTeamInput
    connect?: ProductRequestWhereUniqueInput
    update?: XOR<ProductRequestUpdateWithoutTeamInput, ProductRequestUncheckedUpdateWithoutTeamInput>
  }

  export type InvitationUpdateManyWithoutTeamNestedInput = {
    create?: XOR<Enumerable<InvitationCreateWithoutTeamInput>, Enumerable<InvitationUncheckedCreateWithoutTeamInput>>
    connectOrCreate?: Enumerable<InvitationCreateOrConnectWithoutTeamInput>
    upsert?: Enumerable<InvitationUpsertWithWhereUniqueWithoutTeamInput>
    createMany?: InvitationCreateManyTeamInputEnvelope
    set?: Enumerable<InvitationWhereUniqueInput>
    disconnect?: Enumerable<InvitationWhereUniqueInput>
    delete?: Enumerable<InvitationWhereUniqueInput>
    connect?: Enumerable<InvitationWhereUniqueInput>
    update?: Enumerable<InvitationUpdateWithWhereUniqueWithoutTeamInput>
    updateMany?: Enumerable<InvitationUpdateManyWithWhereWithoutTeamInput>
    deleteMany?: Enumerable<InvitationScalarWhereInput>
  }

  export type TeamMemberUpdateManyWithoutTeamNestedInput = {
    create?: XOR<Enumerable<TeamMemberCreateWithoutTeamInput>, Enumerable<TeamMemberUncheckedCreateWithoutTeamInput>>
    connectOrCreate?: Enumerable<TeamMemberCreateOrConnectWithoutTeamInput>
    upsert?: Enumerable<TeamMemberUpsertWithWhereUniqueWithoutTeamInput>
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    set?: Enumerable<TeamMemberWhereUniqueInput>
    disconnect?: Enumerable<TeamMemberWhereUniqueInput>
    delete?: Enumerable<TeamMemberWhereUniqueInput>
    connect?: Enumerable<TeamMemberWhereUniqueInput>
    update?: Enumerable<TeamMemberUpdateWithWhereUniqueWithoutTeamInput>
    updateMany?: Enumerable<TeamMemberUpdateManyWithWhereWithoutTeamInput>
    deleteMany?: Enumerable<TeamMemberScalarWhereInput>
  }

  export type InvitationUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<Enumerable<InvitationCreateWithoutTeamInput>, Enumerable<InvitationUncheckedCreateWithoutTeamInput>>
    connectOrCreate?: Enumerable<InvitationCreateOrConnectWithoutTeamInput>
    upsert?: Enumerable<InvitationUpsertWithWhereUniqueWithoutTeamInput>
    createMany?: InvitationCreateManyTeamInputEnvelope
    set?: Enumerable<InvitationWhereUniqueInput>
    disconnect?: Enumerable<InvitationWhereUniqueInput>
    delete?: Enumerable<InvitationWhereUniqueInput>
    connect?: Enumerable<InvitationWhereUniqueInput>
    update?: Enumerable<InvitationUpdateWithWhereUniqueWithoutTeamInput>
    updateMany?: Enumerable<InvitationUpdateManyWithWhereWithoutTeamInput>
    deleteMany?: Enumerable<InvitationScalarWhereInput>
  }

  export type TeamMemberUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<Enumerable<TeamMemberCreateWithoutTeamInput>, Enumerable<TeamMemberUncheckedCreateWithoutTeamInput>>
    connectOrCreate?: Enumerable<TeamMemberCreateOrConnectWithoutTeamInput>
    upsert?: Enumerable<TeamMemberUpsertWithWhereUniqueWithoutTeamInput>
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    set?: Enumerable<TeamMemberWhereUniqueInput>
    disconnect?: Enumerable<TeamMemberWhereUniqueInput>
    delete?: Enumerable<TeamMemberWhereUniqueInput>
    connect?: Enumerable<TeamMemberWhereUniqueInput>
    update?: Enumerable<TeamMemberUpdateWithWhereUniqueWithoutTeamInput>
    updateMany?: Enumerable<TeamMemberUpdateManyWithWhereWithoutTeamInput>
    deleteMany?: Enumerable<TeamMemberScalarWhereInput>
  }

  export type TeamCreateNestedOneWithoutTeamMemberInput = {
    create?: XOR<TeamCreateWithoutTeamMemberInput, TeamUncheckedCreateWithoutTeamMemberInput>
    connectOrCreate?: TeamCreateOrConnectWithoutTeamMemberInput
    connect?: TeamWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTeamMemberInput = {
    create?: XOR<UserCreateWithoutTeamMemberInput, UserUncheckedCreateWithoutTeamMemberInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamMemberInput
    connect?: UserWhereUniqueInput
  }

  export type TeamUpdateOneRequiredWithoutTeamMemberNestedInput = {
    create?: XOR<TeamCreateWithoutTeamMemberInput, TeamUncheckedCreateWithoutTeamMemberInput>
    connectOrCreate?: TeamCreateOrConnectWithoutTeamMemberInput
    upsert?: TeamUpsertWithoutTeamMemberInput
    connect?: TeamWhereUniqueInput
    update?: XOR<TeamUpdateWithoutTeamMemberInput, TeamUncheckedUpdateWithoutTeamMemberInput>
  }

  export type UserUpdateOneRequiredWithoutTeamMemberNestedInput = {
    create?: XOR<UserCreateWithoutTeamMemberInput, UserUncheckedCreateWithoutTeamMemberInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamMemberInput
    upsert?: UserUpsertWithoutTeamMemberInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutTeamMemberInput, UserUncheckedUpdateWithoutTeamMemberInput>
  }

  export type TeamCreateNestedOneWithoutInvitationInput = {
    create?: XOR<TeamCreateWithoutInvitationInput, TeamUncheckedCreateWithoutInvitationInput>
    connectOrCreate?: TeamCreateOrConnectWithoutInvitationInput
    connect?: TeamWhereUniqueInput
  }

  export type TeamUpdateOneRequiredWithoutInvitationNestedInput = {
    create?: XOR<TeamCreateWithoutInvitationInput, TeamUncheckedCreateWithoutInvitationInput>
    connectOrCreate?: TeamCreateOrConnectWithoutInvitationInput
    upsert?: TeamUpsertWithoutInvitationInput
    connect?: TeamWhereUniqueInput
    update?: XOR<TeamUpdateWithoutInvitationInput, TeamUncheckedUpdateWithoutInvitationInput>
  }

  export type ProductRequestCreateNestedOneWithoutPaymentInput = {
    create?: XOR<ProductRequestCreateWithoutPaymentInput, ProductRequestUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: ProductRequestCreateOrConnectWithoutPaymentInput
    connect?: ProductRequestWhereUniqueInput
  }

  export type ProductRequestUpdateOneRequiredWithoutPaymentNestedInput = {
    create?: XOR<ProductRequestCreateWithoutPaymentInput, ProductRequestUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: ProductRequestCreateOrConnectWithoutPaymentInput
    upsert?: ProductRequestUpsertWithoutPaymentInput
    connect?: ProductRequestWhereUniqueInput
    update?: XOR<ProductRequestUpdateWithoutPaymentInput, ProductRequestUncheckedUpdateWithoutPaymentInput>
  }

  export type ParterCreateverificationDocumentInput = {
    set: Enumerable<string>
  }

  export type ParterCreatepaymentDetailsInput = {
    set: Enumerable<string>
  }

  export type ParterCreatecountrySupportedInput = {
    set: Enumerable<string>
  }

  export type ParterCreateserviceSupportedInput = {
    set: Enumerable<string>
  }

  export type ParterCreateservicesAssignedInput = {
    set: Enumerable<string>
  }

  export type ParterCreateservicesCompletedInput = {
    set: Enumerable<string>
  }

  export type ParterCreateservicesDeclinedInput = {
    set: Enumerable<string>
  }

  export type ParterUpdateverificationDocumentInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ParterUpdatepaymentDetailsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ParterUpdatecountrySupportedInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ParterUpdateserviceSupportedInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ParterUpdateservicesAssignedInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ParterUpdateservicesCompletedInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ParterUpdateservicesDeclinedInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedEnumProductActivityStageFilter = {
    equals?: ProductActivityStage
    in?: Enumerable<ProductActivityStage>
    notIn?: Enumerable<ProductActivityStage>
    not?: NestedEnumProductActivityStageFilter | ProductActivityStage
  }

  export type NestedEnumProductActivityStageWithAggregatesFilter = {
    equals?: ProductActivityStage
    in?: Enumerable<ProductActivityStage>
    notIn?: Enumerable<ProductActivityStage>
    not?: NestedEnumProductActivityStageWithAggregatesFilter | ProductActivityStage
    _count?: NestedIntFilter
    _min?: NestedEnumProductActivityStageFilter
    _max?: NestedEnumProductActivityStageFilter
  }

  export type CollaboratorDocumentCreateWithoutCollaboratorInput = {
    id?: string
    name: string
    type: string
    description: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CollaboratorDocumentUncheckedCreateWithoutCollaboratorInput = {
    id?: string
    name: string
    type: string
    description: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CollaboratorDocumentCreateOrConnectWithoutCollaboratorInput = {
    where: CollaboratorDocumentWhereUniqueInput
    create: XOR<CollaboratorDocumentCreateWithoutCollaboratorInput, CollaboratorDocumentUncheckedCreateWithoutCollaboratorInput>
  }

  export type CollaboratorDocumentCreateManyCollaboratorInputEnvelope = {
    data: Enumerable<CollaboratorDocumentCreateManyCollaboratorInput>
    skipDuplicates?: boolean
  }

  export type CollaboratorDocumentUpsertWithWhereUniqueWithoutCollaboratorInput = {
    where: CollaboratorDocumentWhereUniqueInput
    update: XOR<CollaboratorDocumentUpdateWithoutCollaboratorInput, CollaboratorDocumentUncheckedUpdateWithoutCollaboratorInput>
    create: XOR<CollaboratorDocumentCreateWithoutCollaboratorInput, CollaboratorDocumentUncheckedCreateWithoutCollaboratorInput>
  }

  export type CollaboratorDocumentUpdateWithWhereUniqueWithoutCollaboratorInput = {
    where: CollaboratorDocumentWhereUniqueInput
    data: XOR<CollaboratorDocumentUpdateWithoutCollaboratorInput, CollaboratorDocumentUncheckedUpdateWithoutCollaboratorInput>
  }

  export type CollaboratorDocumentUpdateManyWithWhereWithoutCollaboratorInput = {
    where: CollaboratorDocumentScalarWhereInput
    data: XOR<CollaboratorDocumentUpdateManyMutationInput, CollaboratorDocumentUncheckedUpdateManyWithoutCollaboratorDocumentInput>
  }

  export type CollaboratorDocumentScalarWhereInput = {
    AND?: Enumerable<CollaboratorDocumentScalarWhereInput>
    OR?: Enumerable<CollaboratorDocumentScalarWhereInput>
    NOT?: Enumerable<CollaboratorDocumentScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    type?: StringFilter | string
    description?: StringFilter | string
    isDeprecated?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    collaboratorId?: StringFilter | string
  }

  export type CollaboratorCreateWithoutCollaboratorDocumentInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    password: string
    phone: string
    picture?: string | null
    verified: boolean
    isPartner: boolean
    resetToken?: string | null
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CollaboratorUncheckedCreateWithoutCollaboratorDocumentInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    password: string
    phone: string
    picture?: string | null
    verified: boolean
    isPartner: boolean
    resetToken?: string | null
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CollaboratorCreateOrConnectWithoutCollaboratorDocumentInput = {
    where: CollaboratorWhereUniqueInput
    create: XOR<CollaboratorCreateWithoutCollaboratorDocumentInput, CollaboratorUncheckedCreateWithoutCollaboratorDocumentInput>
  }

  export type CollaboratorUpsertWithoutCollaboratorDocumentInput = {
    update: XOR<CollaboratorUpdateWithoutCollaboratorDocumentInput, CollaboratorUncheckedUpdateWithoutCollaboratorDocumentInput>
    create: XOR<CollaboratorCreateWithoutCollaboratorDocumentInput, CollaboratorUncheckedCreateWithoutCollaboratorDocumentInput>
  }

  export type CollaboratorUpdateWithoutCollaboratorDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollaboratorUncheckedUpdateWithoutCollaboratorDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutAccountInput = {
    id?: string
    fullName: string
    username?: string | null
    email: string
    password?: string | null
    googleId?: string | null
    phone?: string | null
    picture?: string | null
    isVerified?: boolean
    referral?: string | null
    country?: string | null
    resetToken?: string | null
    isPartner?: boolean
    isStaff?: boolean
    isPhoneRegistered?: boolean
    isPhoneVerified?: boolean
    isIdentificationRegistered?: boolean
    isIdentificationVerified?: boolean
    partnerPermission?: UserCreatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserCreatestaffPermissionInput | Enumerable<string>
    userPermission?: UserCreateuserPermissionInput | Enumerable<string>
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamMember?: TeamMemberCreateNestedManyWithoutUserInput
    productRequest?: ProductRequestCreateNestedManyWithoutUserInput
    document?: UserDocumentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountInput = {
    id?: string
    fullName: string
    username?: string | null
    email: string
    password?: string | null
    googleId?: string | null
    phone?: string | null
    picture?: string | null
    isVerified?: boolean
    referral?: string | null
    country?: string | null
    resetToken?: string | null
    isPartner?: boolean
    isStaff?: boolean
    isPhoneRegistered?: boolean
    isPhoneVerified?: boolean
    isIdentificationRegistered?: boolean
    isIdentificationVerified?: boolean
    partnerPermission?: UserCreatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserCreatestaffPermissionInput | Enumerable<string>
    userPermission?: UserCreateuserPermissionInput | Enumerable<string>
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamMember?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    productRequest?: ProductRequestUncheckedCreateNestedManyWithoutUserInput
    document?: UserDocumentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountInput, UserUncheckedCreateWithoutAccountInput>
  }

  export type UserUpsertWithoutAccountInput = {
    update: XOR<UserUpdateWithoutAccountInput, UserUncheckedUpdateWithoutAccountInput>
    create: XOR<UserCreateWithoutAccountInput, UserUncheckedCreateWithoutAccountInput>
  }

  export type UserUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    isStaff?: BoolFieldUpdateOperationsInput | boolean
    isPhoneRegistered?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationRegistered?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationVerified?: BoolFieldUpdateOperationsInput | boolean
    partnerPermission?: UserUpdatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserUpdatestaffPermissionInput | Enumerable<string>
    userPermission?: UserUpdateuserPermissionInput | Enumerable<string>
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMember?: TeamMemberUpdateManyWithoutUserNestedInput
    productRequest?: ProductRequestUpdateManyWithoutUserNestedInput
    document?: UserDocumentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    isStaff?: BoolFieldUpdateOperationsInput | boolean
    isPhoneRegistered?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationRegistered?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationVerified?: BoolFieldUpdateOperationsInput | boolean
    partnerPermission?: UserUpdatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserUpdatestaffPermissionInput | Enumerable<string>
    userPermission?: UserUpdateuserPermissionInput | Enumerable<string>
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMember?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    productRequest?: ProductRequestUncheckedUpdateManyWithoutUserNestedInput
    document?: UserDocumentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TeamMemberCreateWithoutUserInput = {
    id?: string
    isLaunchMember: boolean
    isLaunchController: boolean
    isLaunchOwner: boolean
    launchOwnership: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    team: TeamCreateNestedOneWithoutTeamMemberInput
  }

  export type TeamMemberUncheckedCreateWithoutUserInput = {
    id?: string
    isLaunchMember: boolean
    isLaunchController: boolean
    isLaunchOwner: boolean
    launchOwnership: number
    teamId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
  }

  export type TeamMemberCreateOrConnectWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    create: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
  }

  export type TeamMemberCreateManyUserInputEnvelope = {
    data: Enumerable<TeamMemberCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    scope: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    scope: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: Enumerable<AccountCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ProductRequestCreateWithoutUserInput = {
    id?: string
    email?: string | null
    address?: string | null
    paid?: boolean
    completed?: boolean
    status?: string
    currentState?: ProductActivityStage
    createdAt?: Date | string
    isDeprecated?: boolean
    updatedAt?: Date | string
    Team?: TeamCreateNestedManyWithoutProductRequestInput
    product?: ProductCreateNestedOneWithoutRequestInput
    Payment?: PaymentCreateNestedManyWithoutProductRequestsInput
    requestQA?: ProductRequestQACreateNestedManyWithoutRequestInput
  }

  export type ProductRequestUncheckedCreateWithoutUserInput = {
    id?: string
    email?: string | null
    address?: string | null
    paid?: boolean
    completed?: boolean
    status?: string
    currentState?: ProductActivityStage
    createdAt?: Date | string
    isDeprecated?: boolean
    updatedAt?: Date | string
    productId?: string | null
    Team?: TeamUncheckedCreateNestedManyWithoutProductRequestInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutProductRequestsInput
    requestQA?: ProductRequestQAUncheckedCreateNestedManyWithoutRequestInput
  }

  export type ProductRequestCreateOrConnectWithoutUserInput = {
    where: ProductRequestWhereUniqueInput
    create: XOR<ProductRequestCreateWithoutUserInput, ProductRequestUncheckedCreateWithoutUserInput>
  }

  export type ProductRequestCreateManyUserInputEnvelope = {
    data: Enumerable<ProductRequestCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type UserDocumentCreateWithoutUserInput = {
    id?: string
    name?: string | null
    type?: string | null
    link?: string | null
    size?: string | null
    belongsTo?: string | null
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserDocumentUncheckedCreateWithoutUserInput = {
    id?: string
    name?: string | null
    type?: string | null
    link?: string | null
    size?: string | null
    belongsTo?: string | null
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserDocumentCreateOrConnectWithoutUserInput = {
    where: UserDocumentWhereUniqueInput
    create: XOR<UserDocumentCreateWithoutUserInput, UserDocumentUncheckedCreateWithoutUserInput>
  }

  export type UserDocumentCreateManyUserInputEnvelope = {
    data: Enumerable<UserDocumentCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type TeamMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    update: XOR<TeamMemberUpdateWithoutUserInput, TeamMemberUncheckedUpdateWithoutUserInput>
    create: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
  }

  export type TeamMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    data: XOR<TeamMemberUpdateWithoutUserInput, TeamMemberUncheckedUpdateWithoutUserInput>
  }

  export type TeamMemberUpdateManyWithWhereWithoutUserInput = {
    where: TeamMemberScalarWhereInput
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyWithoutTeamMemberInput>
  }

  export type TeamMemberScalarWhereInput = {
    AND?: Enumerable<TeamMemberScalarWhereInput>
    OR?: Enumerable<TeamMemberScalarWhereInput>
    NOT?: Enumerable<TeamMemberScalarWhereInput>
    id?: StringFilter | string
    isLaunchMember?: BoolFilter | boolean
    isLaunchController?: BoolFilter | boolean
    isLaunchOwner?: BoolFilter | boolean
    launchOwnership?: IntFilter | number
    teamId?: StringFilter | string
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeprecated?: BoolFilter | boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutAccountInput>
  }

  export type AccountScalarWhereInput = {
    AND?: Enumerable<AccountScalarWhereInput>
    OR?: Enumerable<AccountScalarWhereInput>
    NOT?: Enumerable<AccountScalarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    type?: StringFilter | string
    provider?: StringFilter | string
    scope?: StringFilter | string
    isDeprecated?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ProductRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: ProductRequestWhereUniqueInput
    update: XOR<ProductRequestUpdateWithoutUserInput, ProductRequestUncheckedUpdateWithoutUserInput>
    create: XOR<ProductRequestCreateWithoutUserInput, ProductRequestUncheckedCreateWithoutUserInput>
  }

  export type ProductRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: ProductRequestWhereUniqueInput
    data: XOR<ProductRequestUpdateWithoutUserInput, ProductRequestUncheckedUpdateWithoutUserInput>
  }

  export type ProductRequestUpdateManyWithWhereWithoutUserInput = {
    where: ProductRequestScalarWhereInput
    data: XOR<ProductRequestUpdateManyMutationInput, ProductRequestUncheckedUpdateManyWithoutProductRequestInput>
  }

  export type ProductRequestScalarWhereInput = {
    AND?: Enumerable<ProductRequestScalarWhereInput>
    OR?: Enumerable<ProductRequestScalarWhereInput>
    NOT?: Enumerable<ProductRequestScalarWhereInput>
    id?: StringFilter | string
    email?: StringNullableFilter | string | null
    address?: StringNullableFilter | string | null
    paid?: BoolFilter | boolean
    completed?: BoolFilter | boolean
    status?: StringFilter | string
    currentState?: EnumProductActivityStageFilter | ProductActivityStage
    createdAt?: DateTimeFilter | Date | string
    isDeprecated?: BoolFilter | boolean
    updatedAt?: DateTimeFilter | Date | string
    productId?: StringNullableFilter | string | null
    userId?: StringFilter | string
  }

  export type UserDocumentUpsertWithWhereUniqueWithoutUserInput = {
    where: UserDocumentWhereUniqueInput
    update: XOR<UserDocumentUpdateWithoutUserInput, UserDocumentUncheckedUpdateWithoutUserInput>
    create: XOR<UserDocumentCreateWithoutUserInput, UserDocumentUncheckedCreateWithoutUserInput>
  }

  export type UserDocumentUpdateWithWhereUniqueWithoutUserInput = {
    where: UserDocumentWhereUniqueInput
    data: XOR<UserDocumentUpdateWithoutUserInput, UserDocumentUncheckedUpdateWithoutUserInput>
  }

  export type UserDocumentUpdateManyWithWhereWithoutUserInput = {
    where: UserDocumentScalarWhereInput
    data: XOR<UserDocumentUpdateManyMutationInput, UserDocumentUncheckedUpdateManyWithoutDocumentInput>
  }

  export type UserDocumentScalarWhereInput = {
    AND?: Enumerable<UserDocumentScalarWhereInput>
    OR?: Enumerable<UserDocumentScalarWhereInput>
    NOT?: Enumerable<UserDocumentScalarWhereInput>
    id?: StringFilter | string
    name?: StringNullableFilter | string | null
    type?: StringNullableFilter | string | null
    link?: StringNullableFilter | string | null
    size?: StringNullableFilter | string | null
    belongsTo?: StringNullableFilter | string | null
    isDeprecated?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    userId?: StringFilter | string
  }

  export type UserCreateWithoutDocumentInput = {
    id?: string
    fullName: string
    username?: string | null
    email: string
    password?: string | null
    googleId?: string | null
    phone?: string | null
    picture?: string | null
    isVerified?: boolean
    referral?: string | null
    country?: string | null
    resetToken?: string | null
    isPartner?: boolean
    isStaff?: boolean
    isPhoneRegistered?: boolean
    isPhoneVerified?: boolean
    isIdentificationRegistered?: boolean
    isIdentificationVerified?: boolean
    partnerPermission?: UserCreatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserCreatestaffPermissionInput | Enumerable<string>
    userPermission?: UserCreateuserPermissionInput | Enumerable<string>
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamMember?: TeamMemberCreateNestedManyWithoutUserInput
    account?: AccountCreateNestedManyWithoutUserInput
    productRequest?: ProductRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDocumentInput = {
    id?: string
    fullName: string
    username?: string | null
    email: string
    password?: string | null
    googleId?: string | null
    phone?: string | null
    picture?: string | null
    isVerified?: boolean
    referral?: string | null
    country?: string | null
    resetToken?: string | null
    isPartner?: boolean
    isStaff?: boolean
    isPhoneRegistered?: boolean
    isPhoneVerified?: boolean
    isIdentificationRegistered?: boolean
    isIdentificationVerified?: boolean
    partnerPermission?: UserCreatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserCreatestaffPermissionInput | Enumerable<string>
    userPermission?: UserCreateuserPermissionInput | Enumerable<string>
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamMember?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    account?: AccountUncheckedCreateNestedManyWithoutUserInput
    productRequest?: ProductRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDocumentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDocumentInput, UserUncheckedCreateWithoutDocumentInput>
  }

  export type UserUpsertWithoutDocumentInput = {
    update: XOR<UserUpdateWithoutDocumentInput, UserUncheckedUpdateWithoutDocumentInput>
    create: XOR<UserCreateWithoutDocumentInput, UserUncheckedCreateWithoutDocumentInput>
  }

  export type UserUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    isStaff?: BoolFieldUpdateOperationsInput | boolean
    isPhoneRegistered?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationRegistered?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationVerified?: BoolFieldUpdateOperationsInput | boolean
    partnerPermission?: UserUpdatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserUpdatestaffPermissionInput | Enumerable<string>
    userPermission?: UserUpdateuserPermissionInput | Enumerable<string>
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMember?: TeamMemberUpdateManyWithoutUserNestedInput
    account?: AccountUpdateManyWithoutUserNestedInput
    productRequest?: ProductRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    isStaff?: BoolFieldUpdateOperationsInput | boolean
    isPhoneRegistered?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationRegistered?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationVerified?: BoolFieldUpdateOperationsInput | boolean
    partnerPermission?: UserUpdatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserUpdatestaffPermissionInput | Enumerable<string>
    userPermission?: UserUpdateuserPermissionInput | Enumerable<string>
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMember?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    account?: AccountUncheckedUpdateManyWithoutUserNestedInput
    productRequest?: ProductRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductCreateWithoutServiceInput = {
    id?: string
    name: string
    description: string
    country: string
    currency: string
    amount: number
    timeline: string
    feature?: ProductCreatefeatureInput | Enumerable<string>
    canAlsoDo?: ProductCreatecanAlsoDoInput | Enumerable<string>
    hasShares?: boolean
    hasAgent?: boolean
    hasOwner?: boolean
    hasController?: boolean
    controllerIsCalled?: string | null
    OwnerIsCalled?: string | null
    agentIsCalled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    request?: ProductRequestCreateNestedManyWithoutProductInput
    form?: ProductFormCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutServiceInput = {
    id?: string
    name: string
    description: string
    country: string
    currency: string
    amount: number
    timeline: string
    feature?: ProductCreatefeatureInput | Enumerable<string>
    canAlsoDo?: ProductCreatecanAlsoDoInput | Enumerable<string>
    hasShares?: boolean
    hasAgent?: boolean
    hasOwner?: boolean
    hasController?: boolean
    controllerIsCalled?: string | null
    OwnerIsCalled?: string | null
    agentIsCalled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    request?: ProductRequestUncheckedCreateNestedManyWithoutProductInput
    form?: ProductFormUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutServiceInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutServiceInput, ProductUncheckedCreateWithoutServiceInput>
  }

  export type ProductCreateManyServiceInputEnvelope = {
    data: Enumerable<ProductCreateManyServiceInput>
    skipDuplicates?: boolean
  }

  export type ServiceFormCreateWithoutServiceInput = {
    id?: string
    title?: string | null
    description?: string | null
    type?: string | null
    compulsory?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    subForm?: ServiceSubFormCreateNestedManyWithoutFormInput
  }

  export type ServiceFormUncheckedCreateWithoutServiceInput = {
    id?: string
    title?: string | null
    description?: string | null
    type?: string | null
    compulsory?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    subForm?: ServiceSubFormUncheckedCreateNestedManyWithoutFormInput
  }

  export type ServiceFormCreateOrConnectWithoutServiceInput = {
    where: ServiceFormWhereUniqueInput
    create: XOR<ServiceFormCreateWithoutServiceInput, ServiceFormUncheckedCreateWithoutServiceInput>
  }

  export type ServiceFormCreateManyServiceInputEnvelope = {
    data: Enumerable<ServiceFormCreateManyServiceInput>
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutServiceInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutServiceInput, ProductUncheckedUpdateWithoutServiceInput>
    create: XOR<ProductCreateWithoutServiceInput, ProductUncheckedCreateWithoutServiceInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutServiceInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutServiceInput, ProductUncheckedUpdateWithoutServiceInput>
  }

  export type ProductUpdateManyWithWhereWithoutServiceInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductsInput>
  }

  export type ProductScalarWhereInput = {
    AND?: Enumerable<ProductScalarWhereInput>
    OR?: Enumerable<ProductScalarWhereInput>
    NOT?: Enumerable<ProductScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    description?: StringFilter | string
    country?: StringFilter | string
    currency?: StringFilter | string
    amount?: IntFilter | number
    timeline?: StringFilter | string
    feature?: StringNullableListFilter
    canAlsoDo?: StringNullableListFilter
    hasShares?: BoolFilter | boolean
    hasAgent?: BoolFilter | boolean
    hasOwner?: BoolFilter | boolean
    hasController?: BoolFilter | boolean
    controllerIsCalled?: StringNullableFilter | string | null
    OwnerIsCalled?: StringNullableFilter | string | null
    agentIsCalled?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeprecated?: BoolFilter | boolean
    serviceId?: StringFilter | string
  }

  export type ServiceFormUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServiceFormWhereUniqueInput
    update: XOR<ServiceFormUpdateWithoutServiceInput, ServiceFormUncheckedUpdateWithoutServiceInput>
    create: XOR<ServiceFormCreateWithoutServiceInput, ServiceFormUncheckedCreateWithoutServiceInput>
  }

  export type ServiceFormUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServiceFormWhereUniqueInput
    data: XOR<ServiceFormUpdateWithoutServiceInput, ServiceFormUncheckedUpdateWithoutServiceInput>
  }

  export type ServiceFormUpdateManyWithWhereWithoutServiceInput = {
    where: ServiceFormScalarWhereInput
    data: XOR<ServiceFormUpdateManyMutationInput, ServiceFormUncheckedUpdateManyWithoutFormInput>
  }

  export type ServiceFormScalarWhereInput = {
    AND?: Enumerable<ServiceFormScalarWhereInput>
    OR?: Enumerable<ServiceFormScalarWhereInput>
    NOT?: Enumerable<ServiceFormScalarWhereInput>
    id?: StringFilter | string
    title?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    type?: StringNullableFilter | string | null
    compulsory?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeprecated?: BoolFilter | boolean
    serviceId?: StringFilter | string
  }

  export type ServiceCreateWithoutFormInput = {
    id?: string
    name: string
    description: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutFormInput = {
    id?: string
    name: string
    description: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutFormInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutFormInput, ServiceUncheckedCreateWithoutFormInput>
  }

  export type ServiceSubFormCreateWithoutFormInput = {
    id?: string
    question?: string | null
    type?: string | null
    options?: ServiceSubFormCreateoptionsInput | Enumerable<string>
    fileName?: string | null
    fileType?: string | null
    fileLink?: string | null
    fileSize?: string | null
    dependentField?: string | null
    dependentOptions?: ServiceSubFormCreatedependentOptionsInput | Enumerable<string>
    documentType?: string | null
    allowOther?: boolean
    compulsory?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
  }

  export type ServiceSubFormUncheckedCreateWithoutFormInput = {
    id?: string
    question?: string | null
    type?: string | null
    options?: ServiceSubFormCreateoptionsInput | Enumerable<string>
    fileName?: string | null
    fileType?: string | null
    fileLink?: string | null
    fileSize?: string | null
    dependentField?: string | null
    dependentOptions?: ServiceSubFormCreatedependentOptionsInput | Enumerable<string>
    documentType?: string | null
    allowOther?: boolean
    compulsory?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
  }

  export type ServiceSubFormCreateOrConnectWithoutFormInput = {
    where: ServiceSubFormWhereUniqueInput
    create: XOR<ServiceSubFormCreateWithoutFormInput, ServiceSubFormUncheckedCreateWithoutFormInput>
  }

  export type ServiceSubFormCreateManyFormInputEnvelope = {
    data: Enumerable<ServiceSubFormCreateManyFormInput>
    skipDuplicates?: boolean
  }

  export type ServiceUpsertWithoutFormInput = {
    update: XOR<ServiceUpdateWithoutFormInput, ServiceUncheckedUpdateWithoutFormInput>
    create: XOR<ServiceCreateWithoutFormInput, ServiceUncheckedCreateWithoutFormInput>
  }

  export type ServiceUpdateWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceSubFormUpsertWithWhereUniqueWithoutFormInput = {
    where: ServiceSubFormWhereUniqueInput
    update: XOR<ServiceSubFormUpdateWithoutFormInput, ServiceSubFormUncheckedUpdateWithoutFormInput>
    create: XOR<ServiceSubFormCreateWithoutFormInput, ServiceSubFormUncheckedCreateWithoutFormInput>
  }

  export type ServiceSubFormUpdateWithWhereUniqueWithoutFormInput = {
    where: ServiceSubFormWhereUniqueInput
    data: XOR<ServiceSubFormUpdateWithoutFormInput, ServiceSubFormUncheckedUpdateWithoutFormInput>
  }

  export type ServiceSubFormUpdateManyWithWhereWithoutFormInput = {
    where: ServiceSubFormScalarWhereInput
    data: XOR<ServiceSubFormUpdateManyMutationInput, ServiceSubFormUncheckedUpdateManyWithoutSubFormInput>
  }

  export type ServiceSubFormScalarWhereInput = {
    AND?: Enumerable<ServiceSubFormScalarWhereInput>
    OR?: Enumerable<ServiceSubFormScalarWhereInput>
    NOT?: Enumerable<ServiceSubFormScalarWhereInput>
    id?: StringFilter | string
    question?: StringNullableFilter | string | null
    type?: StringNullableFilter | string | null
    options?: StringNullableListFilter
    fileName?: StringNullableFilter | string | null
    fileType?: StringNullableFilter | string | null
    fileLink?: StringNullableFilter | string | null
    fileSize?: StringNullableFilter | string | null
    dependentField?: StringNullableFilter | string | null
    dependentOptions?: StringNullableListFilter
    documentType?: StringNullableFilter | string | null
    allowOther?: BoolFilter | boolean
    compulsory?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeprecated?: BoolFilter | boolean
    formId?: StringFilter | string
  }

  export type ServiceFormCreateWithoutSubFormInput = {
    id?: string
    title?: string | null
    description?: string | null
    type?: string | null
    compulsory?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    service: ServiceCreateNestedOneWithoutFormInput
  }

  export type ServiceFormUncheckedCreateWithoutSubFormInput = {
    id?: string
    title?: string | null
    description?: string | null
    type?: string | null
    compulsory?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    serviceId: string
  }

  export type ServiceFormCreateOrConnectWithoutSubFormInput = {
    where: ServiceFormWhereUniqueInput
    create: XOR<ServiceFormCreateWithoutSubFormInput, ServiceFormUncheckedCreateWithoutSubFormInput>
  }

  export type ServiceFormUpsertWithoutSubFormInput = {
    update: XOR<ServiceFormUpdateWithoutSubFormInput, ServiceFormUncheckedUpdateWithoutSubFormInput>
    create: XOR<ServiceFormCreateWithoutSubFormInput, ServiceFormUncheckedCreateWithoutSubFormInput>
  }

  export type ServiceFormUpdateWithoutSubFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    service?: ServiceUpdateOneRequiredWithoutFormNestedInput
  }

  export type ServiceFormUncheckedUpdateWithoutSubFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceCreateWithoutProductsInput = {
    id?: string
    name: string
    description: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    form?: ServiceFormCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    description: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    form?: ServiceFormUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutProductsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutProductsInput, ServiceUncheckedCreateWithoutProductsInput>
  }

  export type ProductRequestCreateWithoutProductInput = {
    id?: string
    email?: string | null
    address?: string | null
    paid?: boolean
    completed?: boolean
    status?: string
    currentState?: ProductActivityStage
    createdAt?: Date | string
    isDeprecated?: boolean
    updatedAt?: Date | string
    Team?: TeamCreateNestedManyWithoutProductRequestInput
    user: UserCreateNestedOneWithoutProductRequestInput
    Payment?: PaymentCreateNestedManyWithoutProductRequestsInput
    requestQA?: ProductRequestQACreateNestedManyWithoutRequestInput
  }

  export type ProductRequestUncheckedCreateWithoutProductInput = {
    id?: string
    email?: string | null
    address?: string | null
    paid?: boolean
    completed?: boolean
    status?: string
    currentState?: ProductActivityStage
    createdAt?: Date | string
    isDeprecated?: boolean
    updatedAt?: Date | string
    userId: string
    Team?: TeamUncheckedCreateNestedManyWithoutProductRequestInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutProductRequestsInput
    requestQA?: ProductRequestQAUncheckedCreateNestedManyWithoutRequestInput
  }

  export type ProductRequestCreateOrConnectWithoutProductInput = {
    where: ProductRequestWhereUniqueInput
    create: XOR<ProductRequestCreateWithoutProductInput, ProductRequestUncheckedCreateWithoutProductInput>
  }

  export type ProductRequestCreateManyProductInputEnvelope = {
    data: Enumerable<ProductRequestCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type ProductFormCreateWithoutProductInput = {
    id?: string
    title?: string | null
    type?: string | null
    description?: string | null
    compulsory?: boolean
    createdAt?: Date | string
    isDeprecated?: boolean
    updatedAt?: Date | string
    productSubForm?: ProductSubFormCreateNestedManyWithoutFormInput
  }

  export type ProductFormUncheckedCreateWithoutProductInput = {
    id?: string
    title?: string | null
    type?: string | null
    description?: string | null
    compulsory?: boolean
    createdAt?: Date | string
    isDeprecated?: boolean
    updatedAt?: Date | string
    productSubForm?: ProductSubFormUncheckedCreateNestedManyWithoutFormInput
  }

  export type ProductFormCreateOrConnectWithoutProductInput = {
    where: ProductFormWhereUniqueInput
    create: XOR<ProductFormCreateWithoutProductInput, ProductFormUncheckedCreateWithoutProductInput>
  }

  export type ProductFormCreateManyProductInputEnvelope = {
    data: Enumerable<ProductFormCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type ServiceUpsertWithoutProductsInput = {
    update: XOR<ServiceUpdateWithoutProductsInput, ServiceUncheckedUpdateWithoutProductsInput>
    create: XOR<ServiceCreateWithoutProductsInput, ServiceUncheckedCreateWithoutProductsInput>
  }

  export type ServiceUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: ServiceFormUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: ServiceFormUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ProductRequestUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductRequestWhereUniqueInput
    update: XOR<ProductRequestUpdateWithoutProductInput, ProductRequestUncheckedUpdateWithoutProductInput>
    create: XOR<ProductRequestCreateWithoutProductInput, ProductRequestUncheckedCreateWithoutProductInput>
  }

  export type ProductRequestUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductRequestWhereUniqueInput
    data: XOR<ProductRequestUpdateWithoutProductInput, ProductRequestUncheckedUpdateWithoutProductInput>
  }

  export type ProductRequestUpdateManyWithWhereWithoutProductInput = {
    where: ProductRequestScalarWhereInput
    data: XOR<ProductRequestUpdateManyMutationInput, ProductRequestUncheckedUpdateManyWithoutRequestInput>
  }

  export type ProductFormUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductFormWhereUniqueInput
    update: XOR<ProductFormUpdateWithoutProductInput, ProductFormUncheckedUpdateWithoutProductInput>
    create: XOR<ProductFormCreateWithoutProductInput, ProductFormUncheckedCreateWithoutProductInput>
  }

  export type ProductFormUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductFormWhereUniqueInput
    data: XOR<ProductFormUpdateWithoutProductInput, ProductFormUncheckedUpdateWithoutProductInput>
  }

  export type ProductFormUpdateManyWithWhereWithoutProductInput = {
    where: ProductFormScalarWhereInput
    data: XOR<ProductFormUpdateManyMutationInput, ProductFormUncheckedUpdateManyWithoutFormInput>
  }

  export type ProductFormScalarWhereInput = {
    AND?: Enumerable<ProductFormScalarWhereInput>
    OR?: Enumerable<ProductFormScalarWhereInput>
    NOT?: Enumerable<ProductFormScalarWhereInput>
    id?: StringFilter | string
    title?: StringNullableFilter | string | null
    type?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    compulsory?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    isDeprecated?: BoolFilter | boolean
    updatedAt?: DateTimeFilter | Date | string
    productId?: StringFilter | string
  }

  export type ProductCreateWithoutFormInput = {
    id?: string
    name: string
    description: string
    country: string
    currency: string
    amount: number
    timeline: string
    feature?: ProductCreatefeatureInput | Enumerable<string>
    canAlsoDo?: ProductCreatecanAlsoDoInput | Enumerable<string>
    hasShares?: boolean
    hasAgent?: boolean
    hasOwner?: boolean
    hasController?: boolean
    controllerIsCalled?: string | null
    OwnerIsCalled?: string | null
    agentIsCalled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    service: ServiceCreateNestedOneWithoutProductsInput
    request?: ProductRequestCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutFormInput = {
    id?: string
    name: string
    description: string
    country: string
    currency: string
    amount: number
    timeline: string
    feature?: ProductCreatefeatureInput | Enumerable<string>
    canAlsoDo?: ProductCreatecanAlsoDoInput | Enumerable<string>
    hasShares?: boolean
    hasAgent?: boolean
    hasOwner?: boolean
    hasController?: boolean
    controllerIsCalled?: string | null
    OwnerIsCalled?: string | null
    agentIsCalled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    serviceId: string
    request?: ProductRequestUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutFormInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutFormInput, ProductUncheckedCreateWithoutFormInput>
  }

  export type ProductSubFormCreateWithoutFormInput = {
    id?: string
    question?: string | null
    options?: ProductSubFormCreateoptionsInput | Enumerable<string>
    type?: string | null
    allowOther?: boolean
    dependentField?: string | null
    dependentOptions?: ProductSubFormCreatedependentOptionsInput | Enumerable<string>
    fileName?: string | null
    fileType?: string | null
    fileLink?: string | null
    fileSize?: string | null
    documentType?: string | null
    compulsory?: boolean
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductSubFormUncheckedCreateWithoutFormInput = {
    id?: string
    question?: string | null
    options?: ProductSubFormCreateoptionsInput | Enumerable<string>
    type?: string | null
    allowOther?: boolean
    dependentField?: string | null
    dependentOptions?: ProductSubFormCreatedependentOptionsInput | Enumerable<string>
    fileName?: string | null
    fileType?: string | null
    fileLink?: string | null
    fileSize?: string | null
    documentType?: string | null
    compulsory?: boolean
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductSubFormCreateOrConnectWithoutFormInput = {
    where: ProductSubFormWhereUniqueInput
    create: XOR<ProductSubFormCreateWithoutFormInput, ProductSubFormUncheckedCreateWithoutFormInput>
  }

  export type ProductSubFormCreateManyFormInputEnvelope = {
    data: Enumerable<ProductSubFormCreateManyFormInput>
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithoutFormInput = {
    update: XOR<ProductUpdateWithoutFormInput, ProductUncheckedUpdateWithoutFormInput>
    create: XOR<ProductCreateWithoutFormInput, ProductUncheckedCreateWithoutFormInput>
  }

  export type ProductUpdateWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    timeline?: StringFieldUpdateOperationsInput | string
    feature?: ProductUpdatefeatureInput | Enumerable<string>
    canAlsoDo?: ProductUpdatecanAlsoDoInput | Enumerable<string>
    hasShares?: BoolFieldUpdateOperationsInput | boolean
    hasAgent?: BoolFieldUpdateOperationsInput | boolean
    hasOwner?: BoolFieldUpdateOperationsInput | boolean
    hasController?: BoolFieldUpdateOperationsInput | boolean
    controllerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    agentIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    service?: ServiceUpdateOneRequiredWithoutProductsNestedInput
    request?: ProductRequestUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    timeline?: StringFieldUpdateOperationsInput | string
    feature?: ProductUpdatefeatureInput | Enumerable<string>
    canAlsoDo?: ProductUpdatecanAlsoDoInput | Enumerable<string>
    hasShares?: BoolFieldUpdateOperationsInput | boolean
    hasAgent?: BoolFieldUpdateOperationsInput | boolean
    hasOwner?: BoolFieldUpdateOperationsInput | boolean
    hasController?: BoolFieldUpdateOperationsInput | boolean
    controllerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    agentIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    serviceId?: StringFieldUpdateOperationsInput | string
    request?: ProductRequestUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductSubFormUpsertWithWhereUniqueWithoutFormInput = {
    where: ProductSubFormWhereUniqueInput
    update: XOR<ProductSubFormUpdateWithoutFormInput, ProductSubFormUncheckedUpdateWithoutFormInput>
    create: XOR<ProductSubFormCreateWithoutFormInput, ProductSubFormUncheckedCreateWithoutFormInput>
  }

  export type ProductSubFormUpdateWithWhereUniqueWithoutFormInput = {
    where: ProductSubFormWhereUniqueInput
    data: XOR<ProductSubFormUpdateWithoutFormInput, ProductSubFormUncheckedUpdateWithoutFormInput>
  }

  export type ProductSubFormUpdateManyWithWhereWithoutFormInput = {
    where: ProductSubFormScalarWhereInput
    data: XOR<ProductSubFormUpdateManyMutationInput, ProductSubFormUncheckedUpdateManyWithoutProductSubFormInput>
  }

  export type ProductSubFormScalarWhereInput = {
    AND?: Enumerable<ProductSubFormScalarWhereInput>
    OR?: Enumerable<ProductSubFormScalarWhereInput>
    NOT?: Enumerable<ProductSubFormScalarWhereInput>
    id?: StringFilter | string
    question?: StringNullableFilter | string | null
    options?: StringNullableListFilter
    type?: StringNullableFilter | string | null
    allowOther?: BoolFilter | boolean
    dependentField?: StringNullableFilter | string | null
    dependentOptions?: StringNullableListFilter
    fileName?: StringNullableFilter | string | null
    fileType?: StringNullableFilter | string | null
    fileLink?: StringNullableFilter | string | null
    fileSize?: StringNullableFilter | string | null
    documentType?: StringNullableFilter | string | null
    compulsory?: BoolFilter | boolean
    isDeprecated?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    formId?: StringFilter | string
  }

  export type ProductFormCreateWithoutProductSubFormInput = {
    id?: string
    title?: string | null
    type?: string | null
    description?: string | null
    compulsory?: boolean
    createdAt?: Date | string
    isDeprecated?: boolean
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutFormInput
  }

  export type ProductFormUncheckedCreateWithoutProductSubFormInput = {
    id?: string
    title?: string | null
    type?: string | null
    description?: string | null
    compulsory?: boolean
    createdAt?: Date | string
    isDeprecated?: boolean
    updatedAt?: Date | string
    productId: string
  }

  export type ProductFormCreateOrConnectWithoutProductSubFormInput = {
    where: ProductFormWhereUniqueInput
    create: XOR<ProductFormCreateWithoutProductSubFormInput, ProductFormUncheckedCreateWithoutProductSubFormInput>
  }

  export type ProductFormUpsertWithoutProductSubFormInput = {
    update: XOR<ProductFormUpdateWithoutProductSubFormInput, ProductFormUncheckedUpdateWithoutProductSubFormInput>
    create: XOR<ProductFormCreateWithoutProductSubFormInput, ProductFormUncheckedCreateWithoutProductSubFormInput>
  }

  export type ProductFormUpdateWithoutProductSubFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutFormNestedInput
  }

  export type ProductFormUncheckedUpdateWithoutProductSubFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type TeamCreateWithoutProductRequestInput = {
    id?: string
    name: string
    slug: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    invitation?: InvitationCreateNestedManyWithoutTeamInput
    teamMember?: TeamMemberCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutProductRequestInput = {
    id?: string
    name: string
    slug: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    invitation?: InvitationUncheckedCreateNestedManyWithoutTeamInput
    teamMember?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutProductRequestInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutProductRequestInput, TeamUncheckedCreateWithoutProductRequestInput>
  }

  export type TeamCreateManyProductRequestInputEnvelope = {
    data: Enumerable<TeamCreateManyProductRequestInput>
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutRequestInput = {
    id?: string
    name: string
    description: string
    country: string
    currency: string
    amount: number
    timeline: string
    feature?: ProductCreatefeatureInput | Enumerable<string>
    canAlsoDo?: ProductCreatecanAlsoDoInput | Enumerable<string>
    hasShares?: boolean
    hasAgent?: boolean
    hasOwner?: boolean
    hasController?: boolean
    controllerIsCalled?: string | null
    OwnerIsCalled?: string | null
    agentIsCalled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    service: ServiceCreateNestedOneWithoutProductsInput
    form?: ProductFormCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutRequestInput = {
    id?: string
    name: string
    description: string
    country: string
    currency: string
    amount: number
    timeline: string
    feature?: ProductCreatefeatureInput | Enumerable<string>
    canAlsoDo?: ProductCreatecanAlsoDoInput | Enumerable<string>
    hasShares?: boolean
    hasAgent?: boolean
    hasOwner?: boolean
    hasController?: boolean
    controllerIsCalled?: string | null
    OwnerIsCalled?: string | null
    agentIsCalled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    serviceId: string
    form?: ProductFormUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutRequestInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutRequestInput, ProductUncheckedCreateWithoutRequestInput>
  }

  export type UserCreateWithoutProductRequestInput = {
    id?: string
    fullName: string
    username?: string | null
    email: string
    password?: string | null
    googleId?: string | null
    phone?: string | null
    picture?: string | null
    isVerified?: boolean
    referral?: string | null
    country?: string | null
    resetToken?: string | null
    isPartner?: boolean
    isStaff?: boolean
    isPhoneRegistered?: boolean
    isPhoneVerified?: boolean
    isIdentificationRegistered?: boolean
    isIdentificationVerified?: boolean
    partnerPermission?: UserCreatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserCreatestaffPermissionInput | Enumerable<string>
    userPermission?: UserCreateuserPermissionInput | Enumerable<string>
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamMember?: TeamMemberCreateNestedManyWithoutUserInput
    account?: AccountCreateNestedManyWithoutUserInput
    document?: UserDocumentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProductRequestInput = {
    id?: string
    fullName: string
    username?: string | null
    email: string
    password?: string | null
    googleId?: string | null
    phone?: string | null
    picture?: string | null
    isVerified?: boolean
    referral?: string | null
    country?: string | null
    resetToken?: string | null
    isPartner?: boolean
    isStaff?: boolean
    isPhoneRegistered?: boolean
    isPhoneVerified?: boolean
    isIdentificationRegistered?: boolean
    isIdentificationVerified?: boolean
    partnerPermission?: UserCreatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserCreatestaffPermissionInput | Enumerable<string>
    userPermission?: UserCreateuserPermissionInput | Enumerable<string>
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamMember?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    account?: AccountUncheckedCreateNestedManyWithoutUserInput
    document?: UserDocumentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProductRequestInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProductRequestInput, UserUncheckedCreateWithoutProductRequestInput>
  }

  export type PaymentCreateWithoutProductRequestsInput = {
    id?: string
    provider: string
    transactionId: string
    status: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
  }

  export type PaymentUncheckedCreateWithoutProductRequestsInput = {
    id?: string
    provider: string
    transactionId: string
    status: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
  }

  export type PaymentCreateOrConnectWithoutProductRequestsInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutProductRequestsInput, PaymentUncheckedCreateWithoutProductRequestsInput>
  }

  export type PaymentCreateManyProductRequestsInputEnvelope = {
    data: Enumerable<PaymentCreateManyProductRequestsInput>
    skipDuplicates?: boolean
  }

  export type ProductRequestQACreateWithoutRequestInput = {
    id?: string
    title?: string | null
    description?: string | null
    type?: string | null
    compulsory?: boolean
    isGeneral?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    subForm?: ProductRequestQASubFormCreateNestedManyWithoutRequestQAInput
  }

  export type ProductRequestQAUncheckedCreateWithoutRequestInput = {
    id?: string
    title?: string | null
    description?: string | null
    type?: string | null
    compulsory?: boolean
    isGeneral?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    subForm?: ProductRequestQASubFormUncheckedCreateNestedManyWithoutRequestQAInput
  }

  export type ProductRequestQACreateOrConnectWithoutRequestInput = {
    where: ProductRequestQAWhereUniqueInput
    create: XOR<ProductRequestQACreateWithoutRequestInput, ProductRequestQAUncheckedCreateWithoutRequestInput>
  }

  export type ProductRequestQACreateManyRequestInputEnvelope = {
    data: Enumerable<ProductRequestQACreateManyRequestInput>
    skipDuplicates?: boolean
  }

  export type TeamUpsertWithWhereUniqueWithoutProductRequestInput = {
    where: TeamWhereUniqueInput
    update: XOR<TeamUpdateWithoutProductRequestInput, TeamUncheckedUpdateWithoutProductRequestInput>
    create: XOR<TeamCreateWithoutProductRequestInput, TeamUncheckedCreateWithoutProductRequestInput>
  }

  export type TeamUpdateWithWhereUniqueWithoutProductRequestInput = {
    where: TeamWhereUniqueInput
    data: XOR<TeamUpdateWithoutProductRequestInput, TeamUncheckedUpdateWithoutProductRequestInput>
  }

  export type TeamUpdateManyWithWhereWithoutProductRequestInput = {
    where: TeamScalarWhereInput
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyWithoutTeamInput>
  }

  export type TeamScalarWhereInput = {
    AND?: Enumerable<TeamScalarWhereInput>
    OR?: Enumerable<TeamScalarWhereInput>
    NOT?: Enumerable<TeamScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    slug?: StringFilter | string
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeprecated?: BoolFilter | boolean
    productRequestId?: StringFilter | string
  }

  export type ProductUpsertWithoutRequestInput = {
    update: XOR<ProductUpdateWithoutRequestInput, ProductUncheckedUpdateWithoutRequestInput>
    create: XOR<ProductCreateWithoutRequestInput, ProductUncheckedCreateWithoutRequestInput>
  }

  export type ProductUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    timeline?: StringFieldUpdateOperationsInput | string
    feature?: ProductUpdatefeatureInput | Enumerable<string>
    canAlsoDo?: ProductUpdatecanAlsoDoInput | Enumerable<string>
    hasShares?: BoolFieldUpdateOperationsInput | boolean
    hasAgent?: BoolFieldUpdateOperationsInput | boolean
    hasOwner?: BoolFieldUpdateOperationsInput | boolean
    hasController?: BoolFieldUpdateOperationsInput | boolean
    controllerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    agentIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    service?: ServiceUpdateOneRequiredWithoutProductsNestedInput
    form?: ProductFormUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    timeline?: StringFieldUpdateOperationsInput | string
    feature?: ProductUpdatefeatureInput | Enumerable<string>
    canAlsoDo?: ProductUpdatecanAlsoDoInput | Enumerable<string>
    hasShares?: BoolFieldUpdateOperationsInput | boolean
    hasAgent?: BoolFieldUpdateOperationsInput | boolean
    hasOwner?: BoolFieldUpdateOperationsInput | boolean
    hasController?: BoolFieldUpdateOperationsInput | boolean
    controllerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    agentIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    serviceId?: StringFieldUpdateOperationsInput | string
    form?: ProductFormUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserUpsertWithoutProductRequestInput = {
    update: XOR<UserUpdateWithoutProductRequestInput, UserUncheckedUpdateWithoutProductRequestInput>
    create: XOR<UserCreateWithoutProductRequestInput, UserUncheckedCreateWithoutProductRequestInput>
  }

  export type UserUpdateWithoutProductRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    isStaff?: BoolFieldUpdateOperationsInput | boolean
    isPhoneRegistered?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationRegistered?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationVerified?: BoolFieldUpdateOperationsInput | boolean
    partnerPermission?: UserUpdatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserUpdatestaffPermissionInput | Enumerable<string>
    userPermission?: UserUpdateuserPermissionInput | Enumerable<string>
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMember?: TeamMemberUpdateManyWithoutUserNestedInput
    account?: AccountUpdateManyWithoutUserNestedInput
    document?: UserDocumentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProductRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    isStaff?: BoolFieldUpdateOperationsInput | boolean
    isPhoneRegistered?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationRegistered?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationVerified?: BoolFieldUpdateOperationsInput | boolean
    partnerPermission?: UserUpdatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserUpdatestaffPermissionInput | Enumerable<string>
    userPermission?: UserUpdateuserPermissionInput | Enumerable<string>
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMember?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    account?: AccountUncheckedUpdateManyWithoutUserNestedInput
    document?: UserDocumentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PaymentUpsertWithWhereUniqueWithoutProductRequestsInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutProductRequestsInput, PaymentUncheckedUpdateWithoutProductRequestsInput>
    create: XOR<PaymentCreateWithoutProductRequestsInput, PaymentUncheckedCreateWithoutProductRequestsInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutProductRequestsInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutProductRequestsInput, PaymentUncheckedUpdateWithoutProductRequestsInput>
  }

  export type PaymentUpdateManyWithWhereWithoutProductRequestsInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutPaymentInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: Enumerable<PaymentScalarWhereInput>
    OR?: Enumerable<PaymentScalarWhereInput>
    NOT?: Enumerable<PaymentScalarWhereInput>
    id?: StringFilter | string
    provider?: StringFilter | string
    transactionId?: StringFilter | string
    status?: StringFilter | string
    email?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeprecated?: BoolFilter | boolean
    productRequestId?: StringFilter | string
  }

  export type ProductRequestQAUpsertWithWhereUniqueWithoutRequestInput = {
    where: ProductRequestQAWhereUniqueInput
    update: XOR<ProductRequestQAUpdateWithoutRequestInput, ProductRequestQAUncheckedUpdateWithoutRequestInput>
    create: XOR<ProductRequestQACreateWithoutRequestInput, ProductRequestQAUncheckedCreateWithoutRequestInput>
  }

  export type ProductRequestQAUpdateWithWhereUniqueWithoutRequestInput = {
    where: ProductRequestQAWhereUniqueInput
    data: XOR<ProductRequestQAUpdateWithoutRequestInput, ProductRequestQAUncheckedUpdateWithoutRequestInput>
  }

  export type ProductRequestQAUpdateManyWithWhereWithoutRequestInput = {
    where: ProductRequestQAScalarWhereInput
    data: XOR<ProductRequestQAUpdateManyMutationInput, ProductRequestQAUncheckedUpdateManyWithoutRequestQAInput>
  }

  export type ProductRequestQAScalarWhereInput = {
    AND?: Enumerable<ProductRequestQAScalarWhereInput>
    OR?: Enumerable<ProductRequestQAScalarWhereInput>
    NOT?: Enumerable<ProductRequestQAScalarWhereInput>
    id?: StringFilter | string
    title?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    type?: StringNullableFilter | string | null
    compulsory?: BoolFilter | boolean
    isGeneral?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeprecated?: BoolFilter | boolean
    requestId?: StringFilter | string
  }

  export type ProductRequestCreateWithoutRequestQAInput = {
    id?: string
    email?: string | null
    address?: string | null
    paid?: boolean
    completed?: boolean
    status?: string
    currentState?: ProductActivityStage
    createdAt?: Date | string
    isDeprecated?: boolean
    updatedAt?: Date | string
    Team?: TeamCreateNestedManyWithoutProductRequestInput
    product?: ProductCreateNestedOneWithoutRequestInput
    user: UserCreateNestedOneWithoutProductRequestInput
    Payment?: PaymentCreateNestedManyWithoutProductRequestsInput
  }

  export type ProductRequestUncheckedCreateWithoutRequestQAInput = {
    id?: string
    email?: string | null
    address?: string | null
    paid?: boolean
    completed?: boolean
    status?: string
    currentState?: ProductActivityStage
    createdAt?: Date | string
    isDeprecated?: boolean
    updatedAt?: Date | string
    productId?: string | null
    userId: string
    Team?: TeamUncheckedCreateNestedManyWithoutProductRequestInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutProductRequestsInput
  }

  export type ProductRequestCreateOrConnectWithoutRequestQAInput = {
    where: ProductRequestWhereUniqueInput
    create: XOR<ProductRequestCreateWithoutRequestQAInput, ProductRequestUncheckedCreateWithoutRequestQAInput>
  }

  export type ProductRequestQASubFormCreateWithoutRequestQAInput = {
    id?: string
    question?: string | null
    answer?: ProductRequestQASubFormCreateanswerInput | Enumerable<string>
    type?: string | null
    fileName?: string | null
    fileType?: string | null
    fileLink?: string | null
    fileSize?: string | null
    compulsory?: boolean
    isDeprecated?: boolean
  }

  export type ProductRequestQASubFormUncheckedCreateWithoutRequestQAInput = {
    id?: string
    question?: string | null
    answer?: ProductRequestQASubFormCreateanswerInput | Enumerable<string>
    type?: string | null
    fileName?: string | null
    fileType?: string | null
    fileLink?: string | null
    fileSize?: string | null
    compulsory?: boolean
    isDeprecated?: boolean
  }

  export type ProductRequestQASubFormCreateOrConnectWithoutRequestQAInput = {
    where: ProductRequestQASubFormWhereUniqueInput
    create: XOR<ProductRequestQASubFormCreateWithoutRequestQAInput, ProductRequestQASubFormUncheckedCreateWithoutRequestQAInput>
  }

  export type ProductRequestQASubFormCreateManyRequestQAInputEnvelope = {
    data: Enumerable<ProductRequestQASubFormCreateManyRequestQAInput>
    skipDuplicates?: boolean
  }

  export type ProductRequestUpsertWithoutRequestQAInput = {
    update: XOR<ProductRequestUpdateWithoutRequestQAInput, ProductRequestUncheckedUpdateWithoutRequestQAInput>
    create: XOR<ProductRequestCreateWithoutRequestQAInput, ProductRequestUncheckedCreateWithoutRequestQAInput>
  }

  export type ProductRequestUpdateWithoutRequestQAInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    currentState?: EnumProductActivityStageFieldUpdateOperationsInput | ProductActivityStage
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Team?: TeamUpdateManyWithoutProductRequestNestedInput
    product?: ProductUpdateOneWithoutRequestNestedInput
    user?: UserUpdateOneRequiredWithoutProductRequestNestedInput
    Payment?: PaymentUpdateManyWithoutProductRequestsNestedInput
  }

  export type ProductRequestUncheckedUpdateWithoutRequestQAInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    currentState?: EnumProductActivityStageFieldUpdateOperationsInput | ProductActivityStage
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    Team?: TeamUncheckedUpdateManyWithoutProductRequestNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutProductRequestsNestedInput
  }

  export type ProductRequestQASubFormUpsertWithWhereUniqueWithoutRequestQAInput = {
    where: ProductRequestQASubFormWhereUniqueInput
    update: XOR<ProductRequestQASubFormUpdateWithoutRequestQAInput, ProductRequestQASubFormUncheckedUpdateWithoutRequestQAInput>
    create: XOR<ProductRequestQASubFormCreateWithoutRequestQAInput, ProductRequestQASubFormUncheckedCreateWithoutRequestQAInput>
  }

  export type ProductRequestQASubFormUpdateWithWhereUniqueWithoutRequestQAInput = {
    where: ProductRequestQASubFormWhereUniqueInput
    data: XOR<ProductRequestQASubFormUpdateWithoutRequestQAInput, ProductRequestQASubFormUncheckedUpdateWithoutRequestQAInput>
  }

  export type ProductRequestQASubFormUpdateManyWithWhereWithoutRequestQAInput = {
    where: ProductRequestQASubFormScalarWhereInput
    data: XOR<ProductRequestQASubFormUpdateManyMutationInput, ProductRequestQASubFormUncheckedUpdateManyWithoutSubFormInput>
  }

  export type ProductRequestQASubFormScalarWhereInput = {
    AND?: Enumerable<ProductRequestQASubFormScalarWhereInput>
    OR?: Enumerable<ProductRequestQASubFormScalarWhereInput>
    NOT?: Enumerable<ProductRequestQASubFormScalarWhereInput>
    id?: StringFilter | string
    question?: StringNullableFilter | string | null
    answer?: StringNullableListFilter
    type?: StringNullableFilter | string | null
    fileName?: StringNullableFilter | string | null
    fileType?: StringNullableFilter | string | null
    fileLink?: StringNullableFilter | string | null
    fileSize?: StringNullableFilter | string | null
    compulsory?: BoolFilter | boolean
    isDeprecated?: BoolFilter | boolean
    requestQAId?: StringFilter | string
  }

  export type ProductRequestQACreateWithoutSubFormInput = {
    id?: string
    title?: string | null
    description?: string | null
    type?: string | null
    compulsory?: boolean
    isGeneral?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    request: ProductRequestCreateNestedOneWithoutRequestQAInput
  }

  export type ProductRequestQAUncheckedCreateWithoutSubFormInput = {
    id?: string
    title?: string | null
    description?: string | null
    type?: string | null
    compulsory?: boolean
    isGeneral?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    requestId: string
  }

  export type ProductRequestQACreateOrConnectWithoutSubFormInput = {
    where: ProductRequestQAWhereUniqueInput
    create: XOR<ProductRequestQACreateWithoutSubFormInput, ProductRequestQAUncheckedCreateWithoutSubFormInput>
  }

  export type ProductRequestQAUpsertWithoutSubFormInput = {
    update: XOR<ProductRequestQAUpdateWithoutSubFormInput, ProductRequestQAUncheckedUpdateWithoutSubFormInput>
    create: XOR<ProductRequestQACreateWithoutSubFormInput, ProductRequestQAUncheckedCreateWithoutSubFormInput>
  }

  export type ProductRequestQAUpdateWithoutSubFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    isGeneral?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    request?: ProductRequestUpdateOneRequiredWithoutRequestQANestedInput
  }

  export type ProductRequestQAUncheckedUpdateWithoutSubFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    isGeneral?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    requestId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductRequestCreateWithoutTeamInput = {
    id?: string
    email?: string | null
    address?: string | null
    paid?: boolean
    completed?: boolean
    status?: string
    currentState?: ProductActivityStage
    createdAt?: Date | string
    isDeprecated?: boolean
    updatedAt?: Date | string
    product?: ProductCreateNestedOneWithoutRequestInput
    user: UserCreateNestedOneWithoutProductRequestInput
    Payment?: PaymentCreateNestedManyWithoutProductRequestsInput
    requestQA?: ProductRequestQACreateNestedManyWithoutRequestInput
  }

  export type ProductRequestUncheckedCreateWithoutTeamInput = {
    id?: string
    email?: string | null
    address?: string | null
    paid?: boolean
    completed?: boolean
    status?: string
    currentState?: ProductActivityStage
    createdAt?: Date | string
    isDeprecated?: boolean
    updatedAt?: Date | string
    productId?: string | null
    userId: string
    Payment?: PaymentUncheckedCreateNestedManyWithoutProductRequestsInput
    requestQA?: ProductRequestQAUncheckedCreateNestedManyWithoutRequestInput
  }

  export type ProductRequestCreateOrConnectWithoutTeamInput = {
    where: ProductRequestWhereUniqueInput
    create: XOR<ProductRequestCreateWithoutTeamInput, ProductRequestUncheckedCreateWithoutTeamInput>
  }

  export type InvitationCreateWithoutTeamInput = {
    id?: string
    email: string
    token: string
    expireIn: Date | string
    invitedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
  }

  export type InvitationUncheckedCreateWithoutTeamInput = {
    id?: string
    email: string
    token: string
    expireIn: Date | string
    invitedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
  }

  export type InvitationCreateOrConnectWithoutTeamInput = {
    where: InvitationWhereUniqueInput
    create: XOR<InvitationCreateWithoutTeamInput, InvitationUncheckedCreateWithoutTeamInput>
  }

  export type InvitationCreateManyTeamInputEnvelope = {
    data: Enumerable<InvitationCreateManyTeamInput>
    skipDuplicates?: boolean
  }

  export type TeamMemberCreateWithoutTeamInput = {
    id?: string
    isLaunchMember: boolean
    isLaunchController: boolean
    isLaunchOwner: boolean
    launchOwnership: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    user: UserCreateNestedOneWithoutTeamMemberInput
  }

  export type TeamMemberUncheckedCreateWithoutTeamInput = {
    id?: string
    isLaunchMember: boolean
    isLaunchController: boolean
    isLaunchOwner: boolean
    launchOwnership: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
  }

  export type TeamMemberCreateOrConnectWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    create: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
  }

  export type TeamMemberCreateManyTeamInputEnvelope = {
    data: Enumerable<TeamMemberCreateManyTeamInput>
    skipDuplicates?: boolean
  }

  export type ProductRequestUpsertWithoutTeamInput = {
    update: XOR<ProductRequestUpdateWithoutTeamInput, ProductRequestUncheckedUpdateWithoutTeamInput>
    create: XOR<ProductRequestCreateWithoutTeamInput, ProductRequestUncheckedCreateWithoutTeamInput>
  }

  export type ProductRequestUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    currentState?: EnumProductActivityStageFieldUpdateOperationsInput | ProductActivityStage
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneWithoutRequestNestedInput
    user?: UserUpdateOneRequiredWithoutProductRequestNestedInput
    Payment?: PaymentUpdateManyWithoutProductRequestsNestedInput
    requestQA?: ProductRequestQAUpdateManyWithoutRequestNestedInput
  }

  export type ProductRequestUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    currentState?: EnumProductActivityStageFieldUpdateOperationsInput | ProductActivityStage
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    Payment?: PaymentUncheckedUpdateManyWithoutProductRequestsNestedInput
    requestQA?: ProductRequestQAUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type InvitationUpsertWithWhereUniqueWithoutTeamInput = {
    where: InvitationWhereUniqueInput
    update: XOR<InvitationUpdateWithoutTeamInput, InvitationUncheckedUpdateWithoutTeamInput>
    create: XOR<InvitationCreateWithoutTeamInput, InvitationUncheckedCreateWithoutTeamInput>
  }

  export type InvitationUpdateWithWhereUniqueWithoutTeamInput = {
    where: InvitationWhereUniqueInput
    data: XOR<InvitationUpdateWithoutTeamInput, InvitationUncheckedUpdateWithoutTeamInput>
  }

  export type InvitationUpdateManyWithWhereWithoutTeamInput = {
    where: InvitationScalarWhereInput
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyWithoutInvitationInput>
  }

  export type InvitationScalarWhereInput = {
    AND?: Enumerable<InvitationScalarWhereInput>
    OR?: Enumerable<InvitationScalarWhereInput>
    NOT?: Enumerable<InvitationScalarWhereInput>
    id?: StringFilter | string
    teamId?: StringFilter | string
    email?: StringFilter | string
    token?: StringFilter | string
    expireIn?: DateTimeFilter | Date | string
    invitedBy?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeprecated?: BoolFilter | boolean
  }

  export type TeamMemberUpsertWithWhereUniqueWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    update: XOR<TeamMemberUpdateWithoutTeamInput, TeamMemberUncheckedUpdateWithoutTeamInput>
    create: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
  }

  export type TeamMemberUpdateWithWhereUniqueWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    data: XOR<TeamMemberUpdateWithoutTeamInput, TeamMemberUncheckedUpdateWithoutTeamInput>
  }

  export type TeamMemberUpdateManyWithWhereWithoutTeamInput = {
    where: TeamMemberScalarWhereInput
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyWithoutTeamMemberInput>
  }

  export type TeamCreateWithoutTeamMemberInput = {
    id?: string
    name: string
    slug: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    productRequest: ProductRequestCreateNestedOneWithoutTeamInput
    invitation?: InvitationCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutTeamMemberInput = {
    id?: string
    name: string
    slug: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    productRequestId: string
    invitation?: InvitationUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutTeamMemberInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutTeamMemberInput, TeamUncheckedCreateWithoutTeamMemberInput>
  }

  export type UserCreateWithoutTeamMemberInput = {
    id?: string
    fullName: string
    username?: string | null
    email: string
    password?: string | null
    googleId?: string | null
    phone?: string | null
    picture?: string | null
    isVerified?: boolean
    referral?: string | null
    country?: string | null
    resetToken?: string | null
    isPartner?: boolean
    isStaff?: boolean
    isPhoneRegistered?: boolean
    isPhoneVerified?: boolean
    isIdentificationRegistered?: boolean
    isIdentificationVerified?: boolean
    partnerPermission?: UserCreatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserCreatestaffPermissionInput | Enumerable<string>
    userPermission?: UserCreateuserPermissionInput | Enumerable<string>
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    account?: AccountCreateNestedManyWithoutUserInput
    productRequest?: ProductRequestCreateNestedManyWithoutUserInput
    document?: UserDocumentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTeamMemberInput = {
    id?: string
    fullName: string
    username?: string | null
    email: string
    password?: string | null
    googleId?: string | null
    phone?: string | null
    picture?: string | null
    isVerified?: boolean
    referral?: string | null
    country?: string | null
    resetToken?: string | null
    isPartner?: boolean
    isStaff?: boolean
    isPhoneRegistered?: boolean
    isPhoneVerified?: boolean
    isIdentificationRegistered?: boolean
    isIdentificationVerified?: boolean
    partnerPermission?: UserCreatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserCreatestaffPermissionInput | Enumerable<string>
    userPermission?: UserCreateuserPermissionInput | Enumerable<string>
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    account?: AccountUncheckedCreateNestedManyWithoutUserInput
    productRequest?: ProductRequestUncheckedCreateNestedManyWithoutUserInput
    document?: UserDocumentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTeamMemberInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeamMemberInput, UserUncheckedCreateWithoutTeamMemberInput>
  }

  export type TeamUpsertWithoutTeamMemberInput = {
    update: XOR<TeamUpdateWithoutTeamMemberInput, TeamUncheckedUpdateWithoutTeamMemberInput>
    create: XOR<TeamCreateWithoutTeamMemberInput, TeamUncheckedCreateWithoutTeamMemberInput>
  }

  export type TeamUpdateWithoutTeamMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    productRequest?: ProductRequestUpdateOneRequiredWithoutTeamNestedInput
    invitation?: InvitationUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutTeamMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    productRequestId?: StringFieldUpdateOperationsInput | string
    invitation?: InvitationUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type UserUpsertWithoutTeamMemberInput = {
    update: XOR<UserUpdateWithoutTeamMemberInput, UserUncheckedUpdateWithoutTeamMemberInput>
    create: XOR<UserCreateWithoutTeamMemberInput, UserUncheckedCreateWithoutTeamMemberInput>
  }

  export type UserUpdateWithoutTeamMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    isStaff?: BoolFieldUpdateOperationsInput | boolean
    isPhoneRegistered?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationRegistered?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationVerified?: BoolFieldUpdateOperationsInput | boolean
    partnerPermission?: UserUpdatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserUpdatestaffPermissionInput | Enumerable<string>
    userPermission?: UserUpdateuserPermissionInput | Enumerable<string>
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateManyWithoutUserNestedInput
    productRequest?: ProductRequestUpdateManyWithoutUserNestedInput
    document?: UserDocumentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTeamMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    referral?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    isStaff?: BoolFieldUpdateOperationsInput | boolean
    isPhoneRegistered?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationRegistered?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationVerified?: BoolFieldUpdateOperationsInput | boolean
    partnerPermission?: UserUpdatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserUpdatestaffPermissionInput | Enumerable<string>
    userPermission?: UserUpdateuserPermissionInput | Enumerable<string>
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUncheckedUpdateManyWithoutUserNestedInput
    productRequest?: ProductRequestUncheckedUpdateManyWithoutUserNestedInput
    document?: UserDocumentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TeamCreateWithoutInvitationInput = {
    id?: string
    name: string
    slug: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    productRequest: ProductRequestCreateNestedOneWithoutTeamInput
    teamMember?: TeamMemberCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutInvitationInput = {
    id?: string
    name: string
    slug: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
    productRequestId: string
    teamMember?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutInvitationInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutInvitationInput, TeamUncheckedCreateWithoutInvitationInput>
  }

  export type TeamUpsertWithoutInvitationInput = {
    update: XOR<TeamUpdateWithoutInvitationInput, TeamUncheckedUpdateWithoutInvitationInput>
    create: XOR<TeamCreateWithoutInvitationInput, TeamUncheckedCreateWithoutInvitationInput>
  }

  export type TeamUpdateWithoutInvitationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    productRequest?: ProductRequestUpdateOneRequiredWithoutTeamNestedInput
    teamMember?: TeamMemberUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutInvitationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    productRequestId?: StringFieldUpdateOperationsInput | string
    teamMember?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type ProductRequestCreateWithoutPaymentInput = {
    id?: string
    email?: string | null
    address?: string | null
    paid?: boolean
    completed?: boolean
    status?: string
    currentState?: ProductActivityStage
    createdAt?: Date | string
    isDeprecated?: boolean
    updatedAt?: Date | string
    Team?: TeamCreateNestedManyWithoutProductRequestInput
    product?: ProductCreateNestedOneWithoutRequestInput
    user: UserCreateNestedOneWithoutProductRequestInput
    requestQA?: ProductRequestQACreateNestedManyWithoutRequestInput
  }

  export type ProductRequestUncheckedCreateWithoutPaymentInput = {
    id?: string
    email?: string | null
    address?: string | null
    paid?: boolean
    completed?: boolean
    status?: string
    currentState?: ProductActivityStage
    createdAt?: Date | string
    isDeprecated?: boolean
    updatedAt?: Date | string
    productId?: string | null
    userId: string
    Team?: TeamUncheckedCreateNestedManyWithoutProductRequestInput
    requestQA?: ProductRequestQAUncheckedCreateNestedManyWithoutRequestInput
  }

  export type ProductRequestCreateOrConnectWithoutPaymentInput = {
    where: ProductRequestWhereUniqueInput
    create: XOR<ProductRequestCreateWithoutPaymentInput, ProductRequestUncheckedCreateWithoutPaymentInput>
  }

  export type ProductRequestUpsertWithoutPaymentInput = {
    update: XOR<ProductRequestUpdateWithoutPaymentInput, ProductRequestUncheckedUpdateWithoutPaymentInput>
    create: XOR<ProductRequestCreateWithoutPaymentInput, ProductRequestUncheckedCreateWithoutPaymentInput>
  }

  export type ProductRequestUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    currentState?: EnumProductActivityStageFieldUpdateOperationsInput | ProductActivityStage
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Team?: TeamUpdateManyWithoutProductRequestNestedInput
    product?: ProductUpdateOneWithoutRequestNestedInput
    user?: UserUpdateOneRequiredWithoutProductRequestNestedInput
    requestQA?: ProductRequestQAUpdateManyWithoutRequestNestedInput
  }

  export type ProductRequestUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    currentState?: EnumProductActivityStageFieldUpdateOperationsInput | ProductActivityStage
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    Team?: TeamUncheckedUpdateManyWithoutProductRequestNestedInput
    requestQA?: ProductRequestQAUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type CollaboratorDocumentCreateManyCollaboratorInput = {
    id?: string
    name: string
    type: string
    description: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CollaboratorDocumentUpdateWithoutCollaboratorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollaboratorDocumentUncheckedUpdateWithoutCollaboratorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollaboratorDocumentUncheckedUpdateManyWithoutCollaboratorDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberCreateManyUserInput = {
    id?: string
    isLaunchMember: boolean
    isLaunchController: boolean
    isLaunchOwner: boolean
    launchOwnership: number
    teamId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    scope: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductRequestCreateManyUserInput = {
    id?: string
    email?: string | null
    address?: string | null
    paid?: boolean
    completed?: boolean
    status?: string
    currentState?: ProductActivityStage
    createdAt?: Date | string
    isDeprecated?: boolean
    updatedAt?: Date | string
    productId?: string | null
  }

  export type UserDocumentCreateManyUserInput = {
    id?: string
    name?: string | null
    type?: string | null
    link?: string | null
    size?: string | null
    belongsTo?: string | null
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isLaunchMember?: BoolFieldUpdateOperationsInput | boolean
    isLaunchController?: BoolFieldUpdateOperationsInput | boolean
    isLaunchOwner?: BoolFieldUpdateOperationsInput | boolean
    launchOwnership?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    team?: TeamUpdateOneRequiredWithoutTeamMemberNestedInput
  }

  export type TeamMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isLaunchMember?: BoolFieldUpdateOperationsInput | boolean
    isLaunchController?: BoolFieldUpdateOperationsInput | boolean
    isLaunchOwner?: BoolFieldUpdateOperationsInput | boolean
    launchOwnership?: IntFieldUpdateOperationsInput | number
    teamId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TeamMemberUncheckedUpdateManyWithoutTeamMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    isLaunchMember?: BoolFieldUpdateOperationsInput | boolean
    isLaunchController?: BoolFieldUpdateOperationsInput | boolean
    isLaunchOwner?: BoolFieldUpdateOperationsInput | boolean
    launchOwnership?: IntFieldUpdateOperationsInput | number
    teamId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductRequestUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    currentState?: EnumProductActivityStageFieldUpdateOperationsInput | ProductActivityStage
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Team?: TeamUpdateManyWithoutProductRequestNestedInput
    product?: ProductUpdateOneWithoutRequestNestedInput
    Payment?: PaymentUpdateManyWithoutProductRequestsNestedInput
    requestQA?: ProductRequestQAUpdateManyWithoutRequestNestedInput
  }

  export type ProductRequestUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    currentState?: EnumProductActivityStageFieldUpdateOperationsInput | ProductActivityStage
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    Team?: TeamUncheckedUpdateManyWithoutProductRequestNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutProductRequestsNestedInput
    requestQA?: ProductRequestQAUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type ProductRequestUncheckedUpdateManyWithoutProductRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    currentState?: EnumProductActivityStageFieldUpdateOperationsInput | ProductActivityStage
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserDocumentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    belongsTo?: NullableStringFieldUpdateOperationsInput | string | null
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserDocumentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    belongsTo?: NullableStringFieldUpdateOperationsInput | string | null
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserDocumentUncheckedUpdateManyWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    belongsTo?: NullableStringFieldUpdateOperationsInput | string | null
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyServiceInput = {
    id?: string
    name: string
    description: string
    country: string
    currency: string
    amount: number
    timeline: string
    feature?: ProductCreatefeatureInput | Enumerable<string>
    canAlsoDo?: ProductCreatecanAlsoDoInput | Enumerable<string>
    hasShares?: boolean
    hasAgent?: boolean
    hasOwner?: boolean
    hasController?: boolean
    controllerIsCalled?: string | null
    OwnerIsCalled?: string | null
    agentIsCalled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
  }

  export type ServiceFormCreateManyServiceInput = {
    id?: string
    title?: string | null
    description?: string | null
    type?: string | null
    compulsory?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
  }

  export type ProductUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    timeline?: StringFieldUpdateOperationsInput | string
    feature?: ProductUpdatefeatureInput | Enumerable<string>
    canAlsoDo?: ProductUpdatecanAlsoDoInput | Enumerable<string>
    hasShares?: BoolFieldUpdateOperationsInput | boolean
    hasAgent?: BoolFieldUpdateOperationsInput | boolean
    hasOwner?: BoolFieldUpdateOperationsInput | boolean
    hasController?: BoolFieldUpdateOperationsInput | boolean
    controllerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    agentIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    request?: ProductRequestUpdateManyWithoutProductNestedInput
    form?: ProductFormUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    timeline?: StringFieldUpdateOperationsInput | string
    feature?: ProductUpdatefeatureInput | Enumerable<string>
    canAlsoDo?: ProductUpdatecanAlsoDoInput | Enumerable<string>
    hasShares?: BoolFieldUpdateOperationsInput | boolean
    hasAgent?: BoolFieldUpdateOperationsInput | boolean
    hasOwner?: BoolFieldUpdateOperationsInput | boolean
    hasController?: BoolFieldUpdateOperationsInput | boolean
    controllerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    agentIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    request?: ProductRequestUncheckedUpdateManyWithoutProductNestedInput
    form?: ProductFormUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    timeline?: StringFieldUpdateOperationsInput | string
    feature?: ProductUpdatefeatureInput | Enumerable<string>
    canAlsoDo?: ProductUpdatecanAlsoDoInput | Enumerable<string>
    hasShares?: BoolFieldUpdateOperationsInput | boolean
    hasAgent?: BoolFieldUpdateOperationsInput | boolean
    hasOwner?: BoolFieldUpdateOperationsInput | boolean
    hasController?: BoolFieldUpdateOperationsInput | boolean
    controllerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    agentIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ServiceFormUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    subForm?: ServiceSubFormUpdateManyWithoutFormNestedInput
  }

  export type ServiceFormUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    subForm?: ServiceSubFormUncheckedUpdateManyWithoutFormNestedInput
  }

  export type ServiceFormUncheckedUpdateManyWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ServiceSubFormCreateManyFormInput = {
    id?: string
    question?: string | null
    type?: string | null
    options?: ServiceSubFormCreateoptionsInput | Enumerable<string>
    fileName?: string | null
    fileType?: string | null
    fileLink?: string | null
    fileSize?: string | null
    dependentField?: string | null
    dependentOptions?: ServiceSubFormCreatedependentOptionsInput | Enumerable<string>
    documentType?: string | null
    allowOther?: boolean
    compulsory?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
  }

  export type ServiceSubFormUpdateWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    options?: ServiceSubFormUpdateoptionsInput | Enumerable<string>
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileLink?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableStringFieldUpdateOperationsInput | string | null
    dependentField?: NullableStringFieldUpdateOperationsInput | string | null
    dependentOptions?: ServiceSubFormUpdatedependentOptionsInput | Enumerable<string>
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    allowOther?: BoolFieldUpdateOperationsInput | boolean
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ServiceSubFormUncheckedUpdateWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    options?: ServiceSubFormUpdateoptionsInput | Enumerable<string>
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileLink?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableStringFieldUpdateOperationsInput | string | null
    dependentField?: NullableStringFieldUpdateOperationsInput | string | null
    dependentOptions?: ServiceSubFormUpdatedependentOptionsInput | Enumerable<string>
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    allowOther?: BoolFieldUpdateOperationsInput | boolean
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ServiceSubFormUncheckedUpdateManyWithoutSubFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    options?: ServiceSubFormUpdateoptionsInput | Enumerable<string>
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileLink?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableStringFieldUpdateOperationsInput | string | null
    dependentField?: NullableStringFieldUpdateOperationsInput | string | null
    dependentOptions?: ServiceSubFormUpdatedependentOptionsInput | Enumerable<string>
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    allowOther?: BoolFieldUpdateOperationsInput | boolean
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductRequestCreateManyProductInput = {
    id?: string
    email?: string | null
    address?: string | null
    paid?: boolean
    completed?: boolean
    status?: string
    currentState?: ProductActivityStage
    createdAt?: Date | string
    isDeprecated?: boolean
    updatedAt?: Date | string
    userId: string
  }

  export type ProductFormCreateManyProductInput = {
    id?: string
    title?: string | null
    type?: string | null
    description?: string | null
    compulsory?: boolean
    createdAt?: Date | string
    isDeprecated?: boolean
    updatedAt?: Date | string
  }

  export type ProductRequestUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    currentState?: EnumProductActivityStageFieldUpdateOperationsInput | ProductActivityStage
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Team?: TeamUpdateManyWithoutProductRequestNestedInput
    user?: UserUpdateOneRequiredWithoutProductRequestNestedInput
    Payment?: PaymentUpdateManyWithoutProductRequestsNestedInput
    requestQA?: ProductRequestQAUpdateManyWithoutRequestNestedInput
  }

  export type ProductRequestUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    currentState?: EnumProductActivityStageFieldUpdateOperationsInput | ProductActivityStage
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    Team?: TeamUncheckedUpdateManyWithoutProductRequestNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutProductRequestsNestedInput
    requestQA?: ProductRequestQAUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type ProductRequestUncheckedUpdateManyWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    currentState?: EnumProductActivityStageFieldUpdateOperationsInput | ProductActivityStage
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductFormUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productSubForm?: ProductSubFormUpdateManyWithoutFormNestedInput
  }

  export type ProductFormUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productSubForm?: ProductSubFormUncheckedUpdateManyWithoutFormNestedInput
  }

  export type ProductFormUncheckedUpdateManyWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductSubFormCreateManyFormInput = {
    id?: string
    question?: string | null
    options?: ProductSubFormCreateoptionsInput | Enumerable<string>
    type?: string | null
    allowOther?: boolean
    dependentField?: string | null
    dependentOptions?: ProductSubFormCreatedependentOptionsInput | Enumerable<string>
    fileName?: string | null
    fileType?: string | null
    fileLink?: string | null
    fileSize?: string | null
    documentType?: string | null
    compulsory?: boolean
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductSubFormUpdateWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: NullableStringFieldUpdateOperationsInput | string | null
    options?: ProductSubFormUpdateoptionsInput | Enumerable<string>
    type?: NullableStringFieldUpdateOperationsInput | string | null
    allowOther?: BoolFieldUpdateOperationsInput | boolean
    dependentField?: NullableStringFieldUpdateOperationsInput | string | null
    dependentOptions?: ProductSubFormUpdatedependentOptionsInput | Enumerable<string>
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileLink?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductSubFormUncheckedUpdateWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: NullableStringFieldUpdateOperationsInput | string | null
    options?: ProductSubFormUpdateoptionsInput | Enumerable<string>
    type?: NullableStringFieldUpdateOperationsInput | string | null
    allowOther?: BoolFieldUpdateOperationsInput | boolean
    dependentField?: NullableStringFieldUpdateOperationsInput | string | null
    dependentOptions?: ProductSubFormUpdatedependentOptionsInput | Enumerable<string>
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileLink?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductSubFormUncheckedUpdateManyWithoutProductSubFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: NullableStringFieldUpdateOperationsInput | string | null
    options?: ProductSubFormUpdateoptionsInput | Enumerable<string>
    type?: NullableStringFieldUpdateOperationsInput | string | null
    allowOther?: BoolFieldUpdateOperationsInput | boolean
    dependentField?: NullableStringFieldUpdateOperationsInput | string | null
    dependentOptions?: ProductSubFormUpdatedependentOptionsInput | Enumerable<string>
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileLink?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamCreateManyProductRequestInput = {
    id?: string
    name: string
    slug: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
  }

  export type PaymentCreateManyProductRequestsInput = {
    id?: string
    provider: string
    transactionId: string
    status: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
  }

  export type ProductRequestQACreateManyRequestInput = {
    id?: string
    title?: string | null
    description?: string | null
    type?: string | null
    compulsory?: boolean
    isGeneral?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
  }

  export type TeamUpdateWithoutProductRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    invitation?: InvitationUpdateManyWithoutTeamNestedInput
    teamMember?: TeamMemberUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutProductRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    invitation?: InvitationUncheckedUpdateManyWithoutTeamNestedInput
    teamMember?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PaymentUpdateWithoutProductRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PaymentUncheckedUpdateWithoutProductRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PaymentUncheckedUpdateManyWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductRequestQAUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    isGeneral?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    subForm?: ProductRequestQASubFormUpdateManyWithoutRequestQANestedInput
  }

  export type ProductRequestQAUncheckedUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    isGeneral?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    subForm?: ProductRequestQASubFormUncheckedUpdateManyWithoutRequestQANestedInput
  }

  export type ProductRequestQAUncheckedUpdateManyWithoutRequestQAInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    isGeneral?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductRequestQASubFormCreateManyRequestQAInput = {
    id?: string
    question?: string | null
    answer?: ProductRequestQASubFormCreateanswerInput | Enumerable<string>
    type?: string | null
    fileName?: string | null
    fileType?: string | null
    fileLink?: string | null
    fileSize?: string | null
    compulsory?: boolean
    isDeprecated?: boolean
  }

  export type ProductRequestQASubFormUpdateWithoutRequestQAInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: NullableStringFieldUpdateOperationsInput | string | null
    answer?: ProductRequestQASubFormUpdateanswerInput | Enumerable<string>
    type?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileLink?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableStringFieldUpdateOperationsInput | string | null
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductRequestQASubFormUncheckedUpdateWithoutRequestQAInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: NullableStringFieldUpdateOperationsInput | string | null
    answer?: ProductRequestQASubFormUpdateanswerInput | Enumerable<string>
    type?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileLink?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableStringFieldUpdateOperationsInput | string | null
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductRequestQASubFormUncheckedUpdateManyWithoutSubFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: NullableStringFieldUpdateOperationsInput | string | null
    answer?: ProductRequestQASubFormUpdateanswerInput | Enumerable<string>
    type?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileLink?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableStringFieldUpdateOperationsInput | string | null
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvitationCreateManyTeamInput = {
    id?: string
    email: string
    token: string
    expireIn: Date | string
    invitedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
  }

  export type TeamMemberCreateManyTeamInput = {
    id?: string
    isLaunchMember: boolean
    isLaunchController: boolean
    isLaunchOwner: boolean
    launchOwnership: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeprecated?: boolean
  }

  export type InvitationUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expireIn?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvitationUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expireIn?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvitationUncheckedUpdateManyWithoutInvitationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expireIn?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TeamMemberUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    isLaunchMember?: BoolFieldUpdateOperationsInput | boolean
    isLaunchController?: BoolFieldUpdateOperationsInput | boolean
    isLaunchOwner?: BoolFieldUpdateOperationsInput | boolean
    launchOwnership?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutTeamMemberNestedInput
  }

  export type TeamMemberUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    isLaunchMember?: BoolFieldUpdateOperationsInput | boolean
    isLaunchController?: BoolFieldUpdateOperationsInput | boolean
    isLaunchOwner?: BoolFieldUpdateOperationsInput | boolean
    launchOwnership?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}
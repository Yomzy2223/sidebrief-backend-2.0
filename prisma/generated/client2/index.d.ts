
/**
 * Client
**/

import * as runtime from './runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions

export type PrismaPromise<T> = $Public.PrismaPromise<T>


export type StaffPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Staff"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    firstName: string
    lastName: string
    email: string
    password: string
    phone: string
    verified: boolean
    picture: string | null
    resetToken: string | null
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["staff"]>
  composites: {}
}

/**
 * Model Staff
 * 
 */
export type Staff = runtime.Types.DefaultSelection<StaffPayload>
export type CollaboratorPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Collaborator"
  objects: {
    collaboratorDocument: CollaboratorDocumentPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    firstName: string
    lastName: string
    email: string
    password: string
    phone: string
    picture: string | null
    verified: boolean
    isPartner: boolean
    resetToken: string | null
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["collaborator"]>
  composites: {}
}

/**
 * Model Collaborator
 * 
 */
export type Collaborator = runtime.Types.DefaultSelection<CollaboratorPayload>
export type CollaboratorDocumentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "CollaboratorDocument"
  objects: {
    collaborator: CollaboratorPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    type: string
    description: string
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
    collaboratorId: string
  }, ExtArgs["result"]["collaboratorDocument"]>
  composites: {}
}

/**
 * Model CollaboratorDocument
 * 
 */
export type CollaboratorDocument = runtime.Types.DefaultSelection<CollaboratorDocumentPayload>
export type RewardPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Reward"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    url: string
    descrition: string
    image: string
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["reward"]>
  composites: {}
}

/**
 * Model Reward
 * 
 */
export type Reward = runtime.Types.DefaultSelection<RewardPayload>
export type CountryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Country"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    iso: string
    currency: string
    code: string
    flagUrl: string
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["country"]>
  composites: {}
}

/**
 * Model Country
 * 
 */
export type Country = runtime.Types.DefaultSelection<CountryPayload>
export type BankPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Bank"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    code: string
    url: string
    image: string
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["bank"]>
  composites: {}
}

/**
 * Model Bank
 * 
 */
export type Bank = runtime.Types.DefaultSelection<BankPayload>
export type NotificationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Notification"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    title: string
    body: string
    readStatus: boolean
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["notification"]>
  composites: {}
}

/**
 * Model Notification
 * 
 */
export type Notification = runtime.Types.DefaultSelection<NotificationPayload>
export type AccountPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Account"
  objects: {
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    userId: string
    type: string
    provider: string
    scope: string
  }, ExtArgs["result"]["account"]>
  composites: {}
}

/**
 * Model Account
 * 
 */
export type Account = runtime.Types.DefaultSelection<AccountPayload>
export type UserPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "User"
  objects: {
    teamMember: TeamMemberPayload<ExtArgs>[]
    account: AccountPayload<ExtArgs>[]
    product: ProductPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    fullName: string
    username: string | null
    email: string
    password: string
    phone: string | null
    picture: string | null
    isVerified: boolean
    referral: string
    country: string | null
    resetToken: string | null
    isPartner: boolean
    isStaff: boolean
    isPhoneRegistered: boolean
    isPhoneVerified: boolean
    isIdentificationRegistered: boolean
    isIdentificationVerified: boolean
    partnerPermission: string[]
    staffPermission: string[]
    userPermission: string[]
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["user"]>
  composites: {}
}

/**
 * Model User
 * 
 */
export type User = runtime.Types.DefaultSelection<UserPayload>
export type UserDocumentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "UserDocument"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    type: string
    description: string
    userId: string
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["userDocument"]>
  composites: {}
}

/**
 * Model UserDocument
 * 
 */
export type UserDocument = runtime.Types.DefaultSelection<UserDocumentPayload>
export type ServiceCategoryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ServiceCategory"
  objects: {
    services: ServicePayload<ExtArgs>[]
    form: ServiceCategoryFormPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    description: string
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["serviceCategory"]>
  composites: {}
}

/**
 * Model ServiceCategory
 * 
 */
export type ServiceCategory = runtime.Types.DefaultSelection<ServiceCategoryPayload>
export type ServiceCategoryFormPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ServiceCategoryForm"
  objects: {
    category: ServiceCategoryPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    question: string
    type: string
    options: string[]
    compulsory: boolean
    createdAt: Date
    updatedAt: Date
    serviceCategoryId: string
  }, ExtArgs["result"]["serviceCategoryForm"]>
  composites: {}
}

/**
 * Model ServiceCategoryForm
 * 
 */
export type ServiceCategoryForm = runtime.Types.DefaultSelection<ServiceCategoryFormPayload>
export type ServicePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Service"
  objects: {
    category: ServiceCategoryPayload<ExtArgs>
    products: ProductPayload<ExtArgs>[]
    templates: ServiceTemplatePayload<ExtArgs>[]
    forms: ServiceFormPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    type: string
    code: string
    description: string
    country: string
    price: string
    timeline: string
    feature: string[]
    categoryForm: string[]
    hasShares: boolean
    numberOfShares: string
    hasAgent: boolean
    hasOwner: boolean
    hasController: boolean
    controllerIsCalled: string | null
    OwnerIsCalled: string | null
    agentIsCalled: string | null
    createdAt: Date
    updatedAt: Date
    serviceCategoryId: string
  }, ExtArgs["result"]["service"]>
  composites: {}
}

/**
 * Model Service
 * 
 */
export type Service = runtime.Types.DefaultSelection<ServicePayload>
export type ServiceTemplatePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ServiceTemplate"
  objects: {
    service: ServicePayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    type: string
    description: string
    createdAt: Date
    updatedAt: Date
    serviceId: string
  }, ExtArgs["result"]["serviceTemplate"]>
  composites: {}
}

/**
 * Model ServiceTemplate
 * 
 */
export type ServiceTemplate = runtime.Types.DefaultSelection<ServiceTemplatePayload>
export type ServiceFormPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ServiceForm"
  objects: {
    service: ServicePayload<ExtArgs>
    serviceSubForm: ServiceSubFormPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    question: string
    type: string
    options: string[]
    compulsory: boolean
    fileName: string
    fileDescription: string
    fileType: string
    fileLink: string
    createdAt: Date
    updatedAt: Date
    serviceId: string
  }, ExtArgs["result"]["serviceForm"]>
  composites: {}
}

/**
 * Model ServiceForm
 * 
 */
export type ServiceForm = runtime.Types.DefaultSelection<ServiceFormPayload>
export type ServiceSubFormPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ServiceSubForm"
  objects: {
    serviceForm: ServiceFormPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    question: string
    options: string[]
    type: string
    compulsory: boolean
    fileName: string
    fileDescription: string
    fileType: string
    fileLink: string
    serviceFormId: string
  }, ExtArgs["result"]["serviceSubForm"]>
  composites: {}
}

/**
 * Model ServiceSubForm
 * 
 */
export type ServiceSubForm = runtime.Types.DefaultSelection<ServiceSubFormPayload>
export type ProductPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Product"
  objects: {
    Team: TeamPayload<ExtArgs>[]
    service: ServicePayload<ExtArgs> | null
    user: UserPayload<ExtArgs>
    Payment: PaymentPayload<ExtArgs>[]
    productQA: ProductQAPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    email: string | null
    address: string | null
    paid: boolean
    completed: boolean
    status: string
    currentState: ProductActivityStage
    createdAt: Date
    updatedAt: Date
    serviceId: string | null
    userId: string
  }, ExtArgs["result"]["product"]>
  composites: {}
}

/**
 * Model Product
 * 
 */
export type Product = runtime.Types.DefaultSelection<ProductPayload>
export type ProductQAPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ProductQA"
  objects: {
    products: ProductPayload<ExtArgs>
    productSubForm: ProductQASubFormPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    question: string
    answer: string[]
    type: string
    compulsory: boolean
    isGeneral: boolean
    fileName: string
    fileDescription: string
    fileType: string
    fileLink: string
    createdAt: Date
    updatedAt: Date
    productId: string
  }, ExtArgs["result"]["productQA"]>
  composites: {}
}

/**
 * Model ProductQA
 * 
 */
export type ProductQA = runtime.Types.DefaultSelection<ProductQAPayload>
export type ProductQASubFormPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ProductQASubForm"
  objects: {
    productQA: ProductQAPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    question: string
    answer: string[]
    type: string
    compulsory: boolean
    productQAId: string
  }, ExtArgs["result"]["productQASubForm"]>
  composites: {}
}

/**
 * Model ProductQASubForm
 * 
 */
export type ProductQASubForm = runtime.Types.DefaultSelection<ProductQASubFormPayload>
export type ClaimPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Claim"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    value: string
    userId: string
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["claim"]>
  composites: {}
}

/**
 * Model Claim
 * 
 */
export type Claim = runtime.Types.DefaultSelection<ClaimPayload>
export type TeamPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Team"
  objects: {
    product: ProductPayload<ExtArgs>
    invitation: InvitationPayload<ExtArgs>[]
    teamMember: TeamMemberPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    slug: string
    userId: string
    createdAt: Date
    updatedAt: Date
    productId: string
  }, ExtArgs["result"]["team"]>
  composites: {}
}

/**
 * Model Team
 * 
 */
export type Team = runtime.Types.DefaultSelection<TeamPayload>
export type TeamMemberPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "TeamMember"
  objects: {
    team: TeamPayload<ExtArgs>
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    isLaunchMember: boolean
    isLaunchController: boolean
    isLaunchOwner: boolean
    launchOwnership: number
    teamId: string
    userId: string
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["teamMember"]>
  composites: {}
}

/**
 * Model TeamMember
 * 
 */
export type TeamMember = runtime.Types.DefaultSelection<TeamMemberPayload>
export type InvitationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Invitation"
  objects: {
    team: TeamPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    teamId: string
    email: string
    token: string
    expireIn: Date
    invitedBy: string
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["invitation"]>
  composites: {}
}

/**
 * Model Invitation
 * 
 */
export type Invitation = runtime.Types.DefaultSelection<InvitationPayload>
export type PaymentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Payment"
  objects: {
    products: ProductPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    provider: string
    transactionId: string
    status: string
    email: string
    createdAt: Date
    updatedAt: Date
    productId: string
  }, ExtArgs["result"]["payment"]>
  composites: {}
}

/**
 * Model Payment
 * 
 */
export type Payment = runtime.Types.DefaultSelection<PaymentPayload>
export type ParterPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Parter"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    isVerified: boolean
    verificationDocument: string[]
    serviceScore: number
    paymentsMade: number
    paymentsDue: number
    paymentDetails: string[]
    countrySupported: string[]
    serviceSupported: string[]
    servicesAssigned: string[]
    servicesCompleted: string[]
    servicesDeclined: string[]
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["parter"]>
  composites: {}
}

/**
 * Model Parter
 * 
 */
export type Parter = runtime.Types.DefaultSelection<ParterPayload>

/**
 * Enums
 */

export const ProductActivityStage: {
  START: 'START',
  PAYMENT: 'PAYMENT',
  PRORIETOR: 'PRORIETOR',
  REVIEW: 'REVIEW'
};

export type ProductActivityStage = (typeof ProductActivityStage)[keyof typeof ProductActivityStage]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Staff
 * const staff = await prisma.staff.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Staff
   * const staff = await prisma.staff.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.staff`: Exposes CRUD operations for the **Staff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Staff
    * const staff = await prisma.staff.findMany()
    * ```
    */
  get staff(): Prisma.StaffDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.collaborator`: Exposes CRUD operations for the **Collaborator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Collaborators
    * const collaborators = await prisma.collaborator.findMany()
    * ```
    */
  get collaborator(): Prisma.CollaboratorDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.collaboratorDocument`: Exposes CRUD operations for the **CollaboratorDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CollaboratorDocuments
    * const collaboratorDocuments = await prisma.collaboratorDocument.findMany()
    * ```
    */
  get collaboratorDocument(): Prisma.CollaboratorDocumentDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.reward`: Exposes CRUD operations for the **Reward** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rewards
    * const rewards = await prisma.reward.findMany()
    * ```
    */
  get reward(): Prisma.RewardDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.country`: Exposes CRUD operations for the **Country** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.country.findMany()
    * ```
    */
  get country(): Prisma.CountryDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.bank`: Exposes CRUD operations for the **Bank** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Banks
    * const banks = await prisma.bank.findMany()
    * ```
    */
  get bank(): Prisma.BankDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.userDocument`: Exposes CRUD operations for the **UserDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserDocuments
    * const userDocuments = await prisma.userDocument.findMany()
    * ```
    */
  get userDocument(): Prisma.UserDocumentDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.serviceCategory`: Exposes CRUD operations for the **ServiceCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceCategories
    * const serviceCategories = await prisma.serviceCategory.findMany()
    * ```
    */
  get serviceCategory(): Prisma.ServiceCategoryDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.serviceCategoryForm`: Exposes CRUD operations for the **ServiceCategoryForm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceCategoryForms
    * const serviceCategoryForms = await prisma.serviceCategoryForm.findMany()
    * ```
    */
  get serviceCategoryForm(): Prisma.ServiceCategoryFormDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.serviceTemplate`: Exposes CRUD operations for the **ServiceTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceTemplates
    * const serviceTemplates = await prisma.serviceTemplate.findMany()
    * ```
    */
  get serviceTemplate(): Prisma.ServiceTemplateDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.serviceForm`: Exposes CRUD operations for the **ServiceForm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceForms
    * const serviceForms = await prisma.serviceForm.findMany()
    * ```
    */
  get serviceForm(): Prisma.ServiceFormDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.serviceSubForm`: Exposes CRUD operations for the **ServiceSubForm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceSubForms
    * const serviceSubForms = await prisma.serviceSubForm.findMany()
    * ```
    */
  get serviceSubForm(): Prisma.ServiceSubFormDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.productQA`: Exposes CRUD operations for the **ProductQA** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductQAS
    * const productQAS = await prisma.productQA.findMany()
    * ```
    */
  get productQA(): Prisma.ProductQADelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.productQASubForm`: Exposes CRUD operations for the **ProductQASubForm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductQASubForms
    * const productQASubForms = await prisma.productQASubForm.findMany()
    * ```
    */
  get productQASubForm(): Prisma.ProductQASubFormDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.claim`: Exposes CRUD operations for the **Claim** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Claims
    * const claims = await prisma.claim.findMany()
    * ```
    */
  get claim(): Prisma.ClaimDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.teamMember`: Exposes CRUD operations for the **TeamMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamMembers
    * const teamMembers = await prisma.teamMember.findMany()
    * ```
    */
  get teamMember(): Prisma.TeamMemberDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.invitation`: Exposes CRUD operations for the **Invitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invitations
    * const invitations = await prisma.invitation.findMany()
    * ```
    */
  get invitation(): Prisma.InvitationDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.parter`: Exposes CRUD operations for the **Parter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parters
    * const parters = await prisma.parter.findMany()
    * ```
    */
  get parter(): Prisma.ParterDelegate<GlobalReject, ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export type Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export type Args<T, F extends $Public.Operation> = $Public.Args<T, F>
  export type Payload<T, F extends $Public.Operation> = $Public.Payload<T, F>
  export type Result<T, A, F extends $Public.Operation> = $Public.Result<T, A, F>
  export type Exact<T, W> = $Public.Exact<T, W>

  /**
   * Prisma Client JS version: 4.16.2
   * Query Engine version: 4bc8b6e1b66cb932731fb1bdbbc550d1e010de81
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Staff: 'Staff',
    Collaborator: 'Collaborator',
    CollaboratorDocument: 'CollaboratorDocument',
    Reward: 'Reward',
    Country: 'Country',
    Bank: 'Bank',
    Notification: 'Notification',
    Account: 'Account',
    User: 'User',
    UserDocument: 'UserDocument',
    ServiceCategory: 'ServiceCategory',
    ServiceCategoryForm: 'ServiceCategoryForm',
    Service: 'Service',
    ServiceTemplate: 'ServiceTemplate',
    ServiceForm: 'ServiceForm',
    ServiceSubForm: 'ServiceSubForm',
    Product: 'Product',
    ProductQA: 'ProductQA',
    ProductQASubForm: 'ProductQASubForm',
    Claim: 'Claim',
    Team: 'Team',
    TeamMember: 'TeamMember',
    Invitation: 'Invitation',
    Payment: 'Payment',
    Parter: 'Parter'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'staff' | 'collaborator' | 'collaboratorDocument' | 'reward' | 'country' | 'bank' | 'notification' | 'account' | 'user' | 'userDocument' | 'serviceCategory' | 'serviceCategoryForm' | 'service' | 'serviceTemplate' | 'serviceForm' | 'serviceSubForm' | 'product' | 'productQA' | 'productQASubForm' | 'claim' | 'team' | 'teamMember' | 'invitation' | 'payment' | 'parter'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Staff: {
        payload: StaffPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.StaffFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StaffFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffPayload>
          }
          findFirst: {
            args: Prisma.StaffFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StaffFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffPayload>
          }
          findMany: {
            args: Prisma.StaffFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffPayload>[]
          }
          create: {
            args: Prisma.StaffCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffPayload>
          }
          createMany: {
            args: Prisma.StaffCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StaffDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffPayload>
          }
          update: {
            args: Prisma.StaffUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffPayload>
          }
          deleteMany: {
            args: Prisma.StaffDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StaffUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StaffUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffPayload>
          }
          aggregate: {
            args: Prisma.StaffAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStaff>
          }
          groupBy: {
            args: Prisma.StaffGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StaffGroupByOutputType>[]
          }
          count: {
            args: Prisma.StaffCountArgs<ExtArgs>,
            result: $Utils.Optional<StaffCountAggregateOutputType> | number
          }
        }
      }
      Collaborator: {
        payload: CollaboratorPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.CollaboratorFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CollaboratorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CollaboratorFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CollaboratorPayload>
          }
          findFirst: {
            args: Prisma.CollaboratorFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CollaboratorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CollaboratorFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CollaboratorPayload>
          }
          findMany: {
            args: Prisma.CollaboratorFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CollaboratorPayload>[]
          }
          create: {
            args: Prisma.CollaboratorCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CollaboratorPayload>
          }
          createMany: {
            args: Prisma.CollaboratorCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CollaboratorDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CollaboratorPayload>
          }
          update: {
            args: Prisma.CollaboratorUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CollaboratorPayload>
          }
          deleteMany: {
            args: Prisma.CollaboratorDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CollaboratorUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CollaboratorUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CollaboratorPayload>
          }
          aggregate: {
            args: Prisma.CollaboratorAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCollaborator>
          }
          groupBy: {
            args: Prisma.CollaboratorGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CollaboratorGroupByOutputType>[]
          }
          count: {
            args: Prisma.CollaboratorCountArgs<ExtArgs>,
            result: $Utils.Optional<CollaboratorCountAggregateOutputType> | number
          }
        }
      }
      CollaboratorDocument: {
        payload: CollaboratorDocumentPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.CollaboratorDocumentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CollaboratorDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CollaboratorDocumentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CollaboratorDocumentPayload>
          }
          findFirst: {
            args: Prisma.CollaboratorDocumentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CollaboratorDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CollaboratorDocumentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CollaboratorDocumentPayload>
          }
          findMany: {
            args: Prisma.CollaboratorDocumentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CollaboratorDocumentPayload>[]
          }
          create: {
            args: Prisma.CollaboratorDocumentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CollaboratorDocumentPayload>
          }
          createMany: {
            args: Prisma.CollaboratorDocumentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CollaboratorDocumentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CollaboratorDocumentPayload>
          }
          update: {
            args: Prisma.CollaboratorDocumentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CollaboratorDocumentPayload>
          }
          deleteMany: {
            args: Prisma.CollaboratorDocumentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CollaboratorDocumentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CollaboratorDocumentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CollaboratorDocumentPayload>
          }
          aggregate: {
            args: Prisma.CollaboratorDocumentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCollaboratorDocument>
          }
          groupBy: {
            args: Prisma.CollaboratorDocumentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CollaboratorDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CollaboratorDocumentCountArgs<ExtArgs>,
            result: $Utils.Optional<CollaboratorDocumentCountAggregateOutputType> | number
          }
        }
      }
      Reward: {
        payload: RewardPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.RewardFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RewardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RewardFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RewardPayload>
          }
          findFirst: {
            args: Prisma.RewardFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RewardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RewardFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RewardPayload>
          }
          findMany: {
            args: Prisma.RewardFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RewardPayload>[]
          }
          create: {
            args: Prisma.RewardCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RewardPayload>
          }
          createMany: {
            args: Prisma.RewardCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RewardDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RewardPayload>
          }
          update: {
            args: Prisma.RewardUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RewardPayload>
          }
          deleteMany: {
            args: Prisma.RewardDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RewardUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RewardUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RewardPayload>
          }
          aggregate: {
            args: Prisma.RewardAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReward>
          }
          groupBy: {
            args: Prisma.RewardGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RewardGroupByOutputType>[]
          }
          count: {
            args: Prisma.RewardCountArgs<ExtArgs>,
            result: $Utils.Optional<RewardCountAggregateOutputType> | number
          }
        }
      }
      Country: {
        payload: CountryPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.CountryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CountryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CountryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CountryPayload>
          }
          findFirst: {
            args: Prisma.CountryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CountryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CountryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CountryPayload>
          }
          findMany: {
            args: Prisma.CountryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CountryPayload>[]
          }
          create: {
            args: Prisma.CountryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CountryPayload>
          }
          createMany: {
            args: Prisma.CountryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CountryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CountryPayload>
          }
          update: {
            args: Prisma.CountryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CountryPayload>
          }
          deleteMany: {
            args: Prisma.CountryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CountryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CountryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CountryPayload>
          }
          aggregate: {
            args: Prisma.CountryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCountry>
          }
          groupBy: {
            args: Prisma.CountryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CountryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CountryCountArgs<ExtArgs>,
            result: $Utils.Optional<CountryCountAggregateOutputType> | number
          }
        }
      }
      Bank: {
        payload: BankPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.BankFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BankPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BankFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BankPayload>
          }
          findFirst: {
            args: Prisma.BankFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BankPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BankFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BankPayload>
          }
          findMany: {
            args: Prisma.BankFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BankPayload>[]
          }
          create: {
            args: Prisma.BankCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BankPayload>
          }
          createMany: {
            args: Prisma.BankCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BankDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BankPayload>
          }
          update: {
            args: Prisma.BankUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BankPayload>
          }
          deleteMany: {
            args: Prisma.BankDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BankUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BankUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BankPayload>
          }
          aggregate: {
            args: Prisma.BankAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBank>
          }
          groupBy: {
            args: Prisma.BankGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BankGroupByOutputType>[]
          }
          count: {
            args: Prisma.BankCountArgs<ExtArgs>,
            result: $Utils.Optional<BankCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: NotificationPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>,
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: AccountPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>,
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: UserPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserDocument: {
        payload: UserDocumentPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.UserDocumentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserDocumentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserDocumentPayload>
          }
          findFirst: {
            args: Prisma.UserDocumentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserDocumentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserDocumentPayload>
          }
          findMany: {
            args: Prisma.UserDocumentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserDocumentPayload>[]
          }
          create: {
            args: Prisma.UserDocumentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserDocumentPayload>
          }
          createMany: {
            args: Prisma.UserDocumentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDocumentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserDocumentPayload>
          }
          update: {
            args: Prisma.UserDocumentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserDocumentPayload>
          }
          deleteMany: {
            args: Prisma.UserDocumentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserDocumentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserDocumentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserDocumentPayload>
          }
          aggregate: {
            args: Prisma.UserDocumentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserDocument>
          }
          groupBy: {
            args: Prisma.UserDocumentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserDocumentCountArgs<ExtArgs>,
            result: $Utils.Optional<UserDocumentCountAggregateOutputType> | number
          }
        }
      }
      ServiceCategory: {
        payload: ServiceCategoryPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ServiceCategoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceCategoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceCategoryPayload>
          }
          findFirst: {
            args: Prisma.ServiceCategoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceCategoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceCategoryPayload>
          }
          findMany: {
            args: Prisma.ServiceCategoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceCategoryPayload>[]
          }
          create: {
            args: Prisma.ServiceCategoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceCategoryPayload>
          }
          createMany: {
            args: Prisma.ServiceCategoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ServiceCategoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceCategoryPayload>
          }
          update: {
            args: Prisma.ServiceCategoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ServiceCategoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceCategoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ServiceCategoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceCategoryPayload>
          }
          aggregate: {
            args: Prisma.ServiceCategoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateServiceCategory>
          }
          groupBy: {
            args: Prisma.ServiceCategoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ServiceCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCategoryCountArgs<ExtArgs>,
            result: $Utils.Optional<ServiceCategoryCountAggregateOutputType> | number
          }
        }
      }
      ServiceCategoryForm: {
        payload: ServiceCategoryFormPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ServiceCategoryFormFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceCategoryFormPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceCategoryFormFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceCategoryFormPayload>
          }
          findFirst: {
            args: Prisma.ServiceCategoryFormFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceCategoryFormPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceCategoryFormFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceCategoryFormPayload>
          }
          findMany: {
            args: Prisma.ServiceCategoryFormFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceCategoryFormPayload>[]
          }
          create: {
            args: Prisma.ServiceCategoryFormCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceCategoryFormPayload>
          }
          createMany: {
            args: Prisma.ServiceCategoryFormCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ServiceCategoryFormDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceCategoryFormPayload>
          }
          update: {
            args: Prisma.ServiceCategoryFormUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceCategoryFormPayload>
          }
          deleteMany: {
            args: Prisma.ServiceCategoryFormDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceCategoryFormUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ServiceCategoryFormUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceCategoryFormPayload>
          }
          aggregate: {
            args: Prisma.ServiceCategoryFormAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateServiceCategoryForm>
          }
          groupBy: {
            args: Prisma.ServiceCategoryFormGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ServiceCategoryFormGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCategoryFormCountArgs<ExtArgs>,
            result: $Utils.Optional<ServiceCategoryFormCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: ServicePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>,
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      ServiceTemplate: {
        payload: ServiceTemplatePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ServiceTemplateFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceTemplateFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceTemplatePayload>
          }
          findFirst: {
            args: Prisma.ServiceTemplateFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceTemplateFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceTemplatePayload>
          }
          findMany: {
            args: Prisma.ServiceTemplateFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceTemplatePayload>[]
          }
          create: {
            args: Prisma.ServiceTemplateCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceTemplatePayload>
          }
          createMany: {
            args: Prisma.ServiceTemplateCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ServiceTemplateDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceTemplatePayload>
          }
          update: {
            args: Prisma.ServiceTemplateUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceTemplatePayload>
          }
          deleteMany: {
            args: Prisma.ServiceTemplateDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceTemplateUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ServiceTemplateUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceTemplatePayload>
          }
          aggregate: {
            args: Prisma.ServiceTemplateAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateServiceTemplate>
          }
          groupBy: {
            args: Prisma.ServiceTemplateGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ServiceTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceTemplateCountArgs<ExtArgs>,
            result: $Utils.Optional<ServiceTemplateCountAggregateOutputType> | number
          }
        }
      }
      ServiceForm: {
        payload: ServiceFormPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ServiceFormFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceFormPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFormFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceFormPayload>
          }
          findFirst: {
            args: Prisma.ServiceFormFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceFormPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFormFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceFormPayload>
          }
          findMany: {
            args: Prisma.ServiceFormFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceFormPayload>[]
          }
          create: {
            args: Prisma.ServiceFormCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceFormPayload>
          }
          createMany: {
            args: Prisma.ServiceFormCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ServiceFormDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceFormPayload>
          }
          update: {
            args: Prisma.ServiceFormUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceFormPayload>
          }
          deleteMany: {
            args: Prisma.ServiceFormDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceFormUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ServiceFormUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceFormPayload>
          }
          aggregate: {
            args: Prisma.ServiceFormAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateServiceForm>
          }
          groupBy: {
            args: Prisma.ServiceFormGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ServiceFormGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceFormCountArgs<ExtArgs>,
            result: $Utils.Optional<ServiceFormCountAggregateOutputType> | number
          }
        }
      }
      ServiceSubForm: {
        payload: ServiceSubFormPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ServiceSubFormFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceSubFormPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceSubFormFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceSubFormPayload>
          }
          findFirst: {
            args: Prisma.ServiceSubFormFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceSubFormPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceSubFormFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceSubFormPayload>
          }
          findMany: {
            args: Prisma.ServiceSubFormFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceSubFormPayload>[]
          }
          create: {
            args: Prisma.ServiceSubFormCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceSubFormPayload>
          }
          createMany: {
            args: Prisma.ServiceSubFormCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ServiceSubFormDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceSubFormPayload>
          }
          update: {
            args: Prisma.ServiceSubFormUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceSubFormPayload>
          }
          deleteMany: {
            args: Prisma.ServiceSubFormDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceSubFormUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ServiceSubFormUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceSubFormPayload>
          }
          aggregate: {
            args: Prisma.ServiceSubFormAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateServiceSubForm>
          }
          groupBy: {
            args: Prisma.ServiceSubFormGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ServiceSubFormGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceSubFormCountArgs<ExtArgs>,
            result: $Utils.Optional<ServiceSubFormCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: ProductPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      ProductQA: {
        payload: ProductQAPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ProductQAFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductQAPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductQAFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductQAPayload>
          }
          findFirst: {
            args: Prisma.ProductQAFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductQAPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductQAFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductQAPayload>
          }
          findMany: {
            args: Prisma.ProductQAFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductQAPayload>[]
          }
          create: {
            args: Prisma.ProductQACreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductQAPayload>
          }
          createMany: {
            args: Prisma.ProductQACreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProductQADeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductQAPayload>
          }
          update: {
            args: Prisma.ProductQAUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductQAPayload>
          }
          deleteMany: {
            args: Prisma.ProductQADeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProductQAUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProductQAUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductQAPayload>
          }
          aggregate: {
            args: Prisma.ProductQAAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProductQA>
          }
          groupBy: {
            args: Prisma.ProductQAGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductQAGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductQACountArgs<ExtArgs>,
            result: $Utils.Optional<ProductQACountAggregateOutputType> | number
          }
        }
      }
      ProductQASubForm: {
        payload: ProductQASubFormPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ProductQASubFormFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductQASubFormPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductQASubFormFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductQASubFormPayload>
          }
          findFirst: {
            args: Prisma.ProductQASubFormFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductQASubFormPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductQASubFormFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductQASubFormPayload>
          }
          findMany: {
            args: Prisma.ProductQASubFormFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductQASubFormPayload>[]
          }
          create: {
            args: Prisma.ProductQASubFormCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductQASubFormPayload>
          }
          createMany: {
            args: Prisma.ProductQASubFormCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProductQASubFormDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductQASubFormPayload>
          }
          update: {
            args: Prisma.ProductQASubFormUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductQASubFormPayload>
          }
          deleteMany: {
            args: Prisma.ProductQASubFormDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProductQASubFormUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProductQASubFormUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductQASubFormPayload>
          }
          aggregate: {
            args: Prisma.ProductQASubFormAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProductQASubForm>
          }
          groupBy: {
            args: Prisma.ProductQASubFormGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductQASubFormGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductQASubFormCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductQASubFormCountAggregateOutputType> | number
          }
        }
      }
      Claim: {
        payload: ClaimPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ClaimFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ClaimPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClaimFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ClaimPayload>
          }
          findFirst: {
            args: Prisma.ClaimFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ClaimPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClaimFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ClaimPayload>
          }
          findMany: {
            args: Prisma.ClaimFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ClaimPayload>[]
          }
          create: {
            args: Prisma.ClaimCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ClaimPayload>
          }
          createMany: {
            args: Prisma.ClaimCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ClaimDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ClaimPayload>
          }
          update: {
            args: Prisma.ClaimUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ClaimPayload>
          }
          deleteMany: {
            args: Prisma.ClaimDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ClaimUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ClaimUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ClaimPayload>
          }
          aggregate: {
            args: Prisma.ClaimAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClaim>
          }
          groupBy: {
            args: Prisma.ClaimGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClaimGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClaimCountArgs<ExtArgs>,
            result: $Utils.Optional<ClaimCountAggregateOutputType> | number
          }
        }
      }
      Team: {
        payload: TeamPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TeamPayload>
          }
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TeamPayload>
          }
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TeamPayload>[]
          }
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TeamPayload>
          }
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TeamPayload>
          }
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TeamPayload>
          }
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TeamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>,
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      TeamMember: {
        payload: TeamMemberPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.TeamMemberFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TeamMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamMemberFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TeamMemberPayload>
          }
          findFirst: {
            args: Prisma.TeamMemberFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TeamMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamMemberFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TeamMemberPayload>
          }
          findMany: {
            args: Prisma.TeamMemberFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TeamMemberPayload>[]
          }
          create: {
            args: Prisma.TeamMemberCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TeamMemberPayload>
          }
          createMany: {
            args: Prisma.TeamMemberCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TeamMemberDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TeamMemberPayload>
          }
          update: {
            args: Prisma.TeamMemberUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TeamMemberPayload>
          }
          deleteMany: {
            args: Prisma.TeamMemberDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TeamMemberUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TeamMemberUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TeamMemberPayload>
          }
          aggregate: {
            args: Prisma.TeamMemberAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTeamMember>
          }
          groupBy: {
            args: Prisma.TeamMemberGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TeamMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamMemberCountArgs<ExtArgs>,
            result: $Utils.Optional<TeamMemberCountAggregateOutputType> | number
          }
        }
      }
      Invitation: {
        payload: InvitationPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.InvitationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvitationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvitationPayload>
          }
          findFirst: {
            args: Prisma.InvitationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvitationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvitationPayload>
          }
          findMany: {
            args: Prisma.InvitationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvitationPayload>[]
          }
          create: {
            args: Prisma.InvitationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvitationPayload>
          }
          createMany: {
            args: Prisma.InvitationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InvitationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvitationPayload>
          }
          update: {
            args: Prisma.InvitationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvitationPayload>
          }
          deleteMany: {
            args: Prisma.InvitationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InvitationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InvitationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvitationPayload>
          }
          aggregate: {
            args: Prisma.InvitationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInvitation>
          }
          groupBy: {
            args: Prisma.InvitationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvitationCountArgs<ExtArgs>,
            result: $Utils.Optional<InvitationCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: PaymentPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>,
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Parter: {
        payload: ParterPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ParterFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ParterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParterFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ParterPayload>
          }
          findFirst: {
            args: Prisma.ParterFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ParterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParterFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ParterPayload>
          }
          findMany: {
            args: Prisma.ParterFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ParterPayload>[]
          }
          create: {
            args: Prisma.ParterCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ParterPayload>
          }
          createMany: {
            args: Prisma.ParterCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ParterDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ParterPayload>
          }
          update: {
            args: Prisma.ParterUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ParterPayload>
          }
          deleteMany: {
            args: Prisma.ParterDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ParterUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ParterUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ParterPayload>
          }
          aggregate: {
            args: Prisma.ParterAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateParter>
          }
          groupBy: {
            args: Prisma.ParterGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ParterGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParterCountArgs<ExtArgs>,
            result: $Utils.Optional<ParterCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CollaboratorCountOutputType
   */


  export type CollaboratorCountOutputType = {
    collaboratorDocument: number
  }

  export type CollaboratorCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    collaboratorDocument?: boolean | CollaboratorCountOutputTypeCountCollaboratorDocumentArgs
  }

  // Custom InputTypes

  /**
   * CollaboratorCountOutputType without action
   */
  export type CollaboratorCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollaboratorCountOutputType
     */
    select?: CollaboratorCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CollaboratorCountOutputType without action
   */
  export type CollaboratorCountOutputTypeCountCollaboratorDocumentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CollaboratorDocumentWhereInput
  }



  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    teamMember: number
    account: number
    product: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    teamMember?: boolean | UserCountOutputTypeCountTeamMemberArgs
    account?: boolean | UserCountOutputTypeCountAccountArgs
    product?: boolean | UserCountOutputTypeCountProductArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamMemberArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }



  /**
   * Count Type ServiceCategoryCountOutputType
   */


  export type ServiceCategoryCountOutputType = {
    services: number
    form: number
  }

  export type ServiceCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    services?: boolean | ServiceCategoryCountOutputTypeCountServicesArgs
    form?: boolean | ServiceCategoryCountOutputTypeCountFormArgs
  }

  // Custom InputTypes

  /**
   * ServiceCategoryCountOutputType without action
   */
  export type ServiceCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategoryCountOutputType
     */
    select?: ServiceCategoryCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ServiceCategoryCountOutputType without action
   */
  export type ServiceCategoryCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }


  /**
   * ServiceCategoryCountOutputType without action
   */
  export type ServiceCategoryCountOutputTypeCountFormArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ServiceCategoryFormWhereInput
  }



  /**
   * Count Type ServiceCountOutputType
   */


  export type ServiceCountOutputType = {
    products: number
    templates: number
    forms: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    products?: boolean | ServiceCountOutputTypeCountProductsArgs
    templates?: boolean | ServiceCountOutputTypeCountTemplatesArgs
    forms?: boolean | ServiceCountOutputTypeCountFormsArgs
  }

  // Custom InputTypes

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountTemplatesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ServiceTemplateWhereInput
  }


  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountFormsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ServiceFormWhereInput
  }



  /**
   * Count Type ServiceFormCountOutputType
   */


  export type ServiceFormCountOutputType = {
    serviceSubForm: number
  }

  export type ServiceFormCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    serviceSubForm?: boolean | ServiceFormCountOutputTypeCountServiceSubFormArgs
  }

  // Custom InputTypes

  /**
   * ServiceFormCountOutputType without action
   */
  export type ServiceFormCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceFormCountOutputType
     */
    select?: ServiceFormCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ServiceFormCountOutputType without action
   */
  export type ServiceFormCountOutputTypeCountServiceSubFormArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ServiceSubFormWhereInput
  }



  /**
   * Count Type ProductCountOutputType
   */


  export type ProductCountOutputType = {
    Team: number
    Payment: number
    productQA: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Team?: boolean | ProductCountOutputTypeCountTeamArgs
    Payment?: boolean | ProductCountOutputTypeCountPaymentArgs
    productQA?: boolean | ProductCountOutputTypeCountProductQAArgs
  }

  // Custom InputTypes

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountTeamArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountPaymentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProductQAArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductQAWhereInput
  }



  /**
   * Count Type ProductQACountOutputType
   */


  export type ProductQACountOutputType = {
    productSubForm: number
  }

  export type ProductQACountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    productSubForm?: boolean | ProductQACountOutputTypeCountProductSubFormArgs
  }

  // Custom InputTypes

  /**
   * ProductQACountOutputType without action
   */
  export type ProductQACountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQACountOutputType
     */
    select?: ProductQACountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProductQACountOutputType without action
   */
  export type ProductQACountOutputTypeCountProductSubFormArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductQASubFormWhereInput
  }



  /**
   * Count Type TeamCountOutputType
   */


  export type TeamCountOutputType = {
    invitation: number
    teamMember: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    invitation?: boolean | TeamCountOutputTypeCountInvitationArgs
    teamMember?: boolean | TeamCountOutputTypeCountTeamMemberArgs
  }

  // Custom InputTypes

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountInvitationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: InvitationWhereInput
  }


  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountTeamMemberArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
  }



  /**
   * Models
   */

  /**
   * Model Staff
   */


  export type AggregateStaff = {
    _count: StaffCountAggregateOutputType | null
    _min: StaffMinAggregateOutputType | null
    _max: StaffMaxAggregateOutputType | null
  }

  export type StaffMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    password: string | null
    phone: string | null
    verified: boolean | null
    picture: string | null
    resetToken: string | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    password: string | null
    phone: string | null
    verified: boolean | null
    picture: string | null
    resetToken: string | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    email: number
    password: number
    phone: number
    verified: number
    picture: number
    resetToken: number
    isDeprecated: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StaffMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    phone?: true
    verified?: true
    picture?: true
    resetToken?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    phone?: true
    verified?: true
    picture?: true
    resetToken?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    phone?: true
    verified?: true
    picture?: true
    resetToken?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StaffAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Staff to aggregate.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: Enumerable<StaffOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Staff
    **/
    _count?: true | StaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaffMaxAggregateInputType
  }

  export type GetStaffAggregateType<T extends StaffAggregateArgs> = {
        [P in keyof T & keyof AggregateStaff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaff[P]>
      : GetScalarType<T[P], AggregateStaff[P]>
  }




  export type StaffGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: StaffWhereInput
    orderBy?: Enumerable<StaffOrderByWithAggregationInput>
    by: StaffScalarFieldEnum[]
    having?: StaffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaffCountAggregateInputType | true
    _min?: StaffMinAggregateInputType
    _max?: StaffMaxAggregateInputType
  }


  export type StaffGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    email: string
    password: string
    phone: string
    verified: boolean
    picture: string | null
    resetToken: string | null
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
    _count: StaffCountAggregateOutputType | null
    _min: StaffMinAggregateOutputType | null
    _max: StaffMaxAggregateOutputType | null
  }

  type GetStaffGroupByPayload<T extends StaffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<StaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaffGroupByOutputType[P]>
            : GetScalarType<T[P], StaffGroupByOutputType[P]>
        }
      >
    >


  export type StaffSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    verified?: boolean
    picture?: boolean
    resetToken?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["staff"]>

  export type StaffSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    verified?: boolean
    picture?: boolean
    resetToken?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  type StaffGetPayload<S extends boolean | null | undefined | StaffArgs> = $Types.GetResult<StaffPayload, S>

  type StaffCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<StaffFindManyArgs, 'select' | 'include'> & {
      select?: StaffCountAggregateInputType | true
    }

  export interface StaffDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Staff'], meta: { name: 'Staff' } }
    /**
     * Find zero or one Staff that matches the filter.
     * @param {StaffFindUniqueArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StaffFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StaffFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Staff'> extends True ? Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Staff that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StaffFindUniqueOrThrowArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StaffFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StaffFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Staff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindFirstArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StaffFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StaffFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Staff'> extends True ? Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Staff that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindFirstOrThrowArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StaffFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StaffFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Staff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Staff
     * const staff = await prisma.staff.findMany()
     * 
     * // Get first 10 Staff
     * const staff = await prisma.staff.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const staffWithIdOnly = await prisma.staff.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StaffFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StaffFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<StaffPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Staff.
     * @param {StaffCreateArgs} args - Arguments to create a Staff.
     * @example
     * // Create one Staff
     * const Staff = await prisma.staff.create({
     *   data: {
     *     // ... data to create a Staff
     *   }
     * })
     * 
    **/
    create<T extends StaffCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StaffCreateArgs<ExtArgs>>
    ): Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Staff.
     *     @param {StaffCreateManyArgs} args - Arguments to create many Staff.
     *     @example
     *     // Create many Staff
     *     const staff = await prisma.staff.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StaffCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StaffCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Staff.
     * @param {StaffDeleteArgs} args - Arguments to delete one Staff.
     * @example
     * // Delete one Staff
     * const Staff = await prisma.staff.delete({
     *   where: {
     *     // ... filter to delete one Staff
     *   }
     * })
     * 
    **/
    delete<T extends StaffDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StaffDeleteArgs<ExtArgs>>
    ): Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Staff.
     * @param {StaffUpdateArgs} args - Arguments to update one Staff.
     * @example
     * // Update one Staff
     * const staff = await prisma.staff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StaffUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StaffUpdateArgs<ExtArgs>>
    ): Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Staff.
     * @param {StaffDeleteManyArgs} args - Arguments to filter Staff to delete.
     * @example
     * // Delete a few Staff
     * const { count } = await prisma.staff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StaffDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StaffDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Staff
     * const staff = await prisma.staff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StaffUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StaffUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Staff.
     * @param {StaffUpsertArgs} args - Arguments to update or create a Staff.
     * @example
     * // Update or create a Staff
     * const staff = await prisma.staff.upsert({
     *   create: {
     *     // ... data to create a Staff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Staff we want to update
     *   }
     * })
    **/
    upsert<T extends StaffUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StaffUpsertArgs<ExtArgs>>
    ): Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffCountArgs} args - Arguments to filter Staff to count.
     * @example
     * // Count the number of Staff
     * const count = await prisma.staff.count({
     *   where: {
     *     // ... the filter for the Staff we want to count
     *   }
     * })
    **/
    count<T extends StaffCountArgs>(
      args?: Subset<T, StaffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaffAggregateArgs>(args: Subset<T, StaffAggregateArgs>): Prisma.PrismaPromise<GetStaffAggregateType<T>>

    /**
     * Group by Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaffGroupByArgs['orderBy'] }
        : { orderBy?: StaffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StaffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Staff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StaffClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Staff base type for findUnique actions
   */
  export type StaffFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff findUnique
   */
  export interface StaffFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends StaffFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Staff findUniqueOrThrow
   */
  export type StaffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where: StaffWhereUniqueInput
  }


  /**
   * Staff base type for findFirst actions
   */
  export type StaffFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: Enumerable<StaffOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Staff.
     */
    distinct?: Enumerable<StaffScalarFieldEnum>
  }

  /**
   * Staff findFirst
   */
  export interface StaffFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends StaffFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Staff findFirstOrThrow
   */
  export type StaffFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: Enumerable<StaffOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Staff.
     */
    distinct?: Enumerable<StaffScalarFieldEnum>
  }


  /**
   * Staff findMany
   */
  export type StaffFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: Enumerable<StaffOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    distinct?: Enumerable<StaffScalarFieldEnum>
  }


  /**
   * Staff create
   */
  export type StaffCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * The data needed to create a Staff.
     */
    data: XOR<StaffCreateInput, StaffUncheckedCreateInput>
  }


  /**
   * Staff createMany
   */
  export type StaffCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Staff.
     */
    data: Enumerable<StaffCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Staff update
   */
  export type StaffUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * The data needed to update a Staff.
     */
    data: XOR<StaffUpdateInput, StaffUncheckedUpdateInput>
    /**
     * Choose, which Staff to update.
     */
    where: StaffWhereUniqueInput
  }


  /**
   * Staff updateMany
   */
  export type StaffUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Staff.
     */
    data: XOR<StaffUpdateManyMutationInput, StaffUncheckedUpdateManyInput>
    /**
     * Filter which Staff to update
     */
    where?: StaffWhereInput
  }


  /**
   * Staff upsert
   */
  export type StaffUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * The filter to search for the Staff to update in case it exists.
     */
    where: StaffWhereUniqueInput
    /**
     * In case the Staff found by the `where` argument doesn't exist, create a new Staff with this data.
     */
    create: XOR<StaffCreateInput, StaffUncheckedCreateInput>
    /**
     * In case the Staff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StaffUpdateInput, StaffUncheckedUpdateInput>
  }


  /**
   * Staff delete
   */
  export type StaffDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Filter which Staff to delete.
     */
    where: StaffWhereUniqueInput
  }


  /**
   * Staff deleteMany
   */
  export type StaffDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Staff to delete
     */
    where?: StaffWhereInput
  }


  /**
   * Staff without action
   */
  export type StaffArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
  }



  /**
   * Model Collaborator
   */


  export type AggregateCollaborator = {
    _count: CollaboratorCountAggregateOutputType | null
    _min: CollaboratorMinAggregateOutputType | null
    _max: CollaboratorMaxAggregateOutputType | null
  }

  export type CollaboratorMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    password: string | null
    phone: string | null
    picture: string | null
    verified: boolean | null
    isPartner: boolean | null
    resetToken: string | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CollaboratorMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    password: string | null
    phone: string | null
    picture: string | null
    verified: boolean | null
    isPartner: boolean | null
    resetToken: string | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CollaboratorCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    email: number
    password: number
    phone: number
    picture: number
    verified: number
    isPartner: number
    resetToken: number
    isDeprecated: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CollaboratorMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    phone?: true
    picture?: true
    verified?: true
    isPartner?: true
    resetToken?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CollaboratorMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    phone?: true
    picture?: true
    verified?: true
    isPartner?: true
    resetToken?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CollaboratorCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    phone?: true
    picture?: true
    verified?: true
    isPartner?: true
    resetToken?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CollaboratorAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Collaborator to aggregate.
     */
    where?: CollaboratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Collaborators to fetch.
     */
    orderBy?: Enumerable<CollaboratorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CollaboratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Collaborators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Collaborators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Collaborators
    **/
    _count?: true | CollaboratorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CollaboratorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CollaboratorMaxAggregateInputType
  }

  export type GetCollaboratorAggregateType<T extends CollaboratorAggregateArgs> = {
        [P in keyof T & keyof AggregateCollaborator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollaborator[P]>
      : GetScalarType<T[P], AggregateCollaborator[P]>
  }




  export type CollaboratorGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CollaboratorWhereInput
    orderBy?: Enumerable<CollaboratorOrderByWithAggregationInput>
    by: CollaboratorScalarFieldEnum[]
    having?: CollaboratorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CollaboratorCountAggregateInputType | true
    _min?: CollaboratorMinAggregateInputType
    _max?: CollaboratorMaxAggregateInputType
  }


  export type CollaboratorGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    email: string
    password: string
    phone: string
    picture: string | null
    verified: boolean
    isPartner: boolean
    resetToken: string | null
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
    _count: CollaboratorCountAggregateOutputType | null
    _min: CollaboratorMinAggregateOutputType | null
    _max: CollaboratorMaxAggregateOutputType | null
  }

  type GetCollaboratorGroupByPayload<T extends CollaboratorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CollaboratorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CollaboratorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CollaboratorGroupByOutputType[P]>
            : GetScalarType<T[P], CollaboratorGroupByOutputType[P]>
        }
      >
    >


  export type CollaboratorSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    picture?: boolean
    verified?: boolean
    isPartner?: boolean
    resetToken?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    collaboratorDocument?: boolean | Collaborator$collaboratorDocumentArgs<ExtArgs>
    _count?: boolean | CollaboratorCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["collaborator"]>

  export type CollaboratorSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    picture?: boolean
    verified?: boolean
    isPartner?: boolean
    resetToken?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CollaboratorInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    collaboratorDocument?: boolean | Collaborator$collaboratorDocumentArgs<ExtArgs>
    _count?: boolean | CollaboratorCountOutputTypeArgs<ExtArgs>
  }


  type CollaboratorGetPayload<S extends boolean | null | undefined | CollaboratorArgs> = $Types.GetResult<CollaboratorPayload, S>

  type CollaboratorCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CollaboratorFindManyArgs, 'select' | 'include'> & {
      select?: CollaboratorCountAggregateInputType | true
    }

  export interface CollaboratorDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Collaborator'], meta: { name: 'Collaborator' } }
    /**
     * Find zero or one Collaborator that matches the filter.
     * @param {CollaboratorFindUniqueArgs} args - Arguments to find a Collaborator
     * @example
     * // Get one Collaborator
     * const collaborator = await prisma.collaborator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CollaboratorFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CollaboratorFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Collaborator'> extends True ? Prisma__CollaboratorClient<$Types.GetResult<CollaboratorPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__CollaboratorClient<$Types.GetResult<CollaboratorPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Collaborator that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CollaboratorFindUniqueOrThrowArgs} args - Arguments to find a Collaborator
     * @example
     * // Get one Collaborator
     * const collaborator = await prisma.collaborator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CollaboratorFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CollaboratorFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CollaboratorClient<$Types.GetResult<CollaboratorPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Collaborator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaboratorFindFirstArgs} args - Arguments to find a Collaborator
     * @example
     * // Get one Collaborator
     * const collaborator = await prisma.collaborator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CollaboratorFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CollaboratorFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Collaborator'> extends True ? Prisma__CollaboratorClient<$Types.GetResult<CollaboratorPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__CollaboratorClient<$Types.GetResult<CollaboratorPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Collaborator that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaboratorFindFirstOrThrowArgs} args - Arguments to find a Collaborator
     * @example
     * // Get one Collaborator
     * const collaborator = await prisma.collaborator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CollaboratorFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CollaboratorFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CollaboratorClient<$Types.GetResult<CollaboratorPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Collaborators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaboratorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Collaborators
     * const collaborators = await prisma.collaborator.findMany()
     * 
     * // Get first 10 Collaborators
     * const collaborators = await prisma.collaborator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collaboratorWithIdOnly = await prisma.collaborator.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CollaboratorFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CollaboratorFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<CollaboratorPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Collaborator.
     * @param {CollaboratorCreateArgs} args - Arguments to create a Collaborator.
     * @example
     * // Create one Collaborator
     * const Collaborator = await prisma.collaborator.create({
     *   data: {
     *     // ... data to create a Collaborator
     *   }
     * })
     * 
    **/
    create<T extends CollaboratorCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CollaboratorCreateArgs<ExtArgs>>
    ): Prisma__CollaboratorClient<$Types.GetResult<CollaboratorPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Collaborators.
     *     @param {CollaboratorCreateManyArgs} args - Arguments to create many Collaborators.
     *     @example
     *     // Create many Collaborators
     *     const collaborator = await prisma.collaborator.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CollaboratorCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CollaboratorCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Collaborator.
     * @param {CollaboratorDeleteArgs} args - Arguments to delete one Collaborator.
     * @example
     * // Delete one Collaborator
     * const Collaborator = await prisma.collaborator.delete({
     *   where: {
     *     // ... filter to delete one Collaborator
     *   }
     * })
     * 
    **/
    delete<T extends CollaboratorDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CollaboratorDeleteArgs<ExtArgs>>
    ): Prisma__CollaboratorClient<$Types.GetResult<CollaboratorPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Collaborator.
     * @param {CollaboratorUpdateArgs} args - Arguments to update one Collaborator.
     * @example
     * // Update one Collaborator
     * const collaborator = await prisma.collaborator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CollaboratorUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CollaboratorUpdateArgs<ExtArgs>>
    ): Prisma__CollaboratorClient<$Types.GetResult<CollaboratorPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Collaborators.
     * @param {CollaboratorDeleteManyArgs} args - Arguments to filter Collaborators to delete.
     * @example
     * // Delete a few Collaborators
     * const { count } = await prisma.collaborator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CollaboratorDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CollaboratorDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Collaborators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaboratorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Collaborators
     * const collaborator = await prisma.collaborator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CollaboratorUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CollaboratorUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Collaborator.
     * @param {CollaboratorUpsertArgs} args - Arguments to update or create a Collaborator.
     * @example
     * // Update or create a Collaborator
     * const collaborator = await prisma.collaborator.upsert({
     *   create: {
     *     // ... data to create a Collaborator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Collaborator we want to update
     *   }
     * })
    **/
    upsert<T extends CollaboratorUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CollaboratorUpsertArgs<ExtArgs>>
    ): Prisma__CollaboratorClient<$Types.GetResult<CollaboratorPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Collaborators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaboratorCountArgs} args - Arguments to filter Collaborators to count.
     * @example
     * // Count the number of Collaborators
     * const count = await prisma.collaborator.count({
     *   where: {
     *     // ... the filter for the Collaborators we want to count
     *   }
     * })
    **/
    count<T extends CollaboratorCountArgs>(
      args?: Subset<T, CollaboratorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CollaboratorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Collaborator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaboratorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CollaboratorAggregateArgs>(args: Subset<T, CollaboratorAggregateArgs>): Prisma.PrismaPromise<GetCollaboratorAggregateType<T>>

    /**
     * Group by Collaborator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaboratorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CollaboratorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CollaboratorGroupByArgs['orderBy'] }
        : { orderBy?: CollaboratorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CollaboratorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollaboratorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Collaborator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CollaboratorClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    collaboratorDocument<T extends Collaborator$collaboratorDocumentArgs<ExtArgs> = {}>(args?: Subset<T, Collaborator$collaboratorDocumentArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<CollaboratorDocumentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Collaborator base type for findUnique actions
   */
  export type CollaboratorFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collaborator
     */
    select?: CollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which Collaborator to fetch.
     */
    where: CollaboratorWhereUniqueInput
  }

  /**
   * Collaborator findUnique
   */
  export interface CollaboratorFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CollaboratorFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Collaborator findUniqueOrThrow
   */
  export type CollaboratorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collaborator
     */
    select?: CollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which Collaborator to fetch.
     */
    where: CollaboratorWhereUniqueInput
  }


  /**
   * Collaborator base type for findFirst actions
   */
  export type CollaboratorFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collaborator
     */
    select?: CollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which Collaborator to fetch.
     */
    where?: CollaboratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Collaborators to fetch.
     */
    orderBy?: Enumerable<CollaboratorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Collaborators.
     */
    cursor?: CollaboratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Collaborators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Collaborators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Collaborators.
     */
    distinct?: Enumerable<CollaboratorScalarFieldEnum>
  }

  /**
   * Collaborator findFirst
   */
  export interface CollaboratorFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CollaboratorFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Collaborator findFirstOrThrow
   */
  export type CollaboratorFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collaborator
     */
    select?: CollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which Collaborator to fetch.
     */
    where?: CollaboratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Collaborators to fetch.
     */
    orderBy?: Enumerable<CollaboratorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Collaborators.
     */
    cursor?: CollaboratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Collaborators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Collaborators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Collaborators.
     */
    distinct?: Enumerable<CollaboratorScalarFieldEnum>
  }


  /**
   * Collaborator findMany
   */
  export type CollaboratorFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collaborator
     */
    select?: CollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which Collaborators to fetch.
     */
    where?: CollaboratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Collaborators to fetch.
     */
    orderBy?: Enumerable<CollaboratorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Collaborators.
     */
    cursor?: CollaboratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Collaborators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Collaborators.
     */
    skip?: number
    distinct?: Enumerable<CollaboratorScalarFieldEnum>
  }


  /**
   * Collaborator create
   */
  export type CollaboratorCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collaborator
     */
    select?: CollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorInclude<ExtArgs> | null
    /**
     * The data needed to create a Collaborator.
     */
    data: XOR<CollaboratorCreateInput, CollaboratorUncheckedCreateInput>
  }


  /**
   * Collaborator createMany
   */
  export type CollaboratorCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Collaborators.
     */
    data: Enumerable<CollaboratorCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Collaborator update
   */
  export type CollaboratorUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collaborator
     */
    select?: CollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorInclude<ExtArgs> | null
    /**
     * The data needed to update a Collaborator.
     */
    data: XOR<CollaboratorUpdateInput, CollaboratorUncheckedUpdateInput>
    /**
     * Choose, which Collaborator to update.
     */
    where: CollaboratorWhereUniqueInput
  }


  /**
   * Collaborator updateMany
   */
  export type CollaboratorUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Collaborators.
     */
    data: XOR<CollaboratorUpdateManyMutationInput, CollaboratorUncheckedUpdateManyInput>
    /**
     * Filter which Collaborators to update
     */
    where?: CollaboratorWhereInput
  }


  /**
   * Collaborator upsert
   */
  export type CollaboratorUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collaborator
     */
    select?: CollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorInclude<ExtArgs> | null
    /**
     * The filter to search for the Collaborator to update in case it exists.
     */
    where: CollaboratorWhereUniqueInput
    /**
     * In case the Collaborator found by the `where` argument doesn't exist, create a new Collaborator with this data.
     */
    create: XOR<CollaboratorCreateInput, CollaboratorUncheckedCreateInput>
    /**
     * In case the Collaborator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CollaboratorUpdateInput, CollaboratorUncheckedUpdateInput>
  }


  /**
   * Collaborator delete
   */
  export type CollaboratorDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collaborator
     */
    select?: CollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorInclude<ExtArgs> | null
    /**
     * Filter which Collaborator to delete.
     */
    where: CollaboratorWhereUniqueInput
  }


  /**
   * Collaborator deleteMany
   */
  export type CollaboratorDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Collaborators to delete
     */
    where?: CollaboratorWhereInput
  }


  /**
   * Collaborator.collaboratorDocument
   */
  export type Collaborator$collaboratorDocumentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollaboratorDocument
     */
    select?: CollaboratorDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorDocumentInclude<ExtArgs> | null
    where?: CollaboratorDocumentWhereInput
    orderBy?: Enumerable<CollaboratorDocumentOrderByWithRelationInput>
    cursor?: CollaboratorDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CollaboratorDocumentScalarFieldEnum>
  }


  /**
   * Collaborator without action
   */
  export type CollaboratorArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collaborator
     */
    select?: CollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorInclude<ExtArgs> | null
  }



  /**
   * Model CollaboratorDocument
   */


  export type AggregateCollaboratorDocument = {
    _count: CollaboratorDocumentCountAggregateOutputType | null
    _min: CollaboratorDocumentMinAggregateOutputType | null
    _max: CollaboratorDocumentMaxAggregateOutputType | null
  }

  export type CollaboratorDocumentMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    description: string | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    collaboratorId: string | null
  }

  export type CollaboratorDocumentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    description: string | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    collaboratorId: string | null
  }

  export type CollaboratorDocumentCountAggregateOutputType = {
    id: number
    name: number
    type: number
    description: number
    isDeprecated: number
    createdAt: number
    updatedAt: number
    collaboratorId: number
    _all: number
  }


  export type CollaboratorDocumentMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
    collaboratorId?: true
  }

  export type CollaboratorDocumentMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
    collaboratorId?: true
  }

  export type CollaboratorDocumentCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
    collaboratorId?: true
    _all?: true
  }

  export type CollaboratorDocumentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CollaboratorDocument to aggregate.
     */
    where?: CollaboratorDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollaboratorDocuments to fetch.
     */
    orderBy?: Enumerable<CollaboratorDocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CollaboratorDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollaboratorDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollaboratorDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CollaboratorDocuments
    **/
    _count?: true | CollaboratorDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CollaboratorDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CollaboratorDocumentMaxAggregateInputType
  }

  export type GetCollaboratorDocumentAggregateType<T extends CollaboratorDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateCollaboratorDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollaboratorDocument[P]>
      : GetScalarType<T[P], AggregateCollaboratorDocument[P]>
  }




  export type CollaboratorDocumentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CollaboratorDocumentWhereInput
    orderBy?: Enumerable<CollaboratorDocumentOrderByWithAggregationInput>
    by: CollaboratorDocumentScalarFieldEnum[]
    having?: CollaboratorDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CollaboratorDocumentCountAggregateInputType | true
    _min?: CollaboratorDocumentMinAggregateInputType
    _max?: CollaboratorDocumentMaxAggregateInputType
  }


  export type CollaboratorDocumentGroupByOutputType = {
    id: string
    name: string
    type: string
    description: string
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
    collaboratorId: string
    _count: CollaboratorDocumentCountAggregateOutputType | null
    _min: CollaboratorDocumentMinAggregateOutputType | null
    _max: CollaboratorDocumentMaxAggregateOutputType | null
  }

  type GetCollaboratorDocumentGroupByPayload<T extends CollaboratorDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CollaboratorDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CollaboratorDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CollaboratorDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], CollaboratorDocumentGroupByOutputType[P]>
        }
      >
    >


  export type CollaboratorDocumentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    collaboratorId?: boolean
    collaborator?: boolean | CollaboratorArgs<ExtArgs>
  }, ExtArgs["result"]["collaboratorDocument"]>

  export type CollaboratorDocumentSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    collaboratorId?: boolean
  }

  export type CollaboratorDocumentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    collaborator?: boolean | CollaboratorArgs<ExtArgs>
  }


  type CollaboratorDocumentGetPayload<S extends boolean | null | undefined | CollaboratorDocumentArgs> = $Types.GetResult<CollaboratorDocumentPayload, S>

  type CollaboratorDocumentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CollaboratorDocumentFindManyArgs, 'select' | 'include'> & {
      select?: CollaboratorDocumentCountAggregateInputType | true
    }

  export interface CollaboratorDocumentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CollaboratorDocument'], meta: { name: 'CollaboratorDocument' } }
    /**
     * Find zero or one CollaboratorDocument that matches the filter.
     * @param {CollaboratorDocumentFindUniqueArgs} args - Arguments to find a CollaboratorDocument
     * @example
     * // Get one CollaboratorDocument
     * const collaboratorDocument = await prisma.collaboratorDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CollaboratorDocumentFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CollaboratorDocumentFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CollaboratorDocument'> extends True ? Prisma__CollaboratorDocumentClient<$Types.GetResult<CollaboratorDocumentPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__CollaboratorDocumentClient<$Types.GetResult<CollaboratorDocumentPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one CollaboratorDocument that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CollaboratorDocumentFindUniqueOrThrowArgs} args - Arguments to find a CollaboratorDocument
     * @example
     * // Get one CollaboratorDocument
     * const collaboratorDocument = await prisma.collaboratorDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CollaboratorDocumentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CollaboratorDocumentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CollaboratorDocumentClient<$Types.GetResult<CollaboratorDocumentPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first CollaboratorDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaboratorDocumentFindFirstArgs} args - Arguments to find a CollaboratorDocument
     * @example
     * // Get one CollaboratorDocument
     * const collaboratorDocument = await prisma.collaboratorDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CollaboratorDocumentFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CollaboratorDocumentFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CollaboratorDocument'> extends True ? Prisma__CollaboratorDocumentClient<$Types.GetResult<CollaboratorDocumentPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__CollaboratorDocumentClient<$Types.GetResult<CollaboratorDocumentPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first CollaboratorDocument that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaboratorDocumentFindFirstOrThrowArgs} args - Arguments to find a CollaboratorDocument
     * @example
     * // Get one CollaboratorDocument
     * const collaboratorDocument = await prisma.collaboratorDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CollaboratorDocumentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CollaboratorDocumentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CollaboratorDocumentClient<$Types.GetResult<CollaboratorDocumentPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more CollaboratorDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaboratorDocumentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CollaboratorDocuments
     * const collaboratorDocuments = await prisma.collaboratorDocument.findMany()
     * 
     * // Get first 10 CollaboratorDocuments
     * const collaboratorDocuments = await prisma.collaboratorDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collaboratorDocumentWithIdOnly = await prisma.collaboratorDocument.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CollaboratorDocumentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CollaboratorDocumentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<CollaboratorDocumentPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a CollaboratorDocument.
     * @param {CollaboratorDocumentCreateArgs} args - Arguments to create a CollaboratorDocument.
     * @example
     * // Create one CollaboratorDocument
     * const CollaboratorDocument = await prisma.collaboratorDocument.create({
     *   data: {
     *     // ... data to create a CollaboratorDocument
     *   }
     * })
     * 
    **/
    create<T extends CollaboratorDocumentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CollaboratorDocumentCreateArgs<ExtArgs>>
    ): Prisma__CollaboratorDocumentClient<$Types.GetResult<CollaboratorDocumentPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many CollaboratorDocuments.
     *     @param {CollaboratorDocumentCreateManyArgs} args - Arguments to create many CollaboratorDocuments.
     *     @example
     *     // Create many CollaboratorDocuments
     *     const collaboratorDocument = await prisma.collaboratorDocument.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CollaboratorDocumentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CollaboratorDocumentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CollaboratorDocument.
     * @param {CollaboratorDocumentDeleteArgs} args - Arguments to delete one CollaboratorDocument.
     * @example
     * // Delete one CollaboratorDocument
     * const CollaboratorDocument = await prisma.collaboratorDocument.delete({
     *   where: {
     *     // ... filter to delete one CollaboratorDocument
     *   }
     * })
     * 
    **/
    delete<T extends CollaboratorDocumentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CollaboratorDocumentDeleteArgs<ExtArgs>>
    ): Prisma__CollaboratorDocumentClient<$Types.GetResult<CollaboratorDocumentPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one CollaboratorDocument.
     * @param {CollaboratorDocumentUpdateArgs} args - Arguments to update one CollaboratorDocument.
     * @example
     * // Update one CollaboratorDocument
     * const collaboratorDocument = await prisma.collaboratorDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CollaboratorDocumentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CollaboratorDocumentUpdateArgs<ExtArgs>>
    ): Prisma__CollaboratorDocumentClient<$Types.GetResult<CollaboratorDocumentPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more CollaboratorDocuments.
     * @param {CollaboratorDocumentDeleteManyArgs} args - Arguments to filter CollaboratorDocuments to delete.
     * @example
     * // Delete a few CollaboratorDocuments
     * const { count } = await prisma.collaboratorDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CollaboratorDocumentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CollaboratorDocumentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CollaboratorDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaboratorDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CollaboratorDocuments
     * const collaboratorDocument = await prisma.collaboratorDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CollaboratorDocumentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CollaboratorDocumentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CollaboratorDocument.
     * @param {CollaboratorDocumentUpsertArgs} args - Arguments to update or create a CollaboratorDocument.
     * @example
     * // Update or create a CollaboratorDocument
     * const collaboratorDocument = await prisma.collaboratorDocument.upsert({
     *   create: {
     *     // ... data to create a CollaboratorDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CollaboratorDocument we want to update
     *   }
     * })
    **/
    upsert<T extends CollaboratorDocumentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CollaboratorDocumentUpsertArgs<ExtArgs>>
    ): Prisma__CollaboratorDocumentClient<$Types.GetResult<CollaboratorDocumentPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of CollaboratorDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaboratorDocumentCountArgs} args - Arguments to filter CollaboratorDocuments to count.
     * @example
     * // Count the number of CollaboratorDocuments
     * const count = await prisma.collaboratorDocument.count({
     *   where: {
     *     // ... the filter for the CollaboratorDocuments we want to count
     *   }
     * })
    **/
    count<T extends CollaboratorDocumentCountArgs>(
      args?: Subset<T, CollaboratorDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CollaboratorDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CollaboratorDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaboratorDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CollaboratorDocumentAggregateArgs>(args: Subset<T, CollaboratorDocumentAggregateArgs>): Prisma.PrismaPromise<GetCollaboratorDocumentAggregateType<T>>

    /**
     * Group by CollaboratorDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaboratorDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CollaboratorDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CollaboratorDocumentGroupByArgs['orderBy'] }
        : { orderBy?: CollaboratorDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CollaboratorDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollaboratorDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CollaboratorDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CollaboratorDocumentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    collaborator<T extends CollaboratorArgs<ExtArgs> = {}>(args?: Subset<T, CollaboratorArgs<ExtArgs>>): Prisma__CollaboratorClient<$Types.GetResult<CollaboratorPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CollaboratorDocument base type for findUnique actions
   */
  export type CollaboratorDocumentFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollaboratorDocument
     */
    select?: CollaboratorDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorDocumentInclude<ExtArgs> | null
    /**
     * Filter, which CollaboratorDocument to fetch.
     */
    where: CollaboratorDocumentWhereUniqueInput
  }

  /**
   * CollaboratorDocument findUnique
   */
  export interface CollaboratorDocumentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CollaboratorDocumentFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CollaboratorDocument findUniqueOrThrow
   */
  export type CollaboratorDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollaboratorDocument
     */
    select?: CollaboratorDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorDocumentInclude<ExtArgs> | null
    /**
     * Filter, which CollaboratorDocument to fetch.
     */
    where: CollaboratorDocumentWhereUniqueInput
  }


  /**
   * CollaboratorDocument base type for findFirst actions
   */
  export type CollaboratorDocumentFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollaboratorDocument
     */
    select?: CollaboratorDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorDocumentInclude<ExtArgs> | null
    /**
     * Filter, which CollaboratorDocument to fetch.
     */
    where?: CollaboratorDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollaboratorDocuments to fetch.
     */
    orderBy?: Enumerable<CollaboratorDocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CollaboratorDocuments.
     */
    cursor?: CollaboratorDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollaboratorDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollaboratorDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CollaboratorDocuments.
     */
    distinct?: Enumerable<CollaboratorDocumentScalarFieldEnum>
  }

  /**
   * CollaboratorDocument findFirst
   */
  export interface CollaboratorDocumentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CollaboratorDocumentFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CollaboratorDocument findFirstOrThrow
   */
  export type CollaboratorDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollaboratorDocument
     */
    select?: CollaboratorDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorDocumentInclude<ExtArgs> | null
    /**
     * Filter, which CollaboratorDocument to fetch.
     */
    where?: CollaboratorDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollaboratorDocuments to fetch.
     */
    orderBy?: Enumerable<CollaboratorDocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CollaboratorDocuments.
     */
    cursor?: CollaboratorDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollaboratorDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollaboratorDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CollaboratorDocuments.
     */
    distinct?: Enumerable<CollaboratorDocumentScalarFieldEnum>
  }


  /**
   * CollaboratorDocument findMany
   */
  export type CollaboratorDocumentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollaboratorDocument
     */
    select?: CollaboratorDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorDocumentInclude<ExtArgs> | null
    /**
     * Filter, which CollaboratorDocuments to fetch.
     */
    where?: CollaboratorDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollaboratorDocuments to fetch.
     */
    orderBy?: Enumerable<CollaboratorDocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CollaboratorDocuments.
     */
    cursor?: CollaboratorDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollaboratorDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollaboratorDocuments.
     */
    skip?: number
    distinct?: Enumerable<CollaboratorDocumentScalarFieldEnum>
  }


  /**
   * CollaboratorDocument create
   */
  export type CollaboratorDocumentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollaboratorDocument
     */
    select?: CollaboratorDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a CollaboratorDocument.
     */
    data: XOR<CollaboratorDocumentCreateInput, CollaboratorDocumentUncheckedCreateInput>
  }


  /**
   * CollaboratorDocument createMany
   */
  export type CollaboratorDocumentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CollaboratorDocuments.
     */
    data: Enumerable<CollaboratorDocumentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CollaboratorDocument update
   */
  export type CollaboratorDocumentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollaboratorDocument
     */
    select?: CollaboratorDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a CollaboratorDocument.
     */
    data: XOR<CollaboratorDocumentUpdateInput, CollaboratorDocumentUncheckedUpdateInput>
    /**
     * Choose, which CollaboratorDocument to update.
     */
    where: CollaboratorDocumentWhereUniqueInput
  }


  /**
   * CollaboratorDocument updateMany
   */
  export type CollaboratorDocumentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CollaboratorDocuments.
     */
    data: XOR<CollaboratorDocumentUpdateManyMutationInput, CollaboratorDocumentUncheckedUpdateManyInput>
    /**
     * Filter which CollaboratorDocuments to update
     */
    where?: CollaboratorDocumentWhereInput
  }


  /**
   * CollaboratorDocument upsert
   */
  export type CollaboratorDocumentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollaboratorDocument
     */
    select?: CollaboratorDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the CollaboratorDocument to update in case it exists.
     */
    where: CollaboratorDocumentWhereUniqueInput
    /**
     * In case the CollaboratorDocument found by the `where` argument doesn't exist, create a new CollaboratorDocument with this data.
     */
    create: XOR<CollaboratorDocumentCreateInput, CollaboratorDocumentUncheckedCreateInput>
    /**
     * In case the CollaboratorDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CollaboratorDocumentUpdateInput, CollaboratorDocumentUncheckedUpdateInput>
  }


  /**
   * CollaboratorDocument delete
   */
  export type CollaboratorDocumentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollaboratorDocument
     */
    select?: CollaboratorDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorDocumentInclude<ExtArgs> | null
    /**
     * Filter which CollaboratorDocument to delete.
     */
    where: CollaboratorDocumentWhereUniqueInput
  }


  /**
   * CollaboratorDocument deleteMany
   */
  export type CollaboratorDocumentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CollaboratorDocuments to delete
     */
    where?: CollaboratorDocumentWhereInput
  }


  /**
   * CollaboratorDocument without action
   */
  export type CollaboratorDocumentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollaboratorDocument
     */
    select?: CollaboratorDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CollaboratorDocumentInclude<ExtArgs> | null
  }



  /**
   * Model Reward
   */


  export type AggregateReward = {
    _count: RewardCountAggregateOutputType | null
    _min: RewardMinAggregateOutputType | null
    _max: RewardMaxAggregateOutputType | null
  }

  export type RewardMinAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    descrition: string | null
    image: string | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RewardMaxAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    descrition: string | null
    image: string | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RewardCountAggregateOutputType = {
    id: number
    name: number
    url: number
    descrition: number
    image: number
    isDeprecated: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RewardMinAggregateInputType = {
    id?: true
    name?: true
    url?: true
    descrition?: true
    image?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RewardMaxAggregateInputType = {
    id?: true
    name?: true
    url?: true
    descrition?: true
    image?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RewardCountAggregateInputType = {
    id?: true
    name?: true
    url?: true
    descrition?: true
    image?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RewardAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reward to aggregate.
     */
    where?: RewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rewards to fetch.
     */
    orderBy?: Enumerable<RewardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rewards
    **/
    _count?: true | RewardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RewardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RewardMaxAggregateInputType
  }

  export type GetRewardAggregateType<T extends RewardAggregateArgs> = {
        [P in keyof T & keyof AggregateReward]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReward[P]>
      : GetScalarType<T[P], AggregateReward[P]>
  }




  export type RewardGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: RewardWhereInput
    orderBy?: Enumerable<RewardOrderByWithAggregationInput>
    by: RewardScalarFieldEnum[]
    having?: RewardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RewardCountAggregateInputType | true
    _min?: RewardMinAggregateInputType
    _max?: RewardMaxAggregateInputType
  }


  export type RewardGroupByOutputType = {
    id: string
    name: string
    url: string
    descrition: string
    image: string
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
    _count: RewardCountAggregateOutputType | null
    _min: RewardMinAggregateOutputType | null
    _max: RewardMaxAggregateOutputType | null
  }

  type GetRewardGroupByPayload<T extends RewardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RewardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RewardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RewardGroupByOutputType[P]>
            : GetScalarType<T[P], RewardGroupByOutputType[P]>
        }
      >
    >


  export type RewardSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    descrition?: boolean
    image?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["reward"]>

  export type RewardSelectScalar = {
    id?: boolean
    name?: boolean
    url?: boolean
    descrition?: boolean
    image?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  type RewardGetPayload<S extends boolean | null | undefined | RewardArgs> = $Types.GetResult<RewardPayload, S>

  type RewardCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<RewardFindManyArgs, 'select' | 'include'> & {
      select?: RewardCountAggregateInputType | true
    }

  export interface RewardDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reward'], meta: { name: 'Reward' } }
    /**
     * Find zero or one Reward that matches the filter.
     * @param {RewardFindUniqueArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RewardFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RewardFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Reward'> extends True ? Prisma__RewardClient<$Types.GetResult<RewardPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__RewardClient<$Types.GetResult<RewardPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Reward that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RewardFindUniqueOrThrowArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RewardFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RewardFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RewardClient<$Types.GetResult<RewardPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Reward that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardFindFirstArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RewardFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RewardFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Reward'> extends True ? Prisma__RewardClient<$Types.GetResult<RewardPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__RewardClient<$Types.GetResult<RewardPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Reward that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardFindFirstOrThrowArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RewardFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RewardFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RewardClient<$Types.GetResult<RewardPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Rewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rewards
     * const rewards = await prisma.reward.findMany()
     * 
     * // Get first 10 Rewards
     * const rewards = await prisma.reward.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rewardWithIdOnly = await prisma.reward.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RewardFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RewardFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<RewardPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Reward.
     * @param {RewardCreateArgs} args - Arguments to create a Reward.
     * @example
     * // Create one Reward
     * const Reward = await prisma.reward.create({
     *   data: {
     *     // ... data to create a Reward
     *   }
     * })
     * 
    **/
    create<T extends RewardCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RewardCreateArgs<ExtArgs>>
    ): Prisma__RewardClient<$Types.GetResult<RewardPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Rewards.
     *     @param {RewardCreateManyArgs} args - Arguments to create many Rewards.
     *     @example
     *     // Create many Rewards
     *     const reward = await prisma.reward.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RewardCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RewardCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Reward.
     * @param {RewardDeleteArgs} args - Arguments to delete one Reward.
     * @example
     * // Delete one Reward
     * const Reward = await prisma.reward.delete({
     *   where: {
     *     // ... filter to delete one Reward
     *   }
     * })
     * 
    **/
    delete<T extends RewardDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RewardDeleteArgs<ExtArgs>>
    ): Prisma__RewardClient<$Types.GetResult<RewardPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Reward.
     * @param {RewardUpdateArgs} args - Arguments to update one Reward.
     * @example
     * // Update one Reward
     * const reward = await prisma.reward.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RewardUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RewardUpdateArgs<ExtArgs>>
    ): Prisma__RewardClient<$Types.GetResult<RewardPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Rewards.
     * @param {RewardDeleteManyArgs} args - Arguments to filter Rewards to delete.
     * @example
     * // Delete a few Rewards
     * const { count } = await prisma.reward.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RewardDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RewardDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rewards
     * const reward = await prisma.reward.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RewardUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RewardUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reward.
     * @param {RewardUpsertArgs} args - Arguments to update or create a Reward.
     * @example
     * // Update or create a Reward
     * const reward = await prisma.reward.upsert({
     *   create: {
     *     // ... data to create a Reward
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reward we want to update
     *   }
     * })
    **/
    upsert<T extends RewardUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RewardUpsertArgs<ExtArgs>>
    ): Prisma__RewardClient<$Types.GetResult<RewardPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardCountArgs} args - Arguments to filter Rewards to count.
     * @example
     * // Count the number of Rewards
     * const count = await prisma.reward.count({
     *   where: {
     *     // ... the filter for the Rewards we want to count
     *   }
     * })
    **/
    count<T extends RewardCountArgs>(
      args?: Subset<T, RewardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RewardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RewardAggregateArgs>(args: Subset<T, RewardAggregateArgs>): Prisma.PrismaPromise<GetRewardAggregateType<T>>

    /**
     * Group by Reward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RewardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RewardGroupByArgs['orderBy'] }
        : { orderBy?: RewardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RewardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRewardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Reward.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RewardClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Reward base type for findUnique actions
   */
  export type RewardFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Filter, which Reward to fetch.
     */
    where: RewardWhereUniqueInput
  }

  /**
   * Reward findUnique
   */
  export interface RewardFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends RewardFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Reward findUniqueOrThrow
   */
  export type RewardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Filter, which Reward to fetch.
     */
    where: RewardWhereUniqueInput
  }


  /**
   * Reward base type for findFirst actions
   */
  export type RewardFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Filter, which Reward to fetch.
     */
    where?: RewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rewards to fetch.
     */
    orderBy?: Enumerable<RewardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rewards.
     */
    cursor?: RewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rewards.
     */
    distinct?: Enumerable<RewardScalarFieldEnum>
  }

  /**
   * Reward findFirst
   */
  export interface RewardFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends RewardFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Reward findFirstOrThrow
   */
  export type RewardFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Filter, which Reward to fetch.
     */
    where?: RewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rewards to fetch.
     */
    orderBy?: Enumerable<RewardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rewards.
     */
    cursor?: RewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rewards.
     */
    distinct?: Enumerable<RewardScalarFieldEnum>
  }


  /**
   * Reward findMany
   */
  export type RewardFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Filter, which Rewards to fetch.
     */
    where?: RewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rewards to fetch.
     */
    orderBy?: Enumerable<RewardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rewards.
     */
    cursor?: RewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rewards.
     */
    skip?: number
    distinct?: Enumerable<RewardScalarFieldEnum>
  }


  /**
   * Reward create
   */
  export type RewardCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * The data needed to create a Reward.
     */
    data: XOR<RewardCreateInput, RewardUncheckedCreateInput>
  }


  /**
   * Reward createMany
   */
  export type RewardCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rewards.
     */
    data: Enumerable<RewardCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Reward update
   */
  export type RewardUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * The data needed to update a Reward.
     */
    data: XOR<RewardUpdateInput, RewardUncheckedUpdateInput>
    /**
     * Choose, which Reward to update.
     */
    where: RewardWhereUniqueInput
  }


  /**
   * Reward updateMany
   */
  export type RewardUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rewards.
     */
    data: XOR<RewardUpdateManyMutationInput, RewardUncheckedUpdateManyInput>
    /**
     * Filter which Rewards to update
     */
    where?: RewardWhereInput
  }


  /**
   * Reward upsert
   */
  export type RewardUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * The filter to search for the Reward to update in case it exists.
     */
    where: RewardWhereUniqueInput
    /**
     * In case the Reward found by the `where` argument doesn't exist, create a new Reward with this data.
     */
    create: XOR<RewardCreateInput, RewardUncheckedCreateInput>
    /**
     * In case the Reward was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RewardUpdateInput, RewardUncheckedUpdateInput>
  }


  /**
   * Reward delete
   */
  export type RewardDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
    /**
     * Filter which Reward to delete.
     */
    where: RewardWhereUniqueInput
  }


  /**
   * Reward deleteMany
   */
  export type RewardDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rewards to delete
     */
    where?: RewardWhereInput
  }


  /**
   * Reward without action
   */
  export type RewardArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reward
     */
    select?: RewardSelect<ExtArgs> | null
  }



  /**
   * Model Country
   */


  export type AggregateCountry = {
    _count: CountryCountAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  export type CountryMinAggregateOutputType = {
    id: string | null
    name: string | null
    iso: string | null
    currency: string | null
    code: string | null
    flagUrl: string | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CountryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    iso: string | null
    currency: string | null
    code: string | null
    flagUrl: string | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CountryCountAggregateOutputType = {
    id: number
    name: number
    iso: number
    currency: number
    code: number
    flagUrl: number
    isDeprecated: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CountryMinAggregateInputType = {
    id?: true
    name?: true
    iso?: true
    currency?: true
    code?: true
    flagUrl?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CountryMaxAggregateInputType = {
    id?: true
    name?: true
    iso?: true
    currency?: true
    code?: true
    flagUrl?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CountryCountAggregateInputType = {
    id?: true
    name?: true
    iso?: true
    currency?: true
    code?: true
    flagUrl?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CountryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Country to aggregate.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: Enumerable<CountryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Countries
    **/
    _count?: true | CountryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountryMaxAggregateInputType
  }

  export type GetCountryAggregateType<T extends CountryAggregateArgs> = {
        [P in keyof T & keyof AggregateCountry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountry[P]>
      : GetScalarType<T[P], AggregateCountry[P]>
  }




  export type CountryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CountryWhereInput
    orderBy?: Enumerable<CountryOrderByWithAggregationInput>
    by: CountryScalarFieldEnum[]
    having?: CountryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountryCountAggregateInputType | true
    _min?: CountryMinAggregateInputType
    _max?: CountryMaxAggregateInputType
  }


  export type CountryGroupByOutputType = {
    id: string
    name: string
    iso: string
    currency: string
    code: string
    flagUrl: string
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
    _count: CountryCountAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  type GetCountryGroupByPayload<T extends CountryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CountryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountryGroupByOutputType[P]>
            : GetScalarType<T[P], CountryGroupByOutputType[P]>
        }
      >
    >


  export type CountrySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    iso?: boolean
    currency?: boolean
    code?: boolean
    flagUrl?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["country"]>

  export type CountrySelectScalar = {
    id?: boolean
    name?: boolean
    iso?: boolean
    currency?: boolean
    code?: boolean
    flagUrl?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  type CountryGetPayload<S extends boolean | null | undefined | CountryArgs> = $Types.GetResult<CountryPayload, S>

  type CountryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CountryFindManyArgs, 'select' | 'include'> & {
      select?: CountryCountAggregateInputType | true
    }

  export interface CountryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Country'], meta: { name: 'Country' } }
    /**
     * Find zero or one Country that matches the filter.
     * @param {CountryFindUniqueArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CountryFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CountryFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Country'> extends True ? Prisma__CountryClient<$Types.GetResult<CountryPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__CountryClient<$Types.GetResult<CountryPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Country that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CountryFindUniqueOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CountryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CountryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CountryClient<$Types.GetResult<CountryPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Country that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CountryFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CountryFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Country'> extends True ? Prisma__CountryClient<$Types.GetResult<CountryPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__CountryClient<$Types.GetResult<CountryPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Country that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CountryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CountryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CountryClient<$Types.GetResult<CountryPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.country.findMany()
     * 
     * // Get first 10 Countries
     * const countries = await prisma.country.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const countryWithIdOnly = await prisma.country.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CountryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CountryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<CountryPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Country.
     * @param {CountryCreateArgs} args - Arguments to create a Country.
     * @example
     * // Create one Country
     * const Country = await prisma.country.create({
     *   data: {
     *     // ... data to create a Country
     *   }
     * })
     * 
    **/
    create<T extends CountryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CountryCreateArgs<ExtArgs>>
    ): Prisma__CountryClient<$Types.GetResult<CountryPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Countries.
     *     @param {CountryCreateManyArgs} args - Arguments to create many Countries.
     *     @example
     *     // Create many Countries
     *     const country = await prisma.country.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CountryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CountryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Country.
     * @param {CountryDeleteArgs} args - Arguments to delete one Country.
     * @example
     * // Delete one Country
     * const Country = await prisma.country.delete({
     *   where: {
     *     // ... filter to delete one Country
     *   }
     * })
     * 
    **/
    delete<T extends CountryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CountryDeleteArgs<ExtArgs>>
    ): Prisma__CountryClient<$Types.GetResult<CountryPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Country.
     * @param {CountryUpdateArgs} args - Arguments to update one Country.
     * @example
     * // Update one Country
     * const country = await prisma.country.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CountryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CountryUpdateArgs<ExtArgs>>
    ): Prisma__CountryClient<$Types.GetResult<CountryPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Countries.
     * @param {CountryDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.country.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CountryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CountryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CountryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CountryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Country.
     * @param {CountryUpsertArgs} args - Arguments to update or create a Country.
     * @example
     * // Update or create a Country
     * const country = await prisma.country.upsert({
     *   create: {
     *     // ... data to create a Country
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Country we want to update
     *   }
     * })
    **/
    upsert<T extends CountryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CountryUpsertArgs<ExtArgs>>
    ): Prisma__CountryClient<$Types.GetResult<CountryPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.country.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends CountryCountArgs>(
      args?: Subset<T, CountryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountryAggregateArgs>(args: Subset<T, CountryAggregateArgs>): Prisma.PrismaPromise<GetCountryAggregateType<T>>

    /**
     * Group by Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountryGroupByArgs['orderBy'] }
        : { orderBy?: CountryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Country.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CountryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Country base type for findUnique actions
   */
  export type CountryFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findUnique
   */
  export interface CountryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CountryFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Country findUniqueOrThrow
   */
  export type CountryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }


  /**
   * Country base type for findFirst actions
   */
  export type CountryFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: Enumerable<CountryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: Enumerable<CountryScalarFieldEnum>
  }

  /**
   * Country findFirst
   */
  export interface CountryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CountryFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Country findFirstOrThrow
   */
  export type CountryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: Enumerable<CountryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: Enumerable<CountryScalarFieldEnum>
  }


  /**
   * Country findMany
   */
  export type CountryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Filter, which Countries to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: Enumerable<CountryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    distinct?: Enumerable<CountryScalarFieldEnum>
  }


  /**
   * Country create
   */
  export type CountryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * The data needed to create a Country.
     */
    data: XOR<CountryCreateInput, CountryUncheckedCreateInput>
  }


  /**
   * Country createMany
   */
  export type CountryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Countries.
     */
    data: Enumerable<CountryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Country update
   */
  export type CountryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * The data needed to update a Country.
     */
    data: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
    /**
     * Choose, which Country to update.
     */
    where: CountryWhereUniqueInput
  }


  /**
   * Country updateMany
   */
  export type CountryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Countries.
     */
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyInput>
    /**
     * Filter which Countries to update
     */
    where?: CountryWhereInput
  }


  /**
   * Country upsert
   */
  export type CountryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * The filter to search for the Country to update in case it exists.
     */
    where: CountryWhereUniqueInput
    /**
     * In case the Country found by the `where` argument doesn't exist, create a new Country with this data.
     */
    create: XOR<CountryCreateInput, CountryUncheckedCreateInput>
    /**
     * In case the Country was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
  }


  /**
   * Country delete
   */
  export type CountryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Filter which Country to delete.
     */
    where: CountryWhereUniqueInput
  }


  /**
   * Country deleteMany
   */
  export type CountryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Countries to delete
     */
    where?: CountryWhereInput
  }


  /**
   * Country without action
   */
  export type CountryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
  }



  /**
   * Model Bank
   */


  export type AggregateBank = {
    _count: BankCountAggregateOutputType | null
    _min: BankMinAggregateOutputType | null
    _max: BankMaxAggregateOutputType | null
  }

  export type BankMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    url: string | null
    image: string | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    url: string | null
    image: string | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankCountAggregateOutputType = {
    id: number
    name: number
    code: number
    url: number
    image: number
    isDeprecated: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BankMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    url?: true
    image?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    url?: true
    image?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    url?: true
    image?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BankAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bank to aggregate.
     */
    where?: BankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banks to fetch.
     */
    orderBy?: Enumerable<BankOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Banks
    **/
    _count?: true | BankCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BankMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BankMaxAggregateInputType
  }

  export type GetBankAggregateType<T extends BankAggregateArgs> = {
        [P in keyof T & keyof AggregateBank]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBank[P]>
      : GetScalarType<T[P], AggregateBank[P]>
  }




  export type BankGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BankWhereInput
    orderBy?: Enumerable<BankOrderByWithAggregationInput>
    by: BankScalarFieldEnum[]
    having?: BankScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BankCountAggregateInputType | true
    _min?: BankMinAggregateInputType
    _max?: BankMaxAggregateInputType
  }


  export type BankGroupByOutputType = {
    id: string
    name: string
    code: string
    url: string
    image: string
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
    _count: BankCountAggregateOutputType | null
    _min: BankMinAggregateOutputType | null
    _max: BankMaxAggregateOutputType | null
  }

  type GetBankGroupByPayload<T extends BankGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BankGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BankGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BankGroupByOutputType[P]>
            : GetScalarType<T[P], BankGroupByOutputType[P]>
        }
      >
    >


  export type BankSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    url?: boolean
    image?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["bank"]>

  export type BankSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    url?: boolean
    image?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  type BankGetPayload<S extends boolean | null | undefined | BankArgs> = $Types.GetResult<BankPayload, S>

  type BankCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<BankFindManyArgs, 'select' | 'include'> & {
      select?: BankCountAggregateInputType | true
    }

  export interface BankDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bank'], meta: { name: 'Bank' } }
    /**
     * Find zero or one Bank that matches the filter.
     * @param {BankFindUniqueArgs} args - Arguments to find a Bank
     * @example
     * // Get one Bank
     * const bank = await prisma.bank.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BankFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BankFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Bank'> extends True ? Prisma__BankClient<$Types.GetResult<BankPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__BankClient<$Types.GetResult<BankPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Bank that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BankFindUniqueOrThrowArgs} args - Arguments to find a Bank
     * @example
     * // Get one Bank
     * const bank = await prisma.bank.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BankFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BankFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BankClient<$Types.GetResult<BankPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Bank that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankFindFirstArgs} args - Arguments to find a Bank
     * @example
     * // Get one Bank
     * const bank = await prisma.bank.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BankFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BankFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Bank'> extends True ? Prisma__BankClient<$Types.GetResult<BankPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__BankClient<$Types.GetResult<BankPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Bank that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankFindFirstOrThrowArgs} args - Arguments to find a Bank
     * @example
     * // Get one Bank
     * const bank = await prisma.bank.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BankFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BankFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BankClient<$Types.GetResult<BankPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Banks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Banks
     * const banks = await prisma.bank.findMany()
     * 
     * // Get first 10 Banks
     * const banks = await prisma.bank.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bankWithIdOnly = await prisma.bank.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BankFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BankFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<BankPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Bank.
     * @param {BankCreateArgs} args - Arguments to create a Bank.
     * @example
     * // Create one Bank
     * const Bank = await prisma.bank.create({
     *   data: {
     *     // ... data to create a Bank
     *   }
     * })
     * 
    **/
    create<T extends BankCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BankCreateArgs<ExtArgs>>
    ): Prisma__BankClient<$Types.GetResult<BankPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Banks.
     *     @param {BankCreateManyArgs} args - Arguments to create many Banks.
     *     @example
     *     // Create many Banks
     *     const bank = await prisma.bank.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BankCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BankCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bank.
     * @param {BankDeleteArgs} args - Arguments to delete one Bank.
     * @example
     * // Delete one Bank
     * const Bank = await prisma.bank.delete({
     *   where: {
     *     // ... filter to delete one Bank
     *   }
     * })
     * 
    **/
    delete<T extends BankDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BankDeleteArgs<ExtArgs>>
    ): Prisma__BankClient<$Types.GetResult<BankPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Bank.
     * @param {BankUpdateArgs} args - Arguments to update one Bank.
     * @example
     * // Update one Bank
     * const bank = await prisma.bank.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BankUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BankUpdateArgs<ExtArgs>>
    ): Prisma__BankClient<$Types.GetResult<BankPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Banks.
     * @param {BankDeleteManyArgs} args - Arguments to filter Banks to delete.
     * @example
     * // Delete a few Banks
     * const { count } = await prisma.bank.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BankDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BankDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Banks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Banks
     * const bank = await prisma.bank.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BankUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BankUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bank.
     * @param {BankUpsertArgs} args - Arguments to update or create a Bank.
     * @example
     * // Update or create a Bank
     * const bank = await prisma.bank.upsert({
     *   create: {
     *     // ... data to create a Bank
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bank we want to update
     *   }
     * })
    **/
    upsert<T extends BankUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BankUpsertArgs<ExtArgs>>
    ): Prisma__BankClient<$Types.GetResult<BankPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Banks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankCountArgs} args - Arguments to filter Banks to count.
     * @example
     * // Count the number of Banks
     * const count = await prisma.bank.count({
     *   where: {
     *     // ... the filter for the Banks we want to count
     *   }
     * })
    **/
    count<T extends BankCountArgs>(
      args?: Subset<T, BankCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BankCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bank.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BankAggregateArgs>(args: Subset<T, BankAggregateArgs>): Prisma.PrismaPromise<GetBankAggregateType<T>>

    /**
     * Group by Bank.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BankGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BankGroupByArgs['orderBy'] }
        : { orderBy?: BankGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BankGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBankGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Bank.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BankClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Bank base type for findUnique actions
   */
  export type BankFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
    /**
     * Filter, which Bank to fetch.
     */
    where: BankWhereUniqueInput
  }

  /**
   * Bank findUnique
   */
  export interface BankFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BankFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Bank findUniqueOrThrow
   */
  export type BankFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
    /**
     * Filter, which Bank to fetch.
     */
    where: BankWhereUniqueInput
  }


  /**
   * Bank base type for findFirst actions
   */
  export type BankFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
    /**
     * Filter, which Bank to fetch.
     */
    where?: BankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banks to fetch.
     */
    orderBy?: Enumerable<BankOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Banks.
     */
    cursor?: BankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Banks.
     */
    distinct?: Enumerable<BankScalarFieldEnum>
  }

  /**
   * Bank findFirst
   */
  export interface BankFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BankFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Bank findFirstOrThrow
   */
  export type BankFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
    /**
     * Filter, which Bank to fetch.
     */
    where?: BankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banks to fetch.
     */
    orderBy?: Enumerable<BankOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Banks.
     */
    cursor?: BankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Banks.
     */
    distinct?: Enumerable<BankScalarFieldEnum>
  }


  /**
   * Bank findMany
   */
  export type BankFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
    /**
     * Filter, which Banks to fetch.
     */
    where?: BankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banks to fetch.
     */
    orderBy?: Enumerable<BankOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Banks.
     */
    cursor?: BankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banks.
     */
    skip?: number
    distinct?: Enumerable<BankScalarFieldEnum>
  }


  /**
   * Bank create
   */
  export type BankCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
    /**
     * The data needed to create a Bank.
     */
    data: XOR<BankCreateInput, BankUncheckedCreateInput>
  }


  /**
   * Bank createMany
   */
  export type BankCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Banks.
     */
    data: Enumerable<BankCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Bank update
   */
  export type BankUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
    /**
     * The data needed to update a Bank.
     */
    data: XOR<BankUpdateInput, BankUncheckedUpdateInput>
    /**
     * Choose, which Bank to update.
     */
    where: BankWhereUniqueInput
  }


  /**
   * Bank updateMany
   */
  export type BankUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Banks.
     */
    data: XOR<BankUpdateManyMutationInput, BankUncheckedUpdateManyInput>
    /**
     * Filter which Banks to update
     */
    where?: BankWhereInput
  }


  /**
   * Bank upsert
   */
  export type BankUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
    /**
     * The filter to search for the Bank to update in case it exists.
     */
    where: BankWhereUniqueInput
    /**
     * In case the Bank found by the `where` argument doesn't exist, create a new Bank with this data.
     */
    create: XOR<BankCreateInput, BankUncheckedCreateInput>
    /**
     * In case the Bank was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BankUpdateInput, BankUncheckedUpdateInput>
  }


  /**
   * Bank delete
   */
  export type BankDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
    /**
     * Filter which Bank to delete.
     */
    where: BankWhereUniqueInput
  }


  /**
   * Bank deleteMany
   */
  export type BankDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Banks to delete
     */
    where?: BankWhereInput
  }


  /**
   * Bank without action
   */
  export type BankArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect<ExtArgs> | null
  }



  /**
   * Model Notification
   */


  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    title: string | null
    body: string | null
    readStatus: boolean | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    title: string | null
    body: string | null
    readStatus: boolean | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    title: number
    body: number
    readStatus: number
    isDeprecated: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    title?: true
    body?: true
    readStatus?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    title?: true
    body?: true
    readStatus?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    title?: true
    body?: true
    readStatus?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: Enumerable<NotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: Enumerable<NotificationOrderByWithAggregationInput>
    by: NotificationScalarFieldEnum[]
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }


  export type NotificationGroupByOutputType = {
    id: string
    title: string
    body: string
    readStatus: boolean
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    body?: boolean
    readStatus?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    title?: boolean
    body?: boolean
    readStatus?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  type NotificationGetPayload<S extends boolean | null | undefined | NotificationArgs> = $Types.GetResult<NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NotificationFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Notification'> extends True ? Prisma__NotificationClient<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__NotificationClient<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NotificationFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Notification'> extends True ? Prisma__NotificationClient<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__NotificationClient<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NotificationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
    **/
    create<T extends NotificationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Notifications.
     *     @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     *     @example
     *     // Create many Notifications
     *     const notification = await prisma.notification.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NotificationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
    **/
    delete<T extends NotificationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NotificationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NotificationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NotificationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
    **/
    upsert<T extends NotificationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Notification base type for findUnique actions
   */
  export type NotificationFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUnique
   */
  export interface NotificationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends NotificationFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification base type for findFirst actions
   */
  export type NotificationFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: Enumerable<NotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }

  /**
   * Notification findFirst
   */
  export interface NotificationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends NotificationFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: Enumerable<NotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }


  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: Enumerable<NotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }


  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }


  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: Enumerable<NotificationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }


  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }


  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }


  /**
   * Notification without action
   */
  export type NotificationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
  }



  /**
   * Model Account
   */


  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    scope: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    scope: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    scope: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    scope?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    scope?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    scope?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: Enumerable<AccountOrderByWithAggregationInput>
    by: AccountScalarFieldEnum[]
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }


  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    scope: string
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    scope?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    scope?: boolean
  }

  export type AccountInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type AccountGetPayload<S extends boolean | null | undefined | AccountArgs> = $Types.GetResult<AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AccountFindManyArgs, 'select' | 'include'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccountFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Account'> extends True ? Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Account that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccountFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Account'> extends True ? Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Account that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AccountFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
    **/
    create<T extends AccountCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AccountCreateArgs<ExtArgs>>
    ): Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Accounts.
     *     @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     *     @example
     *     // Create many Accounts
     *     const account = await prisma.account.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AccountCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
    **/
    delete<T extends AccountDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>
    ): Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccountUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>
    ): Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccountDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccountUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
    **/
    upsert<T extends AccountUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>
    ): Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Account base type for findUnique actions
   */
  export type AccountFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUnique
   */
  export interface AccountFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AccountFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account base type for findFirst actions
   */
  export type AccountFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: Enumerable<AccountScalarFieldEnum>
  }

  /**
   * Account findFirst
   */
  export interface AccountFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AccountFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: Enumerable<AccountScalarFieldEnum>
  }


  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: Enumerable<AccountScalarFieldEnum>
  }


  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }


  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: Enumerable<AccountCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
  }


  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }


  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
  }


  /**
   * Account without action
   */
  export type AccountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    fullName: string | null
    username: string | null
    email: string | null
    password: string | null
    phone: string | null
    picture: string | null
    isVerified: boolean | null
    referral: string | null
    country: string | null
    resetToken: string | null
    isPartner: boolean | null
    isStaff: boolean | null
    isPhoneRegistered: boolean | null
    isPhoneVerified: boolean | null
    isIdentificationRegistered: boolean | null
    isIdentificationVerified: boolean | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    fullName: string | null
    username: string | null
    email: string | null
    password: string | null
    phone: string | null
    picture: string | null
    isVerified: boolean | null
    referral: string | null
    country: string | null
    resetToken: string | null
    isPartner: boolean | null
    isStaff: boolean | null
    isPhoneRegistered: boolean | null
    isPhoneVerified: boolean | null
    isIdentificationRegistered: boolean | null
    isIdentificationVerified: boolean | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    fullName: number
    username: number
    email: number
    password: number
    phone: number
    picture: number
    isVerified: number
    referral: number
    country: number
    resetToken: number
    isPartner: number
    isStaff: number
    isPhoneRegistered: number
    isPhoneVerified: number
    isIdentificationRegistered: number
    isIdentificationVerified: number
    partnerPermission: number
    staffPermission: number
    userPermission: number
    isDeprecated: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    fullName?: true
    username?: true
    email?: true
    password?: true
    phone?: true
    picture?: true
    isVerified?: true
    referral?: true
    country?: true
    resetToken?: true
    isPartner?: true
    isStaff?: true
    isPhoneRegistered?: true
    isPhoneVerified?: true
    isIdentificationRegistered?: true
    isIdentificationVerified?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    fullName?: true
    username?: true
    email?: true
    password?: true
    phone?: true
    picture?: true
    isVerified?: true
    referral?: true
    country?: true
    resetToken?: true
    isPartner?: true
    isStaff?: true
    isPhoneRegistered?: true
    isPhoneVerified?: true
    isIdentificationRegistered?: true
    isIdentificationVerified?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    fullName?: true
    username?: true
    email?: true
    password?: true
    phone?: true
    picture?: true
    isVerified?: true
    referral?: true
    country?: true
    resetToken?: true
    isPartner?: true
    isStaff?: true
    isPhoneRegistered?: true
    isPhoneVerified?: true
    isIdentificationRegistered?: true
    isIdentificationVerified?: true
    partnerPermission?: true
    staffPermission?: true
    userPermission?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    fullName: string
    username: string | null
    email: string
    password: string
    phone: string | null
    picture: string | null
    isVerified: boolean
    referral: string
    country: string | null
    resetToken: string | null
    isPartner: boolean
    isStaff: boolean
    isPhoneRegistered: boolean
    isPhoneVerified: boolean
    isIdentificationRegistered: boolean
    isIdentificationVerified: boolean
    partnerPermission: string[]
    staffPermission: string[]
    userPermission: string[]
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    picture?: boolean
    isVerified?: boolean
    referral?: boolean
    country?: boolean
    resetToken?: boolean
    isPartner?: boolean
    isStaff?: boolean
    isPhoneRegistered?: boolean
    isPhoneVerified?: boolean
    isIdentificationRegistered?: boolean
    isIdentificationVerified?: boolean
    partnerPermission?: boolean
    staffPermission?: boolean
    userPermission?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teamMember?: boolean | User$teamMemberArgs<ExtArgs>
    account?: boolean | User$accountArgs<ExtArgs>
    product?: boolean | User$productArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    fullName?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    picture?: boolean
    isVerified?: boolean
    referral?: boolean
    country?: boolean
    resetToken?: boolean
    isPartner?: boolean
    isStaff?: boolean
    isPhoneRegistered?: boolean
    isPhoneVerified?: boolean
    isIdentificationRegistered?: boolean
    isIdentificationVerified?: boolean
    partnerPermission?: boolean
    staffPermission?: boolean
    userPermission?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    teamMember?: boolean | User$teamMemberArgs<ExtArgs>
    account?: boolean | User$accountArgs<ExtArgs>
    product?: boolean | User$productArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeArgs<ExtArgs>
  }


  type UserGetPayload<S extends boolean | null | undefined | UserArgs> = $Types.GetResult<UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<UserPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    teamMember<T extends User$teamMemberArgs<ExtArgs> = {}>(args?: Subset<T, User$teamMemberArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<TeamMemberPayload<ExtArgs>, T, 'findMany', never>| Null>;

    account<T extends User$accountArgs<ExtArgs> = {}>(args?: Subset<T, User$accountArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findMany', never>| Null>;

    product<T extends User$productArgs<ExtArgs> = {}>(args?: Subset<T, User$productArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUnique
   */
  export interface UserFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User findFirst
   */
  export interface UserFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.teamMember
   */
  export type User$teamMemberArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamMemberInclude<ExtArgs> | null
    where?: TeamMemberWhereInput
    orderBy?: Enumerable<TeamMemberOrderByWithRelationInput>
    cursor?: TeamMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TeamMemberScalarFieldEnum>
  }


  /**
   * User.account
   */
  export type User$accountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AccountScalarFieldEnum>
  }


  /**
   * User.product
   */
  export type User$productArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * User without action
   */
  export type UserArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model UserDocument
   */


  export type AggregateUserDocument = {
    _count: UserDocumentCountAggregateOutputType | null
    _min: UserDocumentMinAggregateOutputType | null
    _max: UserDocumentMaxAggregateOutputType | null
  }

  export type UserDocumentMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    description: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserDocumentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    description: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserDocumentCountAggregateOutputType = {
    id: number
    name: number
    type: number
    description: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserDocumentMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserDocumentMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserDocumentCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserDocumentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserDocument to aggregate.
     */
    where?: UserDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDocuments to fetch.
     */
    orderBy?: Enumerable<UserDocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserDocuments
    **/
    _count?: true | UserDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserDocumentMaxAggregateInputType
  }

  export type GetUserDocumentAggregateType<T extends UserDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateUserDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserDocument[P]>
      : GetScalarType<T[P], AggregateUserDocument[P]>
  }




  export type UserDocumentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserDocumentWhereInput
    orderBy?: Enumerable<UserDocumentOrderByWithAggregationInput>
    by: UserDocumentScalarFieldEnum[]
    having?: UserDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserDocumentCountAggregateInputType | true
    _min?: UserDocumentMinAggregateInputType
    _max?: UserDocumentMaxAggregateInputType
  }


  export type UserDocumentGroupByOutputType = {
    id: string
    name: string
    type: string
    description: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: UserDocumentCountAggregateOutputType | null
    _min: UserDocumentMinAggregateOutputType | null
    _max: UserDocumentMaxAggregateOutputType | null
  }

  type GetUserDocumentGroupByPayload<T extends UserDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], UserDocumentGroupByOutputType[P]>
        }
      >
    >


  export type UserDocumentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["userDocument"]>

  export type UserDocumentSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  type UserDocumentGetPayload<S extends boolean | null | undefined | UserDocumentArgs> = $Types.GetResult<UserDocumentPayload, S>

  type UserDocumentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserDocumentFindManyArgs, 'select' | 'include'> & {
      select?: UserDocumentCountAggregateInputType | true
    }

  export interface UserDocumentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserDocument'], meta: { name: 'UserDocument' } }
    /**
     * Find zero or one UserDocument that matches the filter.
     * @param {UserDocumentFindUniqueArgs} args - Arguments to find a UserDocument
     * @example
     * // Get one UserDocument
     * const userDocument = await prisma.userDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserDocumentFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserDocumentFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserDocument'> extends True ? Prisma__UserDocumentClient<$Types.GetResult<UserDocumentPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__UserDocumentClient<$Types.GetResult<UserDocumentPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one UserDocument that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserDocumentFindUniqueOrThrowArgs} args - Arguments to find a UserDocument
     * @example
     * // Get one UserDocument
     * const userDocument = await prisma.userDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserDocumentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDocumentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserDocumentClient<$Types.GetResult<UserDocumentPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first UserDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDocumentFindFirstArgs} args - Arguments to find a UserDocument
     * @example
     * // Get one UserDocument
     * const userDocument = await prisma.userDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserDocumentFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserDocumentFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserDocument'> extends True ? Prisma__UserDocumentClient<$Types.GetResult<UserDocumentPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__UserDocumentClient<$Types.GetResult<UserDocumentPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first UserDocument that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDocumentFindFirstOrThrowArgs} args - Arguments to find a UserDocument
     * @example
     * // Get one UserDocument
     * const userDocument = await prisma.userDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserDocumentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDocumentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserDocumentClient<$Types.GetResult<UserDocumentPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more UserDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDocumentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserDocuments
     * const userDocuments = await prisma.userDocument.findMany()
     * 
     * // Get first 10 UserDocuments
     * const userDocuments = await prisma.userDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userDocumentWithIdOnly = await prisma.userDocument.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserDocumentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDocumentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<UserDocumentPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a UserDocument.
     * @param {UserDocumentCreateArgs} args - Arguments to create a UserDocument.
     * @example
     * // Create one UserDocument
     * const UserDocument = await prisma.userDocument.create({
     *   data: {
     *     // ... data to create a UserDocument
     *   }
     * })
     * 
    **/
    create<T extends UserDocumentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserDocumentCreateArgs<ExtArgs>>
    ): Prisma__UserDocumentClient<$Types.GetResult<UserDocumentPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many UserDocuments.
     *     @param {UserDocumentCreateManyArgs} args - Arguments to create many UserDocuments.
     *     @example
     *     // Create many UserDocuments
     *     const userDocument = await prisma.userDocument.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserDocumentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDocumentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserDocument.
     * @param {UserDocumentDeleteArgs} args - Arguments to delete one UserDocument.
     * @example
     * // Delete one UserDocument
     * const UserDocument = await prisma.userDocument.delete({
     *   where: {
     *     // ... filter to delete one UserDocument
     *   }
     * })
     * 
    **/
    delete<T extends UserDocumentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDocumentDeleteArgs<ExtArgs>>
    ): Prisma__UserDocumentClient<$Types.GetResult<UserDocumentPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one UserDocument.
     * @param {UserDocumentUpdateArgs} args - Arguments to update one UserDocument.
     * @example
     * // Update one UserDocument
     * const userDocument = await prisma.userDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserDocumentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserDocumentUpdateArgs<ExtArgs>>
    ): Prisma__UserDocumentClient<$Types.GetResult<UserDocumentPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more UserDocuments.
     * @param {UserDocumentDeleteManyArgs} args - Arguments to filter UserDocuments to delete.
     * @example
     * // Delete a few UserDocuments
     * const { count } = await prisma.userDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDocumentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDocumentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserDocuments
     * const userDocument = await prisma.userDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserDocumentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserDocumentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserDocument.
     * @param {UserDocumentUpsertArgs} args - Arguments to update or create a UserDocument.
     * @example
     * // Update or create a UserDocument
     * const userDocument = await prisma.userDocument.upsert({
     *   create: {
     *     // ... data to create a UserDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserDocument we want to update
     *   }
     * })
    **/
    upsert<T extends UserDocumentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserDocumentUpsertArgs<ExtArgs>>
    ): Prisma__UserDocumentClient<$Types.GetResult<UserDocumentPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of UserDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDocumentCountArgs} args - Arguments to filter UserDocuments to count.
     * @example
     * // Count the number of UserDocuments
     * const count = await prisma.userDocument.count({
     *   where: {
     *     // ... the filter for the UserDocuments we want to count
     *   }
     * })
    **/
    count<T extends UserDocumentCountArgs>(
      args?: Subset<T, UserDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserDocumentAggregateArgs>(args: Subset<T, UserDocumentAggregateArgs>): Prisma.PrismaPromise<GetUserDocumentAggregateType<T>>

    /**
     * Group by UserDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserDocumentGroupByArgs['orderBy'] }
        : { orderBy?: UserDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserDocumentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserDocument base type for findUnique actions
   */
  export type UserDocumentFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocument
     */
    select?: UserDocumentSelect<ExtArgs> | null
    /**
     * Filter, which UserDocument to fetch.
     */
    where: UserDocumentWhereUniqueInput
  }

  /**
   * UserDocument findUnique
   */
  export interface UserDocumentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserDocumentFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserDocument findUniqueOrThrow
   */
  export type UserDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocument
     */
    select?: UserDocumentSelect<ExtArgs> | null
    /**
     * Filter, which UserDocument to fetch.
     */
    where: UserDocumentWhereUniqueInput
  }


  /**
   * UserDocument base type for findFirst actions
   */
  export type UserDocumentFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocument
     */
    select?: UserDocumentSelect<ExtArgs> | null
    /**
     * Filter, which UserDocument to fetch.
     */
    where?: UserDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDocuments to fetch.
     */
    orderBy?: Enumerable<UserDocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserDocuments.
     */
    cursor?: UserDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserDocuments.
     */
    distinct?: Enumerable<UserDocumentScalarFieldEnum>
  }

  /**
   * UserDocument findFirst
   */
  export interface UserDocumentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserDocumentFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserDocument findFirstOrThrow
   */
  export type UserDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocument
     */
    select?: UserDocumentSelect<ExtArgs> | null
    /**
     * Filter, which UserDocument to fetch.
     */
    where?: UserDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDocuments to fetch.
     */
    orderBy?: Enumerable<UserDocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserDocuments.
     */
    cursor?: UserDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserDocuments.
     */
    distinct?: Enumerable<UserDocumentScalarFieldEnum>
  }


  /**
   * UserDocument findMany
   */
  export type UserDocumentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocument
     */
    select?: UserDocumentSelect<ExtArgs> | null
    /**
     * Filter, which UserDocuments to fetch.
     */
    where?: UserDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDocuments to fetch.
     */
    orderBy?: Enumerable<UserDocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserDocuments.
     */
    cursor?: UserDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDocuments.
     */
    skip?: number
    distinct?: Enumerable<UserDocumentScalarFieldEnum>
  }


  /**
   * UserDocument create
   */
  export type UserDocumentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocument
     */
    select?: UserDocumentSelect<ExtArgs> | null
    /**
     * The data needed to create a UserDocument.
     */
    data: XOR<UserDocumentCreateInput, UserDocumentUncheckedCreateInput>
  }


  /**
   * UserDocument createMany
   */
  export type UserDocumentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserDocuments.
     */
    data: Enumerable<UserDocumentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserDocument update
   */
  export type UserDocumentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocument
     */
    select?: UserDocumentSelect<ExtArgs> | null
    /**
     * The data needed to update a UserDocument.
     */
    data: XOR<UserDocumentUpdateInput, UserDocumentUncheckedUpdateInput>
    /**
     * Choose, which UserDocument to update.
     */
    where: UserDocumentWhereUniqueInput
  }


  /**
   * UserDocument updateMany
   */
  export type UserDocumentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserDocuments.
     */
    data: XOR<UserDocumentUpdateManyMutationInput, UserDocumentUncheckedUpdateManyInput>
    /**
     * Filter which UserDocuments to update
     */
    where?: UserDocumentWhereInput
  }


  /**
   * UserDocument upsert
   */
  export type UserDocumentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocument
     */
    select?: UserDocumentSelect<ExtArgs> | null
    /**
     * The filter to search for the UserDocument to update in case it exists.
     */
    where: UserDocumentWhereUniqueInput
    /**
     * In case the UserDocument found by the `where` argument doesn't exist, create a new UserDocument with this data.
     */
    create: XOR<UserDocumentCreateInput, UserDocumentUncheckedCreateInput>
    /**
     * In case the UserDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserDocumentUpdateInput, UserDocumentUncheckedUpdateInput>
  }


  /**
   * UserDocument delete
   */
  export type UserDocumentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocument
     */
    select?: UserDocumentSelect<ExtArgs> | null
    /**
     * Filter which UserDocument to delete.
     */
    where: UserDocumentWhereUniqueInput
  }


  /**
   * UserDocument deleteMany
   */
  export type UserDocumentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserDocuments to delete
     */
    where?: UserDocumentWhereInput
  }


  /**
   * UserDocument without action
   */
  export type UserDocumentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocument
     */
    select?: UserDocumentSelect<ExtArgs> | null
  }



  /**
   * Model ServiceCategory
   */


  export type AggregateServiceCategory = {
    _count: ServiceCategoryCountAggregateOutputType | null
    _min: ServiceCategoryMinAggregateOutputType | null
    _max: ServiceCategoryMaxAggregateOutputType | null
  }

  export type ServiceCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isDeprecated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isDeprecated: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceCategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isDeprecated?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceCategoryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceCategory to aggregate.
     */
    where?: ServiceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategories to fetch.
     */
    orderBy?: Enumerable<ServiceCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceCategories
    **/
    _count?: true | ServiceCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceCategoryMaxAggregateInputType
  }

  export type GetServiceCategoryAggregateType<T extends ServiceCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceCategory[P]>
      : GetScalarType<T[P], AggregateServiceCategory[P]>
  }




  export type ServiceCategoryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ServiceCategoryWhereInput
    orderBy?: Enumerable<ServiceCategoryOrderByWithAggregationInput>
    by: ServiceCategoryScalarFieldEnum[]
    having?: ServiceCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCategoryCountAggregateInputType | true
    _min?: ServiceCategoryMinAggregateInputType
    _max?: ServiceCategoryMaxAggregateInputType
  }


  export type ServiceCategoryGroupByOutputType = {
    id: string
    name: string
    description: string
    isDeprecated: boolean
    createdAt: Date
    updatedAt: Date
    _count: ServiceCategoryCountAggregateOutputType | null
    _min: ServiceCategoryMinAggregateOutputType | null
    _max: ServiceCategoryMaxAggregateOutputType | null
  }

  type GetServiceCategoryGroupByPayload<T extends ServiceCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ServiceCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ServiceCategorySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    services?: boolean | ServiceCategory$servicesArgs<ExtArgs>
    form?: boolean | ServiceCategory$formArgs<ExtArgs>
    _count?: boolean | ServiceCategoryCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["serviceCategory"]>

  export type ServiceCategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isDeprecated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceCategoryInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    services?: boolean | ServiceCategory$servicesArgs<ExtArgs>
    form?: boolean | ServiceCategory$formArgs<ExtArgs>
    _count?: boolean | ServiceCategoryCountOutputTypeArgs<ExtArgs>
  }


  type ServiceCategoryGetPayload<S extends boolean | null | undefined | ServiceCategoryArgs> = $Types.GetResult<ServiceCategoryPayload, S>

  type ServiceCategoryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ServiceCategoryFindManyArgs, 'select' | 'include'> & {
      select?: ServiceCategoryCountAggregateInputType | true
    }

  export interface ServiceCategoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceCategory'], meta: { name: 'ServiceCategory' } }
    /**
     * Find zero or one ServiceCategory that matches the filter.
     * @param {ServiceCategoryFindUniqueArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ServiceCategoryFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ServiceCategoryFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ServiceCategory'> extends True ? Prisma__ServiceCategoryClient<$Types.GetResult<ServiceCategoryPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ServiceCategoryClient<$Types.GetResult<ServiceCategoryPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ServiceCategory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ServiceCategoryFindUniqueOrThrowArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ServiceCategoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceCategoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceCategoryClient<$Types.GetResult<ServiceCategoryPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ServiceCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryFindFirstArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ServiceCategoryFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ServiceCategoryFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ServiceCategory'> extends True ? Prisma__ServiceCategoryClient<$Types.GetResult<ServiceCategoryPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ServiceCategoryClient<$Types.GetResult<ServiceCategoryPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ServiceCategory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryFindFirstOrThrowArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ServiceCategoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceCategoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceCategoryClient<$Types.GetResult<ServiceCategoryPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more ServiceCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceCategories
     * const serviceCategories = await prisma.serviceCategory.findMany()
     * 
     * // Get first 10 ServiceCategories
     * const serviceCategories = await prisma.serviceCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceCategoryWithIdOnly = await prisma.serviceCategory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ServiceCategoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceCategoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ServiceCategoryPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ServiceCategory.
     * @param {ServiceCategoryCreateArgs} args - Arguments to create a ServiceCategory.
     * @example
     * // Create one ServiceCategory
     * const ServiceCategory = await prisma.serviceCategory.create({
     *   data: {
     *     // ... data to create a ServiceCategory
     *   }
     * })
     * 
    **/
    create<T extends ServiceCategoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceCategoryCreateArgs<ExtArgs>>
    ): Prisma__ServiceCategoryClient<$Types.GetResult<ServiceCategoryPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many ServiceCategories.
     *     @param {ServiceCategoryCreateManyArgs} args - Arguments to create many ServiceCategories.
     *     @example
     *     // Create many ServiceCategories
     *     const serviceCategory = await prisma.serviceCategory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ServiceCategoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceCategoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ServiceCategory.
     * @param {ServiceCategoryDeleteArgs} args - Arguments to delete one ServiceCategory.
     * @example
     * // Delete one ServiceCategory
     * const ServiceCategory = await prisma.serviceCategory.delete({
     *   where: {
     *     // ... filter to delete one ServiceCategory
     *   }
     * })
     * 
    **/
    delete<T extends ServiceCategoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceCategoryDeleteArgs<ExtArgs>>
    ): Prisma__ServiceCategoryClient<$Types.GetResult<ServiceCategoryPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ServiceCategory.
     * @param {ServiceCategoryUpdateArgs} args - Arguments to update one ServiceCategory.
     * @example
     * // Update one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ServiceCategoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceCategoryUpdateArgs<ExtArgs>>
    ): Prisma__ServiceCategoryClient<$Types.GetResult<ServiceCategoryPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more ServiceCategories.
     * @param {ServiceCategoryDeleteManyArgs} args - Arguments to filter ServiceCategories to delete.
     * @example
     * // Delete a few ServiceCategories
     * const { count } = await prisma.serviceCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ServiceCategoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceCategoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceCategories
     * const serviceCategory = await prisma.serviceCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ServiceCategoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceCategoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceCategory.
     * @param {ServiceCategoryUpsertArgs} args - Arguments to update or create a ServiceCategory.
     * @example
     * // Update or create a ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.upsert({
     *   create: {
     *     // ... data to create a ServiceCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceCategory we want to update
     *   }
     * })
    **/
    upsert<T extends ServiceCategoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceCategoryUpsertArgs<ExtArgs>>
    ): Prisma__ServiceCategoryClient<$Types.GetResult<ServiceCategoryPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of ServiceCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryCountArgs} args - Arguments to filter ServiceCategories to count.
     * @example
     * // Count the number of ServiceCategories
     * const count = await prisma.serviceCategory.count({
     *   where: {
     *     // ... the filter for the ServiceCategories we want to count
     *   }
     * })
    **/
    count<T extends ServiceCategoryCountArgs>(
      args?: Subset<T, ServiceCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceCategoryAggregateArgs>(args: Subset<T, ServiceCategoryAggregateArgs>): Prisma.PrismaPromise<GetServiceCategoryAggregateType<T>>

    /**
     * Group by ServiceCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ServiceCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ServiceCategoryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    services<T extends ServiceCategory$servicesArgs<ExtArgs> = {}>(args?: Subset<T, ServiceCategory$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findMany', never>| Null>;

    form<T extends ServiceCategory$formArgs<ExtArgs> = {}>(args?: Subset<T, ServiceCategory$formArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ServiceCategoryFormPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ServiceCategory base type for findUnique actions
   */
  export type ServiceCategoryFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategory to fetch.
     */
    where: ServiceCategoryWhereUniqueInput
  }

  /**
   * ServiceCategory findUnique
   */
  export interface ServiceCategoryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ServiceCategoryFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ServiceCategory findUniqueOrThrow
   */
  export type ServiceCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategory to fetch.
     */
    where: ServiceCategoryWhereUniqueInput
  }


  /**
   * ServiceCategory base type for findFirst actions
   */
  export type ServiceCategoryFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategory to fetch.
     */
    where?: ServiceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategories to fetch.
     */
    orderBy?: Enumerable<ServiceCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceCategories.
     */
    cursor?: ServiceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceCategories.
     */
    distinct?: Enumerable<ServiceCategoryScalarFieldEnum>
  }

  /**
   * ServiceCategory findFirst
   */
  export interface ServiceCategoryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ServiceCategoryFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ServiceCategory findFirstOrThrow
   */
  export type ServiceCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategory to fetch.
     */
    where?: ServiceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategories to fetch.
     */
    orderBy?: Enumerable<ServiceCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceCategories.
     */
    cursor?: ServiceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceCategories.
     */
    distinct?: Enumerable<ServiceCategoryScalarFieldEnum>
  }


  /**
   * ServiceCategory findMany
   */
  export type ServiceCategoryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategories to fetch.
     */
    where?: ServiceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategories to fetch.
     */
    orderBy?: Enumerable<ServiceCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceCategories.
     */
    cursor?: ServiceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategories.
     */
    skip?: number
    distinct?: Enumerable<ServiceCategoryScalarFieldEnum>
  }


  /**
   * ServiceCategory create
   */
  export type ServiceCategoryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceCategory.
     */
    data: XOR<ServiceCategoryCreateInput, ServiceCategoryUncheckedCreateInput>
  }


  /**
   * ServiceCategory createMany
   */
  export type ServiceCategoryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceCategories.
     */
    data: Enumerable<ServiceCategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ServiceCategory update
   */
  export type ServiceCategoryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceCategory.
     */
    data: XOR<ServiceCategoryUpdateInput, ServiceCategoryUncheckedUpdateInput>
    /**
     * Choose, which ServiceCategory to update.
     */
    where: ServiceCategoryWhereUniqueInput
  }


  /**
   * ServiceCategory updateMany
   */
  export type ServiceCategoryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceCategories.
     */
    data: XOR<ServiceCategoryUpdateManyMutationInput, ServiceCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ServiceCategories to update
     */
    where?: ServiceCategoryWhereInput
  }


  /**
   * ServiceCategory upsert
   */
  export type ServiceCategoryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceCategory to update in case it exists.
     */
    where: ServiceCategoryWhereUniqueInput
    /**
     * In case the ServiceCategory found by the `where` argument doesn't exist, create a new ServiceCategory with this data.
     */
    create: XOR<ServiceCategoryCreateInput, ServiceCategoryUncheckedCreateInput>
    /**
     * In case the ServiceCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceCategoryUpdateInput, ServiceCategoryUncheckedUpdateInput>
  }


  /**
   * ServiceCategory delete
   */
  export type ServiceCategoryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter which ServiceCategory to delete.
     */
    where: ServiceCategoryWhereUniqueInput
  }


  /**
   * ServiceCategory deleteMany
   */
  export type ServiceCategoryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceCategories to delete
     */
    where?: ServiceCategoryWhereInput
  }


  /**
   * ServiceCategory.services
   */
  export type ServiceCategory$servicesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: Enumerable<ServiceOrderByWithRelationInput>
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ServiceScalarFieldEnum>
  }


  /**
   * ServiceCategory.form
   */
  export type ServiceCategory$formArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategoryForm
     */
    select?: ServiceCategoryFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceCategoryFormInclude<ExtArgs> | null
    where?: ServiceCategoryFormWhereInput
    orderBy?: Enumerable<ServiceCategoryFormOrderByWithRelationInput>
    cursor?: ServiceCategoryFormWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ServiceCategoryFormScalarFieldEnum>
  }


  /**
   * ServiceCategory without action
   */
  export type ServiceCategoryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
  }



  /**
   * Model ServiceCategoryForm
   */


  export type AggregateServiceCategoryForm = {
    _count: ServiceCategoryFormCountAggregateOutputType | null
    _min: ServiceCategoryFormMinAggregateOutputType | null
    _max: ServiceCategoryFormMaxAggregateOutputType | null
  }

  export type ServiceCategoryFormMinAggregateOutputType = {
    id: string | null
    question: string | null
    type: string | null
    compulsory: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    serviceCategoryId: string | null
  }

  export type ServiceCategoryFormMaxAggregateOutputType = {
    id: string | null
    question: string | null
    type: string | null
    compulsory: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    serviceCategoryId: string | null
  }

  export type ServiceCategoryFormCountAggregateOutputType = {
    id: number
    question: number
    type: number
    options: number
    compulsory: number
    createdAt: number
    updatedAt: number
    serviceCategoryId: number
    _all: number
  }


  export type ServiceCategoryFormMinAggregateInputType = {
    id?: true
    question?: true
    type?: true
    compulsory?: true
    createdAt?: true
    updatedAt?: true
    serviceCategoryId?: true
  }

  export type ServiceCategoryFormMaxAggregateInputType = {
    id?: true
    question?: true
    type?: true
    compulsory?: true
    createdAt?: true
    updatedAt?: true
    serviceCategoryId?: true
  }

  export type ServiceCategoryFormCountAggregateInputType = {
    id?: true
    question?: true
    type?: true
    options?: true
    compulsory?: true
    createdAt?: true
    updatedAt?: true
    serviceCategoryId?: true
    _all?: true
  }

  export type ServiceCategoryFormAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceCategoryForm to aggregate.
     */
    where?: ServiceCategoryFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategoryForms to fetch.
     */
    orderBy?: Enumerable<ServiceCategoryFormOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceCategoryFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategoryForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategoryForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceCategoryForms
    **/
    _count?: true | ServiceCategoryFormCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceCategoryFormMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceCategoryFormMaxAggregateInputType
  }

  export type GetServiceCategoryFormAggregateType<T extends ServiceCategoryFormAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceCategoryForm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceCategoryForm[P]>
      : GetScalarType<T[P], AggregateServiceCategoryForm[P]>
  }




  export type ServiceCategoryFormGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ServiceCategoryFormWhereInput
    orderBy?: Enumerable<ServiceCategoryFormOrderByWithAggregationInput>
    by: ServiceCategoryFormScalarFieldEnum[]
    having?: ServiceCategoryFormScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCategoryFormCountAggregateInputType | true
    _min?: ServiceCategoryFormMinAggregateInputType
    _max?: ServiceCategoryFormMaxAggregateInputType
  }


  export type ServiceCategoryFormGroupByOutputType = {
    id: string
    question: string
    type: string
    options: string[]
    compulsory: boolean
    createdAt: Date
    updatedAt: Date
    serviceCategoryId: string
    _count: ServiceCategoryFormCountAggregateOutputType | null
    _min: ServiceCategoryFormMinAggregateOutputType | null
    _max: ServiceCategoryFormMaxAggregateOutputType | null
  }

  type GetServiceCategoryFormGroupByPayload<T extends ServiceCategoryFormGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ServiceCategoryFormGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceCategoryFormGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceCategoryFormGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceCategoryFormGroupByOutputType[P]>
        }
      >
    >


  export type ServiceCategoryFormSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    type?: boolean
    options?: boolean
    compulsory?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceCategoryId?: boolean
    category?: boolean | ServiceCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["serviceCategoryForm"]>

  export type ServiceCategoryFormSelectScalar = {
    id?: boolean
    question?: boolean
    type?: boolean
    options?: boolean
    compulsory?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceCategoryId?: boolean
  }

  export type ServiceCategoryFormInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    category?: boolean | ServiceCategoryArgs<ExtArgs>
  }


  type ServiceCategoryFormGetPayload<S extends boolean | null | undefined | ServiceCategoryFormArgs> = $Types.GetResult<ServiceCategoryFormPayload, S>

  type ServiceCategoryFormCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ServiceCategoryFormFindManyArgs, 'select' | 'include'> & {
      select?: ServiceCategoryFormCountAggregateInputType | true
    }

  export interface ServiceCategoryFormDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceCategoryForm'], meta: { name: 'ServiceCategoryForm' } }
    /**
     * Find zero or one ServiceCategoryForm that matches the filter.
     * @param {ServiceCategoryFormFindUniqueArgs} args - Arguments to find a ServiceCategoryForm
     * @example
     * // Get one ServiceCategoryForm
     * const serviceCategoryForm = await prisma.serviceCategoryForm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ServiceCategoryFormFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ServiceCategoryFormFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ServiceCategoryForm'> extends True ? Prisma__ServiceCategoryFormClient<$Types.GetResult<ServiceCategoryFormPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ServiceCategoryFormClient<$Types.GetResult<ServiceCategoryFormPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ServiceCategoryForm that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ServiceCategoryFormFindUniqueOrThrowArgs} args - Arguments to find a ServiceCategoryForm
     * @example
     * // Get one ServiceCategoryForm
     * const serviceCategoryForm = await prisma.serviceCategoryForm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ServiceCategoryFormFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceCategoryFormFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceCategoryFormClient<$Types.GetResult<ServiceCategoryFormPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ServiceCategoryForm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryFormFindFirstArgs} args - Arguments to find a ServiceCategoryForm
     * @example
     * // Get one ServiceCategoryForm
     * const serviceCategoryForm = await prisma.serviceCategoryForm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ServiceCategoryFormFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ServiceCategoryFormFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ServiceCategoryForm'> extends True ? Prisma__ServiceCategoryFormClient<$Types.GetResult<ServiceCategoryFormPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ServiceCategoryFormClient<$Types.GetResult<ServiceCategoryFormPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ServiceCategoryForm that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryFormFindFirstOrThrowArgs} args - Arguments to find a ServiceCategoryForm
     * @example
     * // Get one ServiceCategoryForm
     * const serviceCategoryForm = await prisma.serviceCategoryForm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ServiceCategoryFormFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceCategoryFormFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceCategoryFormClient<$Types.GetResult<ServiceCategoryFormPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more ServiceCategoryForms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryFormFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceCategoryForms
     * const serviceCategoryForms = await prisma.serviceCategoryForm.findMany()
     * 
     * // Get first 10 ServiceCategoryForms
     * const serviceCategoryForms = await prisma.serviceCategoryForm.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceCategoryFormWithIdOnly = await prisma.serviceCategoryForm.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ServiceCategoryFormFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceCategoryFormFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ServiceCategoryFormPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ServiceCategoryForm.
     * @param {ServiceCategoryFormCreateArgs} args - Arguments to create a ServiceCategoryForm.
     * @example
     * // Create one ServiceCategoryForm
     * const ServiceCategoryForm = await prisma.serviceCategoryForm.create({
     *   data: {
     *     // ... data to create a ServiceCategoryForm
     *   }
     * })
     * 
    **/
    create<T extends ServiceCategoryFormCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceCategoryFormCreateArgs<ExtArgs>>
    ): Prisma__ServiceCategoryFormClient<$Types.GetResult<ServiceCategoryFormPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many ServiceCategoryForms.
     *     @param {ServiceCategoryFormCreateManyArgs} args - Arguments to create many ServiceCategoryForms.
     *     @example
     *     // Create many ServiceCategoryForms
     *     const serviceCategoryForm = await prisma.serviceCategoryForm.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ServiceCategoryFormCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceCategoryFormCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ServiceCategoryForm.
     * @param {ServiceCategoryFormDeleteArgs} args - Arguments to delete one ServiceCategoryForm.
     * @example
     * // Delete one ServiceCategoryForm
     * const ServiceCategoryForm = await prisma.serviceCategoryForm.delete({
     *   where: {
     *     // ... filter to delete one ServiceCategoryForm
     *   }
     * })
     * 
    **/
    delete<T extends ServiceCategoryFormDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceCategoryFormDeleteArgs<ExtArgs>>
    ): Prisma__ServiceCategoryFormClient<$Types.GetResult<ServiceCategoryFormPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ServiceCategoryForm.
     * @param {ServiceCategoryFormUpdateArgs} args - Arguments to update one ServiceCategoryForm.
     * @example
     * // Update one ServiceCategoryForm
     * const serviceCategoryForm = await prisma.serviceCategoryForm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ServiceCategoryFormUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceCategoryFormUpdateArgs<ExtArgs>>
    ): Prisma__ServiceCategoryFormClient<$Types.GetResult<ServiceCategoryFormPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more ServiceCategoryForms.
     * @param {ServiceCategoryFormDeleteManyArgs} args - Arguments to filter ServiceCategoryForms to delete.
     * @example
     * // Delete a few ServiceCategoryForms
     * const { count } = await prisma.serviceCategoryForm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ServiceCategoryFormDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceCategoryFormDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceCategoryForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryFormUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceCategoryForms
     * const serviceCategoryForm = await prisma.serviceCategoryForm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ServiceCategoryFormUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceCategoryFormUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceCategoryForm.
     * @param {ServiceCategoryFormUpsertArgs} args - Arguments to update or create a ServiceCategoryForm.
     * @example
     * // Update or create a ServiceCategoryForm
     * const serviceCategoryForm = await prisma.serviceCategoryForm.upsert({
     *   create: {
     *     // ... data to create a ServiceCategoryForm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceCategoryForm we want to update
     *   }
     * })
    **/
    upsert<T extends ServiceCategoryFormUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceCategoryFormUpsertArgs<ExtArgs>>
    ): Prisma__ServiceCategoryFormClient<$Types.GetResult<ServiceCategoryFormPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of ServiceCategoryForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryFormCountArgs} args - Arguments to filter ServiceCategoryForms to count.
     * @example
     * // Count the number of ServiceCategoryForms
     * const count = await prisma.serviceCategoryForm.count({
     *   where: {
     *     // ... the filter for the ServiceCategoryForms we want to count
     *   }
     * })
    **/
    count<T extends ServiceCategoryFormCountArgs>(
      args?: Subset<T, ServiceCategoryFormCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCategoryFormCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceCategoryForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryFormAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceCategoryFormAggregateArgs>(args: Subset<T, ServiceCategoryFormAggregateArgs>): Prisma.PrismaPromise<GetServiceCategoryFormAggregateType<T>>

    /**
     * Group by ServiceCategoryForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryFormGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceCategoryFormGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceCategoryFormGroupByArgs['orderBy'] }
        : { orderBy?: ServiceCategoryFormGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceCategoryFormGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceCategoryFormGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceCategoryForm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ServiceCategoryFormClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    category<T extends ServiceCategoryArgs<ExtArgs> = {}>(args?: Subset<T, ServiceCategoryArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Types.GetResult<ServiceCategoryPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ServiceCategoryForm base type for findUnique actions
   */
  export type ServiceCategoryFormFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategoryForm
     */
    select?: ServiceCategoryFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceCategoryFormInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategoryForm to fetch.
     */
    where: ServiceCategoryFormWhereUniqueInput
  }

  /**
   * ServiceCategoryForm findUnique
   */
  export interface ServiceCategoryFormFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ServiceCategoryFormFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ServiceCategoryForm findUniqueOrThrow
   */
  export type ServiceCategoryFormFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategoryForm
     */
    select?: ServiceCategoryFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceCategoryFormInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategoryForm to fetch.
     */
    where: ServiceCategoryFormWhereUniqueInput
  }


  /**
   * ServiceCategoryForm base type for findFirst actions
   */
  export type ServiceCategoryFormFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategoryForm
     */
    select?: ServiceCategoryFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceCategoryFormInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategoryForm to fetch.
     */
    where?: ServiceCategoryFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategoryForms to fetch.
     */
    orderBy?: Enumerable<ServiceCategoryFormOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceCategoryForms.
     */
    cursor?: ServiceCategoryFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategoryForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategoryForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceCategoryForms.
     */
    distinct?: Enumerable<ServiceCategoryFormScalarFieldEnum>
  }

  /**
   * ServiceCategoryForm findFirst
   */
  export interface ServiceCategoryFormFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ServiceCategoryFormFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ServiceCategoryForm findFirstOrThrow
   */
  export type ServiceCategoryFormFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategoryForm
     */
    select?: ServiceCategoryFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceCategoryFormInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategoryForm to fetch.
     */
    where?: ServiceCategoryFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategoryForms to fetch.
     */
    orderBy?: Enumerable<ServiceCategoryFormOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceCategoryForms.
     */
    cursor?: ServiceCategoryFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategoryForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategoryForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceCategoryForms.
     */
    distinct?: Enumerable<ServiceCategoryFormScalarFieldEnum>
  }


  /**
   * ServiceCategoryForm findMany
   */
  export type ServiceCategoryFormFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategoryForm
     */
    select?: ServiceCategoryFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceCategoryFormInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategoryForms to fetch.
     */
    where?: ServiceCategoryFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategoryForms to fetch.
     */
    orderBy?: Enumerable<ServiceCategoryFormOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceCategoryForms.
     */
    cursor?: ServiceCategoryFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategoryForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategoryForms.
     */
    skip?: number
    distinct?: Enumerable<ServiceCategoryFormScalarFieldEnum>
  }


  /**
   * ServiceCategoryForm create
   */
  export type ServiceCategoryFormCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategoryForm
     */
    select?: ServiceCategoryFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceCategoryFormInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceCategoryForm.
     */
    data: XOR<ServiceCategoryFormCreateInput, ServiceCategoryFormUncheckedCreateInput>
  }


  /**
   * ServiceCategoryForm createMany
   */
  export type ServiceCategoryFormCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceCategoryForms.
     */
    data: Enumerable<ServiceCategoryFormCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ServiceCategoryForm update
   */
  export type ServiceCategoryFormUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategoryForm
     */
    select?: ServiceCategoryFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceCategoryFormInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceCategoryForm.
     */
    data: XOR<ServiceCategoryFormUpdateInput, ServiceCategoryFormUncheckedUpdateInput>
    /**
     * Choose, which ServiceCategoryForm to update.
     */
    where: ServiceCategoryFormWhereUniqueInput
  }


  /**
   * ServiceCategoryForm updateMany
   */
  export type ServiceCategoryFormUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceCategoryForms.
     */
    data: XOR<ServiceCategoryFormUpdateManyMutationInput, ServiceCategoryFormUncheckedUpdateManyInput>
    /**
     * Filter which ServiceCategoryForms to update
     */
    where?: ServiceCategoryFormWhereInput
  }


  /**
   * ServiceCategoryForm upsert
   */
  export type ServiceCategoryFormUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategoryForm
     */
    select?: ServiceCategoryFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceCategoryFormInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceCategoryForm to update in case it exists.
     */
    where: ServiceCategoryFormWhereUniqueInput
    /**
     * In case the ServiceCategoryForm found by the `where` argument doesn't exist, create a new ServiceCategoryForm with this data.
     */
    create: XOR<ServiceCategoryFormCreateInput, ServiceCategoryFormUncheckedCreateInput>
    /**
     * In case the ServiceCategoryForm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceCategoryFormUpdateInput, ServiceCategoryFormUncheckedUpdateInput>
  }


  /**
   * ServiceCategoryForm delete
   */
  export type ServiceCategoryFormDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategoryForm
     */
    select?: ServiceCategoryFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceCategoryFormInclude<ExtArgs> | null
    /**
     * Filter which ServiceCategoryForm to delete.
     */
    where: ServiceCategoryFormWhereUniqueInput
  }


  /**
   * ServiceCategoryForm deleteMany
   */
  export type ServiceCategoryFormDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceCategoryForms to delete
     */
    where?: ServiceCategoryFormWhereInput
  }


  /**
   * ServiceCategoryForm without action
   */
  export type ServiceCategoryFormArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategoryForm
     */
    select?: ServiceCategoryFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceCategoryFormInclude<ExtArgs> | null
  }



  /**
   * Model Service
   */


  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    code: string | null
    description: string | null
    country: string | null
    price: string | null
    timeline: string | null
    hasShares: boolean | null
    numberOfShares: string | null
    hasAgent: boolean | null
    hasOwner: boolean | null
    hasController: boolean | null
    controllerIsCalled: string | null
    OwnerIsCalled: string | null
    agentIsCalled: string | null
    createdAt: Date | null
    updatedAt: Date | null
    serviceCategoryId: string | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    code: string | null
    description: string | null
    country: string | null
    price: string | null
    timeline: string | null
    hasShares: boolean | null
    numberOfShares: string | null
    hasAgent: boolean | null
    hasOwner: boolean | null
    hasController: boolean | null
    controllerIsCalled: string | null
    OwnerIsCalled: string | null
    agentIsCalled: string | null
    createdAt: Date | null
    updatedAt: Date | null
    serviceCategoryId: string | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    name: number
    type: number
    code: number
    description: number
    country: number
    price: number
    timeline: number
    feature: number
    categoryForm: number
    hasShares: number
    numberOfShares: number
    hasAgent: number
    hasOwner: number
    hasController: number
    controllerIsCalled: number
    OwnerIsCalled: number
    agentIsCalled: number
    createdAt: number
    updatedAt: number
    serviceCategoryId: number
    _all: number
  }


  export type ServiceMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    code?: true
    description?: true
    country?: true
    price?: true
    timeline?: true
    hasShares?: true
    numberOfShares?: true
    hasAgent?: true
    hasOwner?: true
    hasController?: true
    controllerIsCalled?: true
    OwnerIsCalled?: true
    agentIsCalled?: true
    createdAt?: true
    updatedAt?: true
    serviceCategoryId?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    code?: true
    description?: true
    country?: true
    price?: true
    timeline?: true
    hasShares?: true
    numberOfShares?: true
    hasAgent?: true
    hasOwner?: true
    hasController?: true
    controllerIsCalled?: true
    OwnerIsCalled?: true
    agentIsCalled?: true
    createdAt?: true
    updatedAt?: true
    serviceCategoryId?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    code?: true
    description?: true
    country?: true
    price?: true
    timeline?: true
    feature?: true
    categoryForm?: true
    hasShares?: true
    numberOfShares?: true
    hasAgent?: true
    hasOwner?: true
    hasController?: true
    controllerIsCalled?: true
    OwnerIsCalled?: true
    agentIsCalled?: true
    createdAt?: true
    updatedAt?: true
    serviceCategoryId?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: Enumerable<ServiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: Enumerable<ServiceOrderByWithAggregationInput>
    by: ServiceScalarFieldEnum[]
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }


  export type ServiceGroupByOutputType = {
    id: string
    name: string
    type: string
    code: string
    description: string
    country: string
    price: string
    timeline: string
    feature: string[]
    categoryForm: string[]
    hasShares: boolean
    numberOfShares: string
    hasAgent: boolean
    hasOwner: boolean
    hasController: boolean
    controllerIsCalled: string | null
    OwnerIsCalled: string | null
    agentIsCalled: string | null
    createdAt: Date
    updatedAt: Date
    serviceCategoryId: string
    _count: ServiceCountAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    code?: boolean
    description?: boolean
    country?: boolean
    price?: boolean
    timeline?: boolean
    feature?: boolean
    categoryForm?: boolean
    hasShares?: boolean
    numberOfShares?: boolean
    hasAgent?: boolean
    hasOwner?: boolean
    hasController?: boolean
    controllerIsCalled?: boolean
    OwnerIsCalled?: boolean
    agentIsCalled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceCategoryId?: boolean
    category?: boolean | ServiceCategoryArgs<ExtArgs>
    products?: boolean | Service$productsArgs<ExtArgs>
    templates?: boolean | Service$templatesArgs<ExtArgs>
    forms?: boolean | Service$formsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    code?: boolean
    description?: boolean
    country?: boolean
    price?: boolean
    timeline?: boolean
    feature?: boolean
    categoryForm?: boolean
    hasShares?: boolean
    numberOfShares?: boolean
    hasAgent?: boolean
    hasOwner?: boolean
    hasController?: boolean
    controllerIsCalled?: boolean
    OwnerIsCalled?: boolean
    agentIsCalled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceCategoryId?: boolean
  }

  export type ServiceInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    category?: boolean | ServiceCategoryArgs<ExtArgs>
    products?: boolean | Service$productsArgs<ExtArgs>
    templates?: boolean | Service$templatesArgs<ExtArgs>
    forms?: boolean | Service$formsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeArgs<ExtArgs>
  }


  type ServiceGetPayload<S extends boolean | null | undefined | ServiceArgs> = $Types.GetResult<ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ServiceFindManyArgs, 'select' | 'include'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ServiceFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Service'> extends True ? Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Service that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ServiceFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Service'> extends True ? Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Service that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ServiceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
    **/
    create<T extends ServiceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Services.
     *     @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     *     @example
     *     // Create many Services
     *     const service = await prisma.service.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ServiceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
    **/
    delete<T extends ServiceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ServiceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ServiceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ServiceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
    **/
    upsert<T extends ServiceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    category<T extends ServiceCategoryArgs<ExtArgs> = {}>(args?: Subset<T, ServiceCategoryArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Types.GetResult<ServiceCategoryPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    products<T extends Service$productsArgs<ExtArgs> = {}>(args?: Subset<T, Service$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findMany', never>| Null>;

    templates<T extends Service$templatesArgs<ExtArgs> = {}>(args?: Subset<T, Service$templatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ServiceTemplatePayload<ExtArgs>, T, 'findMany', never>| Null>;

    forms<T extends Service$formsArgs<ExtArgs> = {}>(args?: Subset<T, Service$formsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ServiceFormPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Service base type for findUnique actions
   */
  export type ServiceFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUnique
   */
  export interface ServiceFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ServiceFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }


  /**
   * Service base type for findFirst actions
   */
  export type ServiceFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: Enumerable<ServiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: Enumerable<ServiceScalarFieldEnum>
  }

  /**
   * Service findFirst
   */
  export interface ServiceFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ServiceFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: Enumerable<ServiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: Enumerable<ServiceScalarFieldEnum>
  }


  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: Enumerable<ServiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: Enumerable<ServiceScalarFieldEnum>
  }


  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }


  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: Enumerable<ServiceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }


  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
  }


  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }


  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }


  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
  }


  /**
   * Service.products
   */
  export type Service$productsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Service.templates
   */
  export type Service$templatesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTemplate
     */
    select?: ServiceTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceTemplateInclude<ExtArgs> | null
    where?: ServiceTemplateWhereInput
    orderBy?: Enumerable<ServiceTemplateOrderByWithRelationInput>
    cursor?: ServiceTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ServiceTemplateScalarFieldEnum>
  }


  /**
   * Service.forms
   */
  export type Service$formsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceFormInclude<ExtArgs> | null
    where?: ServiceFormWhereInput
    orderBy?: Enumerable<ServiceFormOrderByWithRelationInput>
    cursor?: ServiceFormWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ServiceFormScalarFieldEnum>
  }


  /**
   * Service without action
   */
  export type ServiceArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
  }



  /**
   * Model ServiceTemplate
   */


  export type AggregateServiceTemplate = {
    _count: ServiceTemplateCountAggregateOutputType | null
    _min: ServiceTemplateMinAggregateOutputType | null
    _max: ServiceTemplateMaxAggregateOutputType | null
  }

  export type ServiceTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    serviceId: string | null
  }

  export type ServiceTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    serviceId: string | null
  }

  export type ServiceTemplateCountAggregateOutputType = {
    id: number
    name: number
    type: number
    description: number
    createdAt: number
    updatedAt: number
    serviceId: number
    _all: number
  }


  export type ServiceTemplateMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    serviceId?: true
  }

  export type ServiceTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    serviceId?: true
  }

  export type ServiceTemplateCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    serviceId?: true
    _all?: true
  }

  export type ServiceTemplateAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceTemplate to aggregate.
     */
    where?: ServiceTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceTemplates to fetch.
     */
    orderBy?: Enumerable<ServiceTemplateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceTemplates
    **/
    _count?: true | ServiceTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceTemplateMaxAggregateInputType
  }

  export type GetServiceTemplateAggregateType<T extends ServiceTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceTemplate[P]>
      : GetScalarType<T[P], AggregateServiceTemplate[P]>
  }




  export type ServiceTemplateGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ServiceTemplateWhereInput
    orderBy?: Enumerable<ServiceTemplateOrderByWithAggregationInput>
    by: ServiceTemplateScalarFieldEnum[]
    having?: ServiceTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceTemplateCountAggregateInputType | true
    _min?: ServiceTemplateMinAggregateInputType
    _max?: ServiceTemplateMaxAggregateInputType
  }


  export type ServiceTemplateGroupByOutputType = {
    id: string
    name: string
    type: string
    description: string
    createdAt: Date
    updatedAt: Date
    serviceId: string
    _count: ServiceTemplateCountAggregateOutputType | null
    _min: ServiceTemplateMinAggregateOutputType | null
    _max: ServiceTemplateMaxAggregateOutputType | null
  }

  type GetServiceTemplateGroupByPayload<T extends ServiceTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ServiceTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceTemplateGroupByOutputType[P]>
        }
      >
    >


  export type ServiceTemplateSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceId?: boolean
    service?: boolean | ServiceArgs<ExtArgs>
  }, ExtArgs["result"]["serviceTemplate"]>

  export type ServiceTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceId?: boolean
  }

  export type ServiceTemplateInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceArgs<ExtArgs>
  }


  type ServiceTemplateGetPayload<S extends boolean | null | undefined | ServiceTemplateArgs> = $Types.GetResult<ServiceTemplatePayload, S>

  type ServiceTemplateCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ServiceTemplateFindManyArgs, 'select' | 'include'> & {
      select?: ServiceTemplateCountAggregateInputType | true
    }

  export interface ServiceTemplateDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceTemplate'], meta: { name: 'ServiceTemplate' } }
    /**
     * Find zero or one ServiceTemplate that matches the filter.
     * @param {ServiceTemplateFindUniqueArgs} args - Arguments to find a ServiceTemplate
     * @example
     * // Get one ServiceTemplate
     * const serviceTemplate = await prisma.serviceTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ServiceTemplateFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ServiceTemplateFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ServiceTemplate'> extends True ? Prisma__ServiceTemplateClient<$Types.GetResult<ServiceTemplatePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ServiceTemplateClient<$Types.GetResult<ServiceTemplatePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ServiceTemplate that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ServiceTemplateFindUniqueOrThrowArgs} args - Arguments to find a ServiceTemplate
     * @example
     * // Get one ServiceTemplate
     * const serviceTemplate = await prisma.serviceTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ServiceTemplateFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceTemplateFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceTemplateClient<$Types.GetResult<ServiceTemplatePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ServiceTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTemplateFindFirstArgs} args - Arguments to find a ServiceTemplate
     * @example
     * // Get one ServiceTemplate
     * const serviceTemplate = await prisma.serviceTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ServiceTemplateFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ServiceTemplateFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ServiceTemplate'> extends True ? Prisma__ServiceTemplateClient<$Types.GetResult<ServiceTemplatePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ServiceTemplateClient<$Types.GetResult<ServiceTemplatePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ServiceTemplate that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTemplateFindFirstOrThrowArgs} args - Arguments to find a ServiceTemplate
     * @example
     * // Get one ServiceTemplate
     * const serviceTemplate = await prisma.serviceTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ServiceTemplateFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceTemplateFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceTemplateClient<$Types.GetResult<ServiceTemplatePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more ServiceTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTemplateFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceTemplates
     * const serviceTemplates = await prisma.serviceTemplate.findMany()
     * 
     * // Get first 10 ServiceTemplates
     * const serviceTemplates = await prisma.serviceTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceTemplateWithIdOnly = await prisma.serviceTemplate.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ServiceTemplateFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceTemplateFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ServiceTemplatePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ServiceTemplate.
     * @param {ServiceTemplateCreateArgs} args - Arguments to create a ServiceTemplate.
     * @example
     * // Create one ServiceTemplate
     * const ServiceTemplate = await prisma.serviceTemplate.create({
     *   data: {
     *     // ... data to create a ServiceTemplate
     *   }
     * })
     * 
    **/
    create<T extends ServiceTemplateCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceTemplateCreateArgs<ExtArgs>>
    ): Prisma__ServiceTemplateClient<$Types.GetResult<ServiceTemplatePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many ServiceTemplates.
     *     @param {ServiceTemplateCreateManyArgs} args - Arguments to create many ServiceTemplates.
     *     @example
     *     // Create many ServiceTemplates
     *     const serviceTemplate = await prisma.serviceTemplate.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ServiceTemplateCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceTemplateCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ServiceTemplate.
     * @param {ServiceTemplateDeleteArgs} args - Arguments to delete one ServiceTemplate.
     * @example
     * // Delete one ServiceTemplate
     * const ServiceTemplate = await prisma.serviceTemplate.delete({
     *   where: {
     *     // ... filter to delete one ServiceTemplate
     *   }
     * })
     * 
    **/
    delete<T extends ServiceTemplateDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceTemplateDeleteArgs<ExtArgs>>
    ): Prisma__ServiceTemplateClient<$Types.GetResult<ServiceTemplatePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ServiceTemplate.
     * @param {ServiceTemplateUpdateArgs} args - Arguments to update one ServiceTemplate.
     * @example
     * // Update one ServiceTemplate
     * const serviceTemplate = await prisma.serviceTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ServiceTemplateUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceTemplateUpdateArgs<ExtArgs>>
    ): Prisma__ServiceTemplateClient<$Types.GetResult<ServiceTemplatePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more ServiceTemplates.
     * @param {ServiceTemplateDeleteManyArgs} args - Arguments to filter ServiceTemplates to delete.
     * @example
     * // Delete a few ServiceTemplates
     * const { count } = await prisma.serviceTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ServiceTemplateDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceTemplateDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceTemplates
     * const serviceTemplate = await prisma.serviceTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ServiceTemplateUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceTemplateUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceTemplate.
     * @param {ServiceTemplateUpsertArgs} args - Arguments to update or create a ServiceTemplate.
     * @example
     * // Update or create a ServiceTemplate
     * const serviceTemplate = await prisma.serviceTemplate.upsert({
     *   create: {
     *     // ... data to create a ServiceTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceTemplate we want to update
     *   }
     * })
    **/
    upsert<T extends ServiceTemplateUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceTemplateUpsertArgs<ExtArgs>>
    ): Prisma__ServiceTemplateClient<$Types.GetResult<ServiceTemplatePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of ServiceTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTemplateCountArgs} args - Arguments to filter ServiceTemplates to count.
     * @example
     * // Count the number of ServiceTemplates
     * const count = await prisma.serviceTemplate.count({
     *   where: {
     *     // ... the filter for the ServiceTemplates we want to count
     *   }
     * })
    **/
    count<T extends ServiceTemplateCountArgs>(
      args?: Subset<T, ServiceTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceTemplateAggregateArgs>(args: Subset<T, ServiceTemplateAggregateArgs>): Prisma.PrismaPromise<GetServiceTemplateAggregateType<T>>

    /**
     * Group by ServiceTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceTemplateGroupByArgs['orderBy'] }
        : { orderBy?: ServiceTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ServiceTemplateClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    service<T extends ServiceArgs<ExtArgs> = {}>(args?: Subset<T, ServiceArgs<ExtArgs>>): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ServiceTemplate base type for findUnique actions
   */
  export type ServiceTemplateFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTemplate
     */
    select?: ServiceTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ServiceTemplate to fetch.
     */
    where: ServiceTemplateWhereUniqueInput
  }

  /**
   * ServiceTemplate findUnique
   */
  export interface ServiceTemplateFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ServiceTemplateFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ServiceTemplate findUniqueOrThrow
   */
  export type ServiceTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTemplate
     */
    select?: ServiceTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ServiceTemplate to fetch.
     */
    where: ServiceTemplateWhereUniqueInput
  }


  /**
   * ServiceTemplate base type for findFirst actions
   */
  export type ServiceTemplateFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTemplate
     */
    select?: ServiceTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ServiceTemplate to fetch.
     */
    where?: ServiceTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceTemplates to fetch.
     */
    orderBy?: Enumerable<ServiceTemplateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceTemplates.
     */
    cursor?: ServiceTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceTemplates.
     */
    distinct?: Enumerable<ServiceTemplateScalarFieldEnum>
  }

  /**
   * ServiceTemplate findFirst
   */
  export interface ServiceTemplateFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ServiceTemplateFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ServiceTemplate findFirstOrThrow
   */
  export type ServiceTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTemplate
     */
    select?: ServiceTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ServiceTemplate to fetch.
     */
    where?: ServiceTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceTemplates to fetch.
     */
    orderBy?: Enumerable<ServiceTemplateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceTemplates.
     */
    cursor?: ServiceTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceTemplates.
     */
    distinct?: Enumerable<ServiceTemplateScalarFieldEnum>
  }


  /**
   * ServiceTemplate findMany
   */
  export type ServiceTemplateFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTemplate
     */
    select?: ServiceTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ServiceTemplates to fetch.
     */
    where?: ServiceTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceTemplates to fetch.
     */
    orderBy?: Enumerable<ServiceTemplateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceTemplates.
     */
    cursor?: ServiceTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceTemplates.
     */
    skip?: number
    distinct?: Enumerable<ServiceTemplateScalarFieldEnum>
  }


  /**
   * ServiceTemplate create
   */
  export type ServiceTemplateCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTemplate
     */
    select?: ServiceTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceTemplate.
     */
    data: XOR<ServiceTemplateCreateInput, ServiceTemplateUncheckedCreateInput>
  }


  /**
   * ServiceTemplate createMany
   */
  export type ServiceTemplateCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceTemplates.
     */
    data: Enumerable<ServiceTemplateCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ServiceTemplate update
   */
  export type ServiceTemplateUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTemplate
     */
    select?: ServiceTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceTemplate.
     */
    data: XOR<ServiceTemplateUpdateInput, ServiceTemplateUncheckedUpdateInput>
    /**
     * Choose, which ServiceTemplate to update.
     */
    where: ServiceTemplateWhereUniqueInput
  }


  /**
   * ServiceTemplate updateMany
   */
  export type ServiceTemplateUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceTemplates.
     */
    data: XOR<ServiceTemplateUpdateManyMutationInput, ServiceTemplateUncheckedUpdateManyInput>
    /**
     * Filter which ServiceTemplates to update
     */
    where?: ServiceTemplateWhereInput
  }


  /**
   * ServiceTemplate upsert
   */
  export type ServiceTemplateUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTemplate
     */
    select?: ServiceTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceTemplate to update in case it exists.
     */
    where: ServiceTemplateWhereUniqueInput
    /**
     * In case the ServiceTemplate found by the `where` argument doesn't exist, create a new ServiceTemplate with this data.
     */
    create: XOR<ServiceTemplateCreateInput, ServiceTemplateUncheckedCreateInput>
    /**
     * In case the ServiceTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceTemplateUpdateInput, ServiceTemplateUncheckedUpdateInput>
  }


  /**
   * ServiceTemplate delete
   */
  export type ServiceTemplateDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTemplate
     */
    select?: ServiceTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceTemplateInclude<ExtArgs> | null
    /**
     * Filter which ServiceTemplate to delete.
     */
    where: ServiceTemplateWhereUniqueInput
  }


  /**
   * ServiceTemplate deleteMany
   */
  export type ServiceTemplateDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceTemplates to delete
     */
    where?: ServiceTemplateWhereInput
  }


  /**
   * ServiceTemplate without action
   */
  export type ServiceTemplateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTemplate
     */
    select?: ServiceTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceTemplateInclude<ExtArgs> | null
  }



  /**
   * Model ServiceForm
   */


  export type AggregateServiceForm = {
    _count: ServiceFormCountAggregateOutputType | null
    _min: ServiceFormMinAggregateOutputType | null
    _max: ServiceFormMaxAggregateOutputType | null
  }

  export type ServiceFormMinAggregateOutputType = {
    id: string | null
    question: string | null
    type: string | null
    compulsory: boolean | null
    fileName: string | null
    fileDescription: string | null
    fileType: string | null
    fileLink: string | null
    createdAt: Date | null
    updatedAt: Date | null
    serviceId: string | null
  }

  export type ServiceFormMaxAggregateOutputType = {
    id: string | null
    question: string | null
    type: string | null
    compulsory: boolean | null
    fileName: string | null
    fileDescription: string | null
    fileType: string | null
    fileLink: string | null
    createdAt: Date | null
    updatedAt: Date | null
    serviceId: string | null
  }

  export type ServiceFormCountAggregateOutputType = {
    id: number
    question: number
    type: number
    options: number
    compulsory: number
    fileName: number
    fileDescription: number
    fileType: number
    fileLink: number
    createdAt: number
    updatedAt: number
    serviceId: number
    _all: number
  }


  export type ServiceFormMinAggregateInputType = {
    id?: true
    question?: true
    type?: true
    compulsory?: true
    fileName?: true
    fileDescription?: true
    fileType?: true
    fileLink?: true
    createdAt?: true
    updatedAt?: true
    serviceId?: true
  }

  export type ServiceFormMaxAggregateInputType = {
    id?: true
    question?: true
    type?: true
    compulsory?: true
    fileName?: true
    fileDescription?: true
    fileType?: true
    fileLink?: true
    createdAt?: true
    updatedAt?: true
    serviceId?: true
  }

  export type ServiceFormCountAggregateInputType = {
    id?: true
    question?: true
    type?: true
    options?: true
    compulsory?: true
    fileName?: true
    fileDescription?: true
    fileType?: true
    fileLink?: true
    createdAt?: true
    updatedAt?: true
    serviceId?: true
    _all?: true
  }

  export type ServiceFormAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceForm to aggregate.
     */
    where?: ServiceFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceForms to fetch.
     */
    orderBy?: Enumerable<ServiceFormOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceForms
    **/
    _count?: true | ServiceFormCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceFormMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceFormMaxAggregateInputType
  }

  export type GetServiceFormAggregateType<T extends ServiceFormAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceForm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceForm[P]>
      : GetScalarType<T[P], AggregateServiceForm[P]>
  }




  export type ServiceFormGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ServiceFormWhereInput
    orderBy?: Enumerable<ServiceFormOrderByWithAggregationInput>
    by: ServiceFormScalarFieldEnum[]
    having?: ServiceFormScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceFormCountAggregateInputType | true
    _min?: ServiceFormMinAggregateInputType
    _max?: ServiceFormMaxAggregateInputType
  }


  export type ServiceFormGroupByOutputType = {
    id: string
    question: string
    type: string
    options: string[]
    compulsory: boolean
    fileName: string
    fileDescription: string
    fileType: string
    fileLink: string
    createdAt: Date
    updatedAt: Date
    serviceId: string
    _count: ServiceFormCountAggregateOutputType | null
    _min: ServiceFormMinAggregateOutputType | null
    _max: ServiceFormMaxAggregateOutputType | null
  }

  type GetServiceFormGroupByPayload<T extends ServiceFormGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ServiceFormGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceFormGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceFormGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceFormGroupByOutputType[P]>
        }
      >
    >


  export type ServiceFormSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    type?: boolean
    options?: boolean
    compulsory?: boolean
    fileName?: boolean
    fileDescription?: boolean
    fileType?: boolean
    fileLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceId?: boolean
    service?: boolean | ServiceArgs<ExtArgs>
    serviceSubForm?: boolean | ServiceForm$serviceSubFormArgs<ExtArgs>
    _count?: boolean | ServiceFormCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["serviceForm"]>

  export type ServiceFormSelectScalar = {
    id?: boolean
    question?: boolean
    type?: boolean
    options?: boolean
    compulsory?: boolean
    fileName?: boolean
    fileDescription?: boolean
    fileType?: boolean
    fileLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceId?: boolean
  }

  export type ServiceFormInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceArgs<ExtArgs>
    serviceSubForm?: boolean | ServiceForm$serviceSubFormArgs<ExtArgs>
    _count?: boolean | ServiceFormCountOutputTypeArgs<ExtArgs>
  }


  type ServiceFormGetPayload<S extends boolean | null | undefined | ServiceFormArgs> = $Types.GetResult<ServiceFormPayload, S>

  type ServiceFormCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ServiceFormFindManyArgs, 'select' | 'include'> & {
      select?: ServiceFormCountAggregateInputType | true
    }

  export interface ServiceFormDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceForm'], meta: { name: 'ServiceForm' } }
    /**
     * Find zero or one ServiceForm that matches the filter.
     * @param {ServiceFormFindUniqueArgs} args - Arguments to find a ServiceForm
     * @example
     * // Get one ServiceForm
     * const serviceForm = await prisma.serviceForm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ServiceFormFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ServiceFormFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ServiceForm'> extends True ? Prisma__ServiceFormClient<$Types.GetResult<ServiceFormPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ServiceFormClient<$Types.GetResult<ServiceFormPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ServiceForm that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ServiceFormFindUniqueOrThrowArgs} args - Arguments to find a ServiceForm
     * @example
     * // Get one ServiceForm
     * const serviceForm = await prisma.serviceForm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ServiceFormFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceFormFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceFormClient<$Types.GetResult<ServiceFormPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ServiceForm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFormFindFirstArgs} args - Arguments to find a ServiceForm
     * @example
     * // Get one ServiceForm
     * const serviceForm = await prisma.serviceForm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ServiceFormFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ServiceFormFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ServiceForm'> extends True ? Prisma__ServiceFormClient<$Types.GetResult<ServiceFormPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ServiceFormClient<$Types.GetResult<ServiceFormPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ServiceForm that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFormFindFirstOrThrowArgs} args - Arguments to find a ServiceForm
     * @example
     * // Get one ServiceForm
     * const serviceForm = await prisma.serviceForm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ServiceFormFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceFormFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceFormClient<$Types.GetResult<ServiceFormPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more ServiceForms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFormFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceForms
     * const serviceForms = await prisma.serviceForm.findMany()
     * 
     * // Get first 10 ServiceForms
     * const serviceForms = await prisma.serviceForm.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceFormWithIdOnly = await prisma.serviceForm.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ServiceFormFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceFormFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ServiceFormPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ServiceForm.
     * @param {ServiceFormCreateArgs} args - Arguments to create a ServiceForm.
     * @example
     * // Create one ServiceForm
     * const ServiceForm = await prisma.serviceForm.create({
     *   data: {
     *     // ... data to create a ServiceForm
     *   }
     * })
     * 
    **/
    create<T extends ServiceFormCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceFormCreateArgs<ExtArgs>>
    ): Prisma__ServiceFormClient<$Types.GetResult<ServiceFormPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many ServiceForms.
     *     @param {ServiceFormCreateManyArgs} args - Arguments to create many ServiceForms.
     *     @example
     *     // Create many ServiceForms
     *     const serviceForm = await prisma.serviceForm.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ServiceFormCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceFormCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ServiceForm.
     * @param {ServiceFormDeleteArgs} args - Arguments to delete one ServiceForm.
     * @example
     * // Delete one ServiceForm
     * const ServiceForm = await prisma.serviceForm.delete({
     *   where: {
     *     // ... filter to delete one ServiceForm
     *   }
     * })
     * 
    **/
    delete<T extends ServiceFormDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceFormDeleteArgs<ExtArgs>>
    ): Prisma__ServiceFormClient<$Types.GetResult<ServiceFormPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ServiceForm.
     * @param {ServiceFormUpdateArgs} args - Arguments to update one ServiceForm.
     * @example
     * // Update one ServiceForm
     * const serviceForm = await prisma.serviceForm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ServiceFormUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceFormUpdateArgs<ExtArgs>>
    ): Prisma__ServiceFormClient<$Types.GetResult<ServiceFormPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more ServiceForms.
     * @param {ServiceFormDeleteManyArgs} args - Arguments to filter ServiceForms to delete.
     * @example
     * // Delete a few ServiceForms
     * const { count } = await prisma.serviceForm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ServiceFormDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceFormDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFormUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceForms
     * const serviceForm = await prisma.serviceForm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ServiceFormUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceFormUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceForm.
     * @param {ServiceFormUpsertArgs} args - Arguments to update or create a ServiceForm.
     * @example
     * // Update or create a ServiceForm
     * const serviceForm = await prisma.serviceForm.upsert({
     *   create: {
     *     // ... data to create a ServiceForm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceForm we want to update
     *   }
     * })
    **/
    upsert<T extends ServiceFormUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceFormUpsertArgs<ExtArgs>>
    ): Prisma__ServiceFormClient<$Types.GetResult<ServiceFormPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of ServiceForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFormCountArgs} args - Arguments to filter ServiceForms to count.
     * @example
     * // Count the number of ServiceForms
     * const count = await prisma.serviceForm.count({
     *   where: {
     *     // ... the filter for the ServiceForms we want to count
     *   }
     * })
    **/
    count<T extends ServiceFormCountArgs>(
      args?: Subset<T, ServiceFormCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceFormCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFormAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceFormAggregateArgs>(args: Subset<T, ServiceFormAggregateArgs>): Prisma.PrismaPromise<GetServiceFormAggregateType<T>>

    /**
     * Group by ServiceForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFormGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceFormGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceFormGroupByArgs['orderBy'] }
        : { orderBy?: ServiceFormGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceFormGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceFormGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceForm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ServiceFormClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    service<T extends ServiceArgs<ExtArgs> = {}>(args?: Subset<T, ServiceArgs<ExtArgs>>): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    serviceSubForm<T extends ServiceForm$serviceSubFormArgs<ExtArgs> = {}>(args?: Subset<T, ServiceForm$serviceSubFormArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ServiceSubFormPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ServiceForm base type for findUnique actions
   */
  export type ServiceFormFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceFormInclude<ExtArgs> | null
    /**
     * Filter, which ServiceForm to fetch.
     */
    where: ServiceFormWhereUniqueInput
  }

  /**
   * ServiceForm findUnique
   */
  export interface ServiceFormFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ServiceFormFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ServiceForm findUniqueOrThrow
   */
  export type ServiceFormFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceFormInclude<ExtArgs> | null
    /**
     * Filter, which ServiceForm to fetch.
     */
    where: ServiceFormWhereUniqueInput
  }


  /**
   * ServiceForm base type for findFirst actions
   */
  export type ServiceFormFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceFormInclude<ExtArgs> | null
    /**
     * Filter, which ServiceForm to fetch.
     */
    where?: ServiceFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceForms to fetch.
     */
    orderBy?: Enumerable<ServiceFormOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceForms.
     */
    cursor?: ServiceFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceForms.
     */
    distinct?: Enumerable<ServiceFormScalarFieldEnum>
  }

  /**
   * ServiceForm findFirst
   */
  export interface ServiceFormFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ServiceFormFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ServiceForm findFirstOrThrow
   */
  export type ServiceFormFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceFormInclude<ExtArgs> | null
    /**
     * Filter, which ServiceForm to fetch.
     */
    where?: ServiceFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceForms to fetch.
     */
    orderBy?: Enumerable<ServiceFormOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceForms.
     */
    cursor?: ServiceFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceForms.
     */
    distinct?: Enumerable<ServiceFormScalarFieldEnum>
  }


  /**
   * ServiceForm findMany
   */
  export type ServiceFormFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceFormInclude<ExtArgs> | null
    /**
     * Filter, which ServiceForms to fetch.
     */
    where?: ServiceFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceForms to fetch.
     */
    orderBy?: Enumerable<ServiceFormOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceForms.
     */
    cursor?: ServiceFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceForms.
     */
    skip?: number
    distinct?: Enumerable<ServiceFormScalarFieldEnum>
  }


  /**
   * ServiceForm create
   */
  export type ServiceFormCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceFormInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceForm.
     */
    data: XOR<ServiceFormCreateInput, ServiceFormUncheckedCreateInput>
  }


  /**
   * ServiceForm createMany
   */
  export type ServiceFormCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceForms.
     */
    data: Enumerable<ServiceFormCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ServiceForm update
   */
  export type ServiceFormUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceFormInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceForm.
     */
    data: XOR<ServiceFormUpdateInput, ServiceFormUncheckedUpdateInput>
    /**
     * Choose, which ServiceForm to update.
     */
    where: ServiceFormWhereUniqueInput
  }


  /**
   * ServiceForm updateMany
   */
  export type ServiceFormUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceForms.
     */
    data: XOR<ServiceFormUpdateManyMutationInput, ServiceFormUncheckedUpdateManyInput>
    /**
     * Filter which ServiceForms to update
     */
    where?: ServiceFormWhereInput
  }


  /**
   * ServiceForm upsert
   */
  export type ServiceFormUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceFormInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceForm to update in case it exists.
     */
    where: ServiceFormWhereUniqueInput
    /**
     * In case the ServiceForm found by the `where` argument doesn't exist, create a new ServiceForm with this data.
     */
    create: XOR<ServiceFormCreateInput, ServiceFormUncheckedCreateInput>
    /**
     * In case the ServiceForm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceFormUpdateInput, ServiceFormUncheckedUpdateInput>
  }


  /**
   * ServiceForm delete
   */
  export type ServiceFormDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceFormInclude<ExtArgs> | null
    /**
     * Filter which ServiceForm to delete.
     */
    where: ServiceFormWhereUniqueInput
  }


  /**
   * ServiceForm deleteMany
   */
  export type ServiceFormDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceForms to delete
     */
    where?: ServiceFormWhereInput
  }


  /**
   * ServiceForm.serviceSubForm
   */
  export type ServiceForm$serviceSubFormArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubForm
     */
    select?: ServiceSubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubFormInclude<ExtArgs> | null
    where?: ServiceSubFormWhereInput
    orderBy?: Enumerable<ServiceSubFormOrderByWithRelationInput>
    cursor?: ServiceSubFormWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ServiceSubFormScalarFieldEnum>
  }


  /**
   * ServiceForm without action
   */
  export type ServiceFormArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceFormInclude<ExtArgs> | null
  }



  /**
   * Model ServiceSubForm
   */


  export type AggregateServiceSubForm = {
    _count: ServiceSubFormCountAggregateOutputType | null
    _min: ServiceSubFormMinAggregateOutputType | null
    _max: ServiceSubFormMaxAggregateOutputType | null
  }

  export type ServiceSubFormMinAggregateOutputType = {
    id: string | null
    question: string | null
    type: string | null
    compulsory: boolean | null
    fileName: string | null
    fileDescription: string | null
    fileType: string | null
    fileLink: string | null
    serviceFormId: string | null
  }

  export type ServiceSubFormMaxAggregateOutputType = {
    id: string | null
    question: string | null
    type: string | null
    compulsory: boolean | null
    fileName: string | null
    fileDescription: string | null
    fileType: string | null
    fileLink: string | null
    serviceFormId: string | null
  }

  export type ServiceSubFormCountAggregateOutputType = {
    id: number
    question: number
    options: number
    type: number
    compulsory: number
    fileName: number
    fileDescription: number
    fileType: number
    fileLink: number
    serviceFormId: number
    _all: number
  }


  export type ServiceSubFormMinAggregateInputType = {
    id?: true
    question?: true
    type?: true
    compulsory?: true
    fileName?: true
    fileDescription?: true
    fileType?: true
    fileLink?: true
    serviceFormId?: true
  }

  export type ServiceSubFormMaxAggregateInputType = {
    id?: true
    question?: true
    type?: true
    compulsory?: true
    fileName?: true
    fileDescription?: true
    fileType?: true
    fileLink?: true
    serviceFormId?: true
  }

  export type ServiceSubFormCountAggregateInputType = {
    id?: true
    question?: true
    options?: true
    type?: true
    compulsory?: true
    fileName?: true
    fileDescription?: true
    fileType?: true
    fileLink?: true
    serviceFormId?: true
    _all?: true
  }

  export type ServiceSubFormAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceSubForm to aggregate.
     */
    where?: ServiceSubFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSubForms to fetch.
     */
    orderBy?: Enumerable<ServiceSubFormOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceSubFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSubForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSubForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceSubForms
    **/
    _count?: true | ServiceSubFormCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceSubFormMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceSubFormMaxAggregateInputType
  }

  export type GetServiceSubFormAggregateType<T extends ServiceSubFormAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceSubForm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceSubForm[P]>
      : GetScalarType<T[P], AggregateServiceSubForm[P]>
  }




  export type ServiceSubFormGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ServiceSubFormWhereInput
    orderBy?: Enumerable<ServiceSubFormOrderByWithAggregationInput>
    by: ServiceSubFormScalarFieldEnum[]
    having?: ServiceSubFormScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceSubFormCountAggregateInputType | true
    _min?: ServiceSubFormMinAggregateInputType
    _max?: ServiceSubFormMaxAggregateInputType
  }


  export type ServiceSubFormGroupByOutputType = {
    id: string
    question: string
    options: string[]
    type: string
    compulsory: boolean
    fileName: string
    fileDescription: string
    fileType: string
    fileLink: string
    serviceFormId: string
    _count: ServiceSubFormCountAggregateOutputType | null
    _min: ServiceSubFormMinAggregateOutputType | null
    _max: ServiceSubFormMaxAggregateOutputType | null
  }

  type GetServiceSubFormGroupByPayload<T extends ServiceSubFormGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ServiceSubFormGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceSubFormGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceSubFormGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceSubFormGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSubFormSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    options?: boolean
    type?: boolean
    compulsory?: boolean
    fileName?: boolean
    fileDescription?: boolean
    fileType?: boolean
    fileLink?: boolean
    serviceFormId?: boolean
    serviceForm?: boolean | ServiceFormArgs<ExtArgs>
  }, ExtArgs["result"]["serviceSubForm"]>

  export type ServiceSubFormSelectScalar = {
    id?: boolean
    question?: boolean
    options?: boolean
    type?: boolean
    compulsory?: boolean
    fileName?: boolean
    fileDescription?: boolean
    fileType?: boolean
    fileLink?: boolean
    serviceFormId?: boolean
  }

  export type ServiceSubFormInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    serviceForm?: boolean | ServiceFormArgs<ExtArgs>
  }


  type ServiceSubFormGetPayload<S extends boolean | null | undefined | ServiceSubFormArgs> = $Types.GetResult<ServiceSubFormPayload, S>

  type ServiceSubFormCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ServiceSubFormFindManyArgs, 'select' | 'include'> & {
      select?: ServiceSubFormCountAggregateInputType | true
    }

  export interface ServiceSubFormDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceSubForm'], meta: { name: 'ServiceSubForm' } }
    /**
     * Find zero or one ServiceSubForm that matches the filter.
     * @param {ServiceSubFormFindUniqueArgs} args - Arguments to find a ServiceSubForm
     * @example
     * // Get one ServiceSubForm
     * const serviceSubForm = await prisma.serviceSubForm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ServiceSubFormFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ServiceSubFormFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ServiceSubForm'> extends True ? Prisma__ServiceSubFormClient<$Types.GetResult<ServiceSubFormPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ServiceSubFormClient<$Types.GetResult<ServiceSubFormPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ServiceSubForm that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ServiceSubFormFindUniqueOrThrowArgs} args - Arguments to find a ServiceSubForm
     * @example
     * // Get one ServiceSubForm
     * const serviceSubForm = await prisma.serviceSubForm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ServiceSubFormFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceSubFormFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceSubFormClient<$Types.GetResult<ServiceSubFormPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ServiceSubForm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSubFormFindFirstArgs} args - Arguments to find a ServiceSubForm
     * @example
     * // Get one ServiceSubForm
     * const serviceSubForm = await prisma.serviceSubForm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ServiceSubFormFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ServiceSubFormFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ServiceSubForm'> extends True ? Prisma__ServiceSubFormClient<$Types.GetResult<ServiceSubFormPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ServiceSubFormClient<$Types.GetResult<ServiceSubFormPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ServiceSubForm that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSubFormFindFirstOrThrowArgs} args - Arguments to find a ServiceSubForm
     * @example
     * // Get one ServiceSubForm
     * const serviceSubForm = await prisma.serviceSubForm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ServiceSubFormFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceSubFormFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceSubFormClient<$Types.GetResult<ServiceSubFormPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more ServiceSubForms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSubFormFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceSubForms
     * const serviceSubForms = await prisma.serviceSubForm.findMany()
     * 
     * // Get first 10 ServiceSubForms
     * const serviceSubForms = await prisma.serviceSubForm.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceSubFormWithIdOnly = await prisma.serviceSubForm.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ServiceSubFormFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceSubFormFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ServiceSubFormPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ServiceSubForm.
     * @param {ServiceSubFormCreateArgs} args - Arguments to create a ServiceSubForm.
     * @example
     * // Create one ServiceSubForm
     * const ServiceSubForm = await prisma.serviceSubForm.create({
     *   data: {
     *     // ... data to create a ServiceSubForm
     *   }
     * })
     * 
    **/
    create<T extends ServiceSubFormCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceSubFormCreateArgs<ExtArgs>>
    ): Prisma__ServiceSubFormClient<$Types.GetResult<ServiceSubFormPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many ServiceSubForms.
     *     @param {ServiceSubFormCreateManyArgs} args - Arguments to create many ServiceSubForms.
     *     @example
     *     // Create many ServiceSubForms
     *     const serviceSubForm = await prisma.serviceSubForm.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ServiceSubFormCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceSubFormCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ServiceSubForm.
     * @param {ServiceSubFormDeleteArgs} args - Arguments to delete one ServiceSubForm.
     * @example
     * // Delete one ServiceSubForm
     * const ServiceSubForm = await prisma.serviceSubForm.delete({
     *   where: {
     *     // ... filter to delete one ServiceSubForm
     *   }
     * })
     * 
    **/
    delete<T extends ServiceSubFormDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceSubFormDeleteArgs<ExtArgs>>
    ): Prisma__ServiceSubFormClient<$Types.GetResult<ServiceSubFormPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ServiceSubForm.
     * @param {ServiceSubFormUpdateArgs} args - Arguments to update one ServiceSubForm.
     * @example
     * // Update one ServiceSubForm
     * const serviceSubForm = await prisma.serviceSubForm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ServiceSubFormUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceSubFormUpdateArgs<ExtArgs>>
    ): Prisma__ServiceSubFormClient<$Types.GetResult<ServiceSubFormPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more ServiceSubForms.
     * @param {ServiceSubFormDeleteManyArgs} args - Arguments to filter ServiceSubForms to delete.
     * @example
     * // Delete a few ServiceSubForms
     * const { count } = await prisma.serviceSubForm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ServiceSubFormDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceSubFormDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceSubForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSubFormUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceSubForms
     * const serviceSubForm = await prisma.serviceSubForm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ServiceSubFormUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceSubFormUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceSubForm.
     * @param {ServiceSubFormUpsertArgs} args - Arguments to update or create a ServiceSubForm.
     * @example
     * // Update or create a ServiceSubForm
     * const serviceSubForm = await prisma.serviceSubForm.upsert({
     *   create: {
     *     // ... data to create a ServiceSubForm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceSubForm we want to update
     *   }
     * })
    **/
    upsert<T extends ServiceSubFormUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceSubFormUpsertArgs<ExtArgs>>
    ): Prisma__ServiceSubFormClient<$Types.GetResult<ServiceSubFormPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of ServiceSubForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSubFormCountArgs} args - Arguments to filter ServiceSubForms to count.
     * @example
     * // Count the number of ServiceSubForms
     * const count = await prisma.serviceSubForm.count({
     *   where: {
     *     // ... the filter for the ServiceSubForms we want to count
     *   }
     * })
    **/
    count<T extends ServiceSubFormCountArgs>(
      args?: Subset<T, ServiceSubFormCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceSubFormCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceSubForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSubFormAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceSubFormAggregateArgs>(args: Subset<T, ServiceSubFormAggregateArgs>): Prisma.PrismaPromise<GetServiceSubFormAggregateType<T>>

    /**
     * Group by ServiceSubForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSubFormGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceSubFormGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceSubFormGroupByArgs['orderBy'] }
        : { orderBy?: ServiceSubFormGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceSubFormGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceSubFormGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceSubForm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ServiceSubFormClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    serviceForm<T extends ServiceFormArgs<ExtArgs> = {}>(args?: Subset<T, ServiceFormArgs<ExtArgs>>): Prisma__ServiceFormClient<$Types.GetResult<ServiceFormPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ServiceSubForm base type for findUnique actions
   */
  export type ServiceSubFormFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubForm
     */
    select?: ServiceSubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubFormInclude<ExtArgs> | null
    /**
     * Filter, which ServiceSubForm to fetch.
     */
    where: ServiceSubFormWhereUniqueInput
  }

  /**
   * ServiceSubForm findUnique
   */
  export interface ServiceSubFormFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ServiceSubFormFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ServiceSubForm findUniqueOrThrow
   */
  export type ServiceSubFormFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubForm
     */
    select?: ServiceSubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubFormInclude<ExtArgs> | null
    /**
     * Filter, which ServiceSubForm to fetch.
     */
    where: ServiceSubFormWhereUniqueInput
  }


  /**
   * ServiceSubForm base type for findFirst actions
   */
  export type ServiceSubFormFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubForm
     */
    select?: ServiceSubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubFormInclude<ExtArgs> | null
    /**
     * Filter, which ServiceSubForm to fetch.
     */
    where?: ServiceSubFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSubForms to fetch.
     */
    orderBy?: Enumerable<ServiceSubFormOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceSubForms.
     */
    cursor?: ServiceSubFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSubForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSubForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceSubForms.
     */
    distinct?: Enumerable<ServiceSubFormScalarFieldEnum>
  }

  /**
   * ServiceSubForm findFirst
   */
  export interface ServiceSubFormFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ServiceSubFormFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ServiceSubForm findFirstOrThrow
   */
  export type ServiceSubFormFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubForm
     */
    select?: ServiceSubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubFormInclude<ExtArgs> | null
    /**
     * Filter, which ServiceSubForm to fetch.
     */
    where?: ServiceSubFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSubForms to fetch.
     */
    orderBy?: Enumerable<ServiceSubFormOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceSubForms.
     */
    cursor?: ServiceSubFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSubForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSubForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceSubForms.
     */
    distinct?: Enumerable<ServiceSubFormScalarFieldEnum>
  }


  /**
   * ServiceSubForm findMany
   */
  export type ServiceSubFormFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubForm
     */
    select?: ServiceSubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubFormInclude<ExtArgs> | null
    /**
     * Filter, which ServiceSubForms to fetch.
     */
    where?: ServiceSubFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSubForms to fetch.
     */
    orderBy?: Enumerable<ServiceSubFormOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceSubForms.
     */
    cursor?: ServiceSubFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSubForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSubForms.
     */
    skip?: number
    distinct?: Enumerable<ServiceSubFormScalarFieldEnum>
  }


  /**
   * ServiceSubForm create
   */
  export type ServiceSubFormCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubForm
     */
    select?: ServiceSubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubFormInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceSubForm.
     */
    data: XOR<ServiceSubFormCreateInput, ServiceSubFormUncheckedCreateInput>
  }


  /**
   * ServiceSubForm createMany
   */
  export type ServiceSubFormCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceSubForms.
     */
    data: Enumerable<ServiceSubFormCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ServiceSubForm update
   */
  export type ServiceSubFormUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubForm
     */
    select?: ServiceSubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubFormInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceSubForm.
     */
    data: XOR<ServiceSubFormUpdateInput, ServiceSubFormUncheckedUpdateInput>
    /**
     * Choose, which ServiceSubForm to update.
     */
    where: ServiceSubFormWhereUniqueInput
  }


  /**
   * ServiceSubForm updateMany
   */
  export type ServiceSubFormUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceSubForms.
     */
    data: XOR<ServiceSubFormUpdateManyMutationInput, ServiceSubFormUncheckedUpdateManyInput>
    /**
     * Filter which ServiceSubForms to update
     */
    where?: ServiceSubFormWhereInput
  }


  /**
   * ServiceSubForm upsert
   */
  export type ServiceSubFormUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubForm
     */
    select?: ServiceSubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubFormInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceSubForm to update in case it exists.
     */
    where: ServiceSubFormWhereUniqueInput
    /**
     * In case the ServiceSubForm found by the `where` argument doesn't exist, create a new ServiceSubForm with this data.
     */
    create: XOR<ServiceSubFormCreateInput, ServiceSubFormUncheckedCreateInput>
    /**
     * In case the ServiceSubForm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceSubFormUpdateInput, ServiceSubFormUncheckedUpdateInput>
  }


  /**
   * ServiceSubForm delete
   */
  export type ServiceSubFormDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubForm
     */
    select?: ServiceSubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubFormInclude<ExtArgs> | null
    /**
     * Filter which ServiceSubForm to delete.
     */
    where: ServiceSubFormWhereUniqueInput
  }


  /**
   * ServiceSubForm deleteMany
   */
  export type ServiceSubFormDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceSubForms to delete
     */
    where?: ServiceSubFormWhereInput
  }


  /**
   * ServiceSubForm without action
   */
  export type ServiceSubFormArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubForm
     */
    select?: ServiceSubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubFormInclude<ExtArgs> | null
  }



  /**
   * Model Product
   */


  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    email: string | null
    address: string | null
    paid: boolean | null
    completed: boolean | null
    status: string | null
    currentState: ProductActivityStage | null
    createdAt: Date | null
    updatedAt: Date | null
    serviceId: string | null
    userId: string | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    email: string | null
    address: string | null
    paid: boolean | null
    completed: boolean | null
    status: string | null
    currentState: ProductActivityStage | null
    createdAt: Date | null
    updatedAt: Date | null
    serviceId: string | null
    userId: string | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    email: number
    address: number
    paid: number
    completed: number
    status: number
    currentState: number
    createdAt: number
    updatedAt: number
    serviceId: number
    userId: number
    _all: number
  }


  export type ProductMinAggregateInputType = {
    id?: true
    email?: true
    address?: true
    paid?: true
    completed?: true
    status?: true
    currentState?: true
    createdAt?: true
    updatedAt?: true
    serviceId?: true
    userId?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    email?: true
    address?: true
    paid?: true
    completed?: true
    status?: true
    currentState?: true
    createdAt?: true
    updatedAt?: true
    serviceId?: true
    userId?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    email?: true
    address?: true
    paid?: true
    completed?: true
    status?: true
    currentState?: true
    createdAt?: true
    updatedAt?: true
    serviceId?: true
    userId?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: Enumerable<ProductOrderByWithAggregationInput>
    by: ProductScalarFieldEnum[]
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }


  export type ProductGroupByOutputType = {
    id: string
    email: string | null
    address: string | null
    paid: boolean
    completed: boolean
    status: string
    currentState: ProductActivityStage
    createdAt: Date
    updatedAt: Date
    serviceId: string | null
    userId: string
    _count: ProductCountAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    address?: boolean
    paid?: boolean
    completed?: boolean
    status?: boolean
    currentState?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceId?: boolean
    userId?: boolean
    Team?: boolean | Product$TeamArgs<ExtArgs>
    service?: boolean | ServiceArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
    Payment?: boolean | Product$PaymentArgs<ExtArgs>
    productQA?: boolean | Product$productQAArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    email?: boolean
    address?: boolean
    paid?: boolean
    completed?: boolean
    status?: boolean
    currentState?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceId?: boolean
    userId?: boolean
  }

  export type ProductInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Team?: boolean | Product$TeamArgs<ExtArgs>
    service?: boolean | ServiceArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
    Payment?: boolean | Product$PaymentArgs<ExtArgs>
    productQA?: boolean | Product$productQAArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeArgs<ExtArgs>
  }


  type ProductGetPayload<S extends boolean | null | undefined | ProductArgs> = $Types.GetResult<ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ProductFindManyArgs, 'select' | 'include'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Product'> extends True ? Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Product'> extends True ? Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
    **/
    create<T extends ProductCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductCreateArgs<ExtArgs>>
    ): Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Products.
     *     @param {ProductCreateManyArgs} args - Arguments to create many Products.
     *     @example
     *     // Create many Products
     *     const product = await prisma.product.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
    **/
    delete<T extends ProductDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>
    ): Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>
    ): Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
    **/
    upsert<T extends ProductUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>
    ): Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Team<T extends Product$TeamArgs<ExtArgs> = {}>(args?: Subset<T, Product$TeamArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<TeamPayload<ExtArgs>, T, 'findMany', never>| Null>;

    service<T extends ServiceArgs<ExtArgs> = {}>(args?: Subset<T, ServiceArgs<ExtArgs>>): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    Payment<T extends Product$PaymentArgs<ExtArgs> = {}>(args?: Subset<T, Product$PaymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    productQA<T extends Product$productQAArgs<ExtArgs> = {}>(args?: Subset<T, Product$productQAArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ProductQAPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Product base type for findUnique actions
   */
  export type ProductFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUnique
   */
  export interface ProductFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProductFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product base type for findFirst actions
   */
  export type ProductFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: Enumerable<ProductScalarFieldEnum>
  }

  /**
   * Product findFirst
   */
  export interface ProductFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProductFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }


  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: Enumerable<ProductCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
  }


  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }


  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
  }


  /**
   * Product.Team
   */
  export type Product$TeamArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
    orderBy?: Enumerable<TeamOrderByWithRelationInput>
    cursor?: TeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TeamScalarFieldEnum>
  }


  /**
   * Product.Payment
   */
  export type Product$PaymentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: Enumerable<PaymentOrderByWithRelationInput>
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }


  /**
   * Product.productQA
   */
  export type Product$productQAArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQA
     */
    select?: ProductQASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductQAInclude<ExtArgs> | null
    where?: ProductQAWhereInput
    orderBy?: Enumerable<ProductQAOrderByWithRelationInput>
    cursor?: ProductQAWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductQAScalarFieldEnum>
  }


  /**
   * Product without action
   */
  export type ProductArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
  }



  /**
   * Model ProductQA
   */


  export type AggregateProductQA = {
    _count: ProductQACountAggregateOutputType | null
    _min: ProductQAMinAggregateOutputType | null
    _max: ProductQAMaxAggregateOutputType | null
  }

  export type ProductQAMinAggregateOutputType = {
    id: string | null
    question: string | null
    type: string | null
    compulsory: boolean | null
    isGeneral: boolean | null
    fileName: string | null
    fileDescription: string | null
    fileType: string | null
    fileLink: string | null
    createdAt: Date | null
    updatedAt: Date | null
    productId: string | null
  }

  export type ProductQAMaxAggregateOutputType = {
    id: string | null
    question: string | null
    type: string | null
    compulsory: boolean | null
    isGeneral: boolean | null
    fileName: string | null
    fileDescription: string | null
    fileType: string | null
    fileLink: string | null
    createdAt: Date | null
    updatedAt: Date | null
    productId: string | null
  }

  export type ProductQACountAggregateOutputType = {
    id: number
    question: number
    answer: number
    type: number
    compulsory: number
    isGeneral: number
    fileName: number
    fileDescription: number
    fileType: number
    fileLink: number
    createdAt: number
    updatedAt: number
    productId: number
    _all: number
  }


  export type ProductQAMinAggregateInputType = {
    id?: true
    question?: true
    type?: true
    compulsory?: true
    isGeneral?: true
    fileName?: true
    fileDescription?: true
    fileType?: true
    fileLink?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
  }

  export type ProductQAMaxAggregateInputType = {
    id?: true
    question?: true
    type?: true
    compulsory?: true
    isGeneral?: true
    fileName?: true
    fileDescription?: true
    fileType?: true
    fileLink?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
  }

  export type ProductQACountAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    type?: true
    compulsory?: true
    isGeneral?: true
    fileName?: true
    fileDescription?: true
    fileType?: true
    fileLink?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
    _all?: true
  }

  export type ProductQAAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductQA to aggregate.
     */
    where?: ProductQAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductQAS to fetch.
     */
    orderBy?: Enumerable<ProductQAOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductQAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductQAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductQAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductQAS
    **/
    _count?: true | ProductQACountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductQAMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductQAMaxAggregateInputType
  }

  export type GetProductQAAggregateType<T extends ProductQAAggregateArgs> = {
        [P in keyof T & keyof AggregateProductQA]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductQA[P]>
      : GetScalarType<T[P], AggregateProductQA[P]>
  }




  export type ProductQAGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductQAWhereInput
    orderBy?: Enumerable<ProductQAOrderByWithAggregationInput>
    by: ProductQAScalarFieldEnum[]
    having?: ProductQAScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductQACountAggregateInputType | true
    _min?: ProductQAMinAggregateInputType
    _max?: ProductQAMaxAggregateInputType
  }


  export type ProductQAGroupByOutputType = {
    id: string
    question: string
    answer: string[]
    type: string
    compulsory: boolean
    isGeneral: boolean
    fileName: string
    fileDescription: string
    fileType: string
    fileLink: string
    createdAt: Date
    updatedAt: Date
    productId: string
    _count: ProductQACountAggregateOutputType | null
    _min: ProductQAMinAggregateOutputType | null
    _max: ProductQAMaxAggregateOutputType | null
  }

  type GetProductQAGroupByPayload<T extends ProductQAGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProductQAGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductQAGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductQAGroupByOutputType[P]>
            : GetScalarType<T[P], ProductQAGroupByOutputType[P]>
        }
      >
    >


  export type ProductQASelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    type?: boolean
    compulsory?: boolean
    isGeneral?: boolean
    fileName?: boolean
    fileDescription?: boolean
    fileType?: boolean
    fileLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productId?: boolean
    products?: boolean | ProductArgs<ExtArgs>
    productSubForm?: boolean | ProductQA$productSubFormArgs<ExtArgs>
    _count?: boolean | ProductQACountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["productQA"]>

  export type ProductQASelectScalar = {
    id?: boolean
    question?: boolean
    answer?: boolean
    type?: boolean
    compulsory?: boolean
    isGeneral?: boolean
    fileName?: boolean
    fileDescription?: boolean
    fileType?: boolean
    fileLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productId?: boolean
  }

  export type ProductQAInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    products?: boolean | ProductArgs<ExtArgs>
    productSubForm?: boolean | ProductQA$productSubFormArgs<ExtArgs>
    _count?: boolean | ProductQACountOutputTypeArgs<ExtArgs>
  }


  type ProductQAGetPayload<S extends boolean | null | undefined | ProductQAArgs> = $Types.GetResult<ProductQAPayload, S>

  type ProductQACountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ProductQAFindManyArgs, 'select' | 'include'> & {
      select?: ProductQACountAggregateInputType | true
    }

  export interface ProductQADelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductQA'], meta: { name: 'ProductQA' } }
    /**
     * Find zero or one ProductQA that matches the filter.
     * @param {ProductQAFindUniqueArgs} args - Arguments to find a ProductQA
     * @example
     * // Get one ProductQA
     * const productQA = await prisma.productQA.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductQAFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductQAFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductQA'> extends True ? Prisma__ProductQAClient<$Types.GetResult<ProductQAPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ProductQAClient<$Types.GetResult<ProductQAPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ProductQA that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductQAFindUniqueOrThrowArgs} args - Arguments to find a ProductQA
     * @example
     * // Get one ProductQA
     * const productQA = await prisma.productQA.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductQAFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductQAFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductQAClient<$Types.GetResult<ProductQAPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ProductQA that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductQAFindFirstArgs} args - Arguments to find a ProductQA
     * @example
     * // Get one ProductQA
     * const productQA = await prisma.productQA.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductQAFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductQAFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductQA'> extends True ? Prisma__ProductQAClient<$Types.GetResult<ProductQAPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ProductQAClient<$Types.GetResult<ProductQAPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ProductQA that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductQAFindFirstOrThrowArgs} args - Arguments to find a ProductQA
     * @example
     * // Get one ProductQA
     * const productQA = await prisma.productQA.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductQAFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductQAFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductQAClient<$Types.GetResult<ProductQAPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more ProductQAS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductQAFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductQAS
     * const productQAS = await prisma.productQA.findMany()
     * 
     * // Get first 10 ProductQAS
     * const productQAS = await prisma.productQA.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productQAWithIdOnly = await prisma.productQA.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductQAFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductQAFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ProductQAPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ProductQA.
     * @param {ProductQACreateArgs} args - Arguments to create a ProductQA.
     * @example
     * // Create one ProductQA
     * const ProductQA = await prisma.productQA.create({
     *   data: {
     *     // ... data to create a ProductQA
     *   }
     * })
     * 
    **/
    create<T extends ProductQACreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductQACreateArgs<ExtArgs>>
    ): Prisma__ProductQAClient<$Types.GetResult<ProductQAPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many ProductQAS.
     *     @param {ProductQACreateManyArgs} args - Arguments to create many ProductQAS.
     *     @example
     *     // Create many ProductQAS
     *     const productQA = await prisma.productQA.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductQACreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductQACreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductQA.
     * @param {ProductQADeleteArgs} args - Arguments to delete one ProductQA.
     * @example
     * // Delete one ProductQA
     * const ProductQA = await prisma.productQA.delete({
     *   where: {
     *     // ... filter to delete one ProductQA
     *   }
     * })
     * 
    **/
    delete<T extends ProductQADeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProductQADeleteArgs<ExtArgs>>
    ): Prisma__ProductQAClient<$Types.GetResult<ProductQAPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ProductQA.
     * @param {ProductQAUpdateArgs} args - Arguments to update one ProductQA.
     * @example
     * // Update one ProductQA
     * const productQA = await prisma.productQA.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductQAUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductQAUpdateArgs<ExtArgs>>
    ): Prisma__ProductQAClient<$Types.GetResult<ProductQAPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more ProductQAS.
     * @param {ProductQADeleteManyArgs} args - Arguments to filter ProductQAS to delete.
     * @example
     * // Delete a few ProductQAS
     * const { count } = await prisma.productQA.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductQADeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductQADeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductQAS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductQAUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductQAS
     * const productQA = await prisma.productQA.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductQAUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProductQAUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductQA.
     * @param {ProductQAUpsertArgs} args - Arguments to update or create a ProductQA.
     * @example
     * // Update or create a ProductQA
     * const productQA = await prisma.productQA.upsert({
     *   create: {
     *     // ... data to create a ProductQA
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductQA we want to update
     *   }
     * })
    **/
    upsert<T extends ProductQAUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProductQAUpsertArgs<ExtArgs>>
    ): Prisma__ProductQAClient<$Types.GetResult<ProductQAPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of ProductQAS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductQACountArgs} args - Arguments to filter ProductQAS to count.
     * @example
     * // Count the number of ProductQAS
     * const count = await prisma.productQA.count({
     *   where: {
     *     // ... the filter for the ProductQAS we want to count
     *   }
     * })
    **/
    count<T extends ProductQACountArgs>(
      args?: Subset<T, ProductQACountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductQACountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductQA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductQAAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductQAAggregateArgs>(args: Subset<T, ProductQAAggregateArgs>): Prisma.PrismaPromise<GetProductQAAggregateType<T>>

    /**
     * Group by ProductQA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductQAGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductQAGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductQAGroupByArgs['orderBy'] }
        : { orderBy?: ProductQAGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductQAGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductQAGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductQA.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductQAClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    products<T extends ProductArgs<ExtArgs> = {}>(args?: Subset<T, ProductArgs<ExtArgs>>): Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    productSubForm<T extends ProductQA$productSubFormArgs<ExtArgs> = {}>(args?: Subset<T, ProductQA$productSubFormArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ProductQASubFormPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ProductQA base type for findUnique actions
   */
  export type ProductQAFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQA
     */
    select?: ProductQASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductQAInclude<ExtArgs> | null
    /**
     * Filter, which ProductQA to fetch.
     */
    where: ProductQAWhereUniqueInput
  }

  /**
   * ProductQA findUnique
   */
  export interface ProductQAFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProductQAFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductQA findUniqueOrThrow
   */
  export type ProductQAFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQA
     */
    select?: ProductQASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductQAInclude<ExtArgs> | null
    /**
     * Filter, which ProductQA to fetch.
     */
    where: ProductQAWhereUniqueInput
  }


  /**
   * ProductQA base type for findFirst actions
   */
  export type ProductQAFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQA
     */
    select?: ProductQASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductQAInclude<ExtArgs> | null
    /**
     * Filter, which ProductQA to fetch.
     */
    where?: ProductQAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductQAS to fetch.
     */
    orderBy?: Enumerable<ProductQAOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductQAS.
     */
    cursor?: ProductQAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductQAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductQAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductQAS.
     */
    distinct?: Enumerable<ProductQAScalarFieldEnum>
  }

  /**
   * ProductQA findFirst
   */
  export interface ProductQAFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProductQAFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductQA findFirstOrThrow
   */
  export type ProductQAFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQA
     */
    select?: ProductQASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductQAInclude<ExtArgs> | null
    /**
     * Filter, which ProductQA to fetch.
     */
    where?: ProductQAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductQAS to fetch.
     */
    orderBy?: Enumerable<ProductQAOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductQAS.
     */
    cursor?: ProductQAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductQAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductQAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductQAS.
     */
    distinct?: Enumerable<ProductQAScalarFieldEnum>
  }


  /**
   * ProductQA findMany
   */
  export type ProductQAFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQA
     */
    select?: ProductQASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductQAInclude<ExtArgs> | null
    /**
     * Filter, which ProductQAS to fetch.
     */
    where?: ProductQAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductQAS to fetch.
     */
    orderBy?: Enumerable<ProductQAOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductQAS.
     */
    cursor?: ProductQAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductQAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductQAS.
     */
    skip?: number
    distinct?: Enumerable<ProductQAScalarFieldEnum>
  }


  /**
   * ProductQA create
   */
  export type ProductQACreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQA
     */
    select?: ProductQASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductQAInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductQA.
     */
    data: XOR<ProductQACreateInput, ProductQAUncheckedCreateInput>
  }


  /**
   * ProductQA createMany
   */
  export type ProductQACreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductQAS.
     */
    data: Enumerable<ProductQACreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductQA update
   */
  export type ProductQAUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQA
     */
    select?: ProductQASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductQAInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductQA.
     */
    data: XOR<ProductQAUpdateInput, ProductQAUncheckedUpdateInput>
    /**
     * Choose, which ProductQA to update.
     */
    where: ProductQAWhereUniqueInput
  }


  /**
   * ProductQA updateMany
   */
  export type ProductQAUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductQAS.
     */
    data: XOR<ProductQAUpdateManyMutationInput, ProductQAUncheckedUpdateManyInput>
    /**
     * Filter which ProductQAS to update
     */
    where?: ProductQAWhereInput
  }


  /**
   * ProductQA upsert
   */
  export type ProductQAUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQA
     */
    select?: ProductQASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductQAInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductQA to update in case it exists.
     */
    where: ProductQAWhereUniqueInput
    /**
     * In case the ProductQA found by the `where` argument doesn't exist, create a new ProductQA with this data.
     */
    create: XOR<ProductQACreateInput, ProductQAUncheckedCreateInput>
    /**
     * In case the ProductQA was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductQAUpdateInput, ProductQAUncheckedUpdateInput>
  }


  /**
   * ProductQA delete
   */
  export type ProductQADeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQA
     */
    select?: ProductQASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductQAInclude<ExtArgs> | null
    /**
     * Filter which ProductQA to delete.
     */
    where: ProductQAWhereUniqueInput
  }


  /**
   * ProductQA deleteMany
   */
  export type ProductQADeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductQAS to delete
     */
    where?: ProductQAWhereInput
  }


  /**
   * ProductQA.productSubForm
   */
  export type ProductQA$productSubFormArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQASubForm
     */
    select?: ProductQASubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductQASubFormInclude<ExtArgs> | null
    where?: ProductQASubFormWhereInput
    orderBy?: Enumerable<ProductQASubFormOrderByWithRelationInput>
    cursor?: ProductQASubFormWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductQASubFormScalarFieldEnum>
  }


  /**
   * ProductQA without action
   */
  export type ProductQAArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQA
     */
    select?: ProductQASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductQAInclude<ExtArgs> | null
  }



  /**
   * Model ProductQASubForm
   */


  export type AggregateProductQASubForm = {
    _count: ProductQASubFormCountAggregateOutputType | null
    _min: ProductQASubFormMinAggregateOutputType | null
    _max: ProductQASubFormMaxAggregateOutputType | null
  }

  export type ProductQASubFormMinAggregateOutputType = {
    id: string | null
    question: string | null
    type: string | null
    compulsory: boolean | null
    productQAId: string | null
  }

  export type ProductQASubFormMaxAggregateOutputType = {
    id: string | null
    question: string | null
    type: string | null
    compulsory: boolean | null
    productQAId: string | null
  }

  export type ProductQASubFormCountAggregateOutputType = {
    id: number
    question: number
    answer: number
    type: number
    compulsory: number
    productQAId: number
    _all: number
  }


  export type ProductQASubFormMinAggregateInputType = {
    id?: true
    question?: true
    type?: true
    compulsory?: true
    productQAId?: true
  }

  export type ProductQASubFormMaxAggregateInputType = {
    id?: true
    question?: true
    type?: true
    compulsory?: true
    productQAId?: true
  }

  export type ProductQASubFormCountAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    type?: true
    compulsory?: true
    productQAId?: true
    _all?: true
  }

  export type ProductQASubFormAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductQASubForm to aggregate.
     */
    where?: ProductQASubFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductQASubForms to fetch.
     */
    orderBy?: Enumerable<ProductQASubFormOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductQASubFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductQASubForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductQASubForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductQASubForms
    **/
    _count?: true | ProductQASubFormCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductQASubFormMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductQASubFormMaxAggregateInputType
  }

  export type GetProductQASubFormAggregateType<T extends ProductQASubFormAggregateArgs> = {
        [P in keyof T & keyof AggregateProductQASubForm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductQASubForm[P]>
      : GetScalarType<T[P], AggregateProductQASubForm[P]>
  }




  export type ProductQASubFormGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductQASubFormWhereInput
    orderBy?: Enumerable<ProductQASubFormOrderByWithAggregationInput>
    by: ProductQASubFormScalarFieldEnum[]
    having?: ProductQASubFormScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductQASubFormCountAggregateInputType | true
    _min?: ProductQASubFormMinAggregateInputType
    _max?: ProductQASubFormMaxAggregateInputType
  }


  export type ProductQASubFormGroupByOutputType = {
    id: string
    question: string
    answer: string[]
    type: string
    compulsory: boolean
    productQAId: string
    _count: ProductQASubFormCountAggregateOutputType | null
    _min: ProductQASubFormMinAggregateOutputType | null
    _max: ProductQASubFormMaxAggregateOutputType | null
  }

  type GetProductQASubFormGroupByPayload<T extends ProductQASubFormGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProductQASubFormGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductQASubFormGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductQASubFormGroupByOutputType[P]>
            : GetScalarType<T[P], ProductQASubFormGroupByOutputType[P]>
        }
      >
    >


  export type ProductQASubFormSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    type?: boolean
    compulsory?: boolean
    productQAId?: boolean
    productQA?: boolean | ProductQAArgs<ExtArgs>
  }, ExtArgs["result"]["productQASubForm"]>

  export type ProductQASubFormSelectScalar = {
    id?: boolean
    question?: boolean
    answer?: boolean
    type?: boolean
    compulsory?: boolean
    productQAId?: boolean
  }

  export type ProductQASubFormInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    productQA?: boolean | ProductQAArgs<ExtArgs>
  }


  type ProductQASubFormGetPayload<S extends boolean | null | undefined | ProductQASubFormArgs> = $Types.GetResult<ProductQASubFormPayload, S>

  type ProductQASubFormCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ProductQASubFormFindManyArgs, 'select' | 'include'> & {
      select?: ProductQASubFormCountAggregateInputType | true
    }

  export interface ProductQASubFormDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductQASubForm'], meta: { name: 'ProductQASubForm' } }
    /**
     * Find zero or one ProductQASubForm that matches the filter.
     * @param {ProductQASubFormFindUniqueArgs} args - Arguments to find a ProductQASubForm
     * @example
     * // Get one ProductQASubForm
     * const productQASubForm = await prisma.productQASubForm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductQASubFormFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductQASubFormFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductQASubForm'> extends True ? Prisma__ProductQASubFormClient<$Types.GetResult<ProductQASubFormPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ProductQASubFormClient<$Types.GetResult<ProductQASubFormPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ProductQASubForm that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductQASubFormFindUniqueOrThrowArgs} args - Arguments to find a ProductQASubForm
     * @example
     * // Get one ProductQASubForm
     * const productQASubForm = await prisma.productQASubForm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductQASubFormFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductQASubFormFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductQASubFormClient<$Types.GetResult<ProductQASubFormPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ProductQASubForm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductQASubFormFindFirstArgs} args - Arguments to find a ProductQASubForm
     * @example
     * // Get one ProductQASubForm
     * const productQASubForm = await prisma.productQASubForm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductQASubFormFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductQASubFormFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductQASubForm'> extends True ? Prisma__ProductQASubFormClient<$Types.GetResult<ProductQASubFormPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ProductQASubFormClient<$Types.GetResult<ProductQASubFormPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ProductQASubForm that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductQASubFormFindFirstOrThrowArgs} args - Arguments to find a ProductQASubForm
     * @example
     * // Get one ProductQASubForm
     * const productQASubForm = await prisma.productQASubForm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductQASubFormFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductQASubFormFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductQASubFormClient<$Types.GetResult<ProductQASubFormPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more ProductQASubForms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductQASubFormFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductQASubForms
     * const productQASubForms = await prisma.productQASubForm.findMany()
     * 
     * // Get first 10 ProductQASubForms
     * const productQASubForms = await prisma.productQASubForm.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productQASubFormWithIdOnly = await prisma.productQASubForm.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductQASubFormFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductQASubFormFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ProductQASubFormPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ProductQASubForm.
     * @param {ProductQASubFormCreateArgs} args - Arguments to create a ProductQASubForm.
     * @example
     * // Create one ProductQASubForm
     * const ProductQASubForm = await prisma.productQASubForm.create({
     *   data: {
     *     // ... data to create a ProductQASubForm
     *   }
     * })
     * 
    **/
    create<T extends ProductQASubFormCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductQASubFormCreateArgs<ExtArgs>>
    ): Prisma__ProductQASubFormClient<$Types.GetResult<ProductQASubFormPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many ProductQASubForms.
     *     @param {ProductQASubFormCreateManyArgs} args - Arguments to create many ProductQASubForms.
     *     @example
     *     // Create many ProductQASubForms
     *     const productQASubForm = await prisma.productQASubForm.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductQASubFormCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductQASubFormCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductQASubForm.
     * @param {ProductQASubFormDeleteArgs} args - Arguments to delete one ProductQASubForm.
     * @example
     * // Delete one ProductQASubForm
     * const ProductQASubForm = await prisma.productQASubForm.delete({
     *   where: {
     *     // ... filter to delete one ProductQASubForm
     *   }
     * })
     * 
    **/
    delete<T extends ProductQASubFormDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProductQASubFormDeleteArgs<ExtArgs>>
    ): Prisma__ProductQASubFormClient<$Types.GetResult<ProductQASubFormPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ProductQASubForm.
     * @param {ProductQASubFormUpdateArgs} args - Arguments to update one ProductQASubForm.
     * @example
     * // Update one ProductQASubForm
     * const productQASubForm = await prisma.productQASubForm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductQASubFormUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductQASubFormUpdateArgs<ExtArgs>>
    ): Prisma__ProductQASubFormClient<$Types.GetResult<ProductQASubFormPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more ProductQASubForms.
     * @param {ProductQASubFormDeleteManyArgs} args - Arguments to filter ProductQASubForms to delete.
     * @example
     * // Delete a few ProductQASubForms
     * const { count } = await prisma.productQASubForm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductQASubFormDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductQASubFormDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductQASubForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductQASubFormUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductQASubForms
     * const productQASubForm = await prisma.productQASubForm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductQASubFormUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProductQASubFormUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductQASubForm.
     * @param {ProductQASubFormUpsertArgs} args - Arguments to update or create a ProductQASubForm.
     * @example
     * // Update or create a ProductQASubForm
     * const productQASubForm = await prisma.productQASubForm.upsert({
     *   create: {
     *     // ... data to create a ProductQASubForm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductQASubForm we want to update
     *   }
     * })
    **/
    upsert<T extends ProductQASubFormUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProductQASubFormUpsertArgs<ExtArgs>>
    ): Prisma__ProductQASubFormClient<$Types.GetResult<ProductQASubFormPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of ProductQASubForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductQASubFormCountArgs} args - Arguments to filter ProductQASubForms to count.
     * @example
     * // Count the number of ProductQASubForms
     * const count = await prisma.productQASubForm.count({
     *   where: {
     *     // ... the filter for the ProductQASubForms we want to count
     *   }
     * })
    **/
    count<T extends ProductQASubFormCountArgs>(
      args?: Subset<T, ProductQASubFormCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductQASubFormCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductQASubForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductQASubFormAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductQASubFormAggregateArgs>(args: Subset<T, ProductQASubFormAggregateArgs>): Prisma.PrismaPromise<GetProductQASubFormAggregateType<T>>

    /**
     * Group by ProductQASubForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductQASubFormGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductQASubFormGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductQASubFormGroupByArgs['orderBy'] }
        : { orderBy?: ProductQASubFormGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductQASubFormGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductQASubFormGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductQASubForm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductQASubFormClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    productQA<T extends ProductQAArgs<ExtArgs> = {}>(args?: Subset<T, ProductQAArgs<ExtArgs>>): Prisma__ProductQAClient<$Types.GetResult<ProductQAPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ProductQASubForm base type for findUnique actions
   */
  export type ProductQASubFormFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQASubForm
     */
    select?: ProductQASubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductQASubFormInclude<ExtArgs> | null
    /**
     * Filter, which ProductQASubForm to fetch.
     */
    where: ProductQASubFormWhereUniqueInput
  }

  /**
   * ProductQASubForm findUnique
   */
  export interface ProductQASubFormFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProductQASubFormFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductQASubForm findUniqueOrThrow
   */
  export type ProductQASubFormFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQASubForm
     */
    select?: ProductQASubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductQASubFormInclude<ExtArgs> | null
    /**
     * Filter, which ProductQASubForm to fetch.
     */
    where: ProductQASubFormWhereUniqueInput
  }


  /**
   * ProductQASubForm base type for findFirst actions
   */
  export type ProductQASubFormFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQASubForm
     */
    select?: ProductQASubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductQASubFormInclude<ExtArgs> | null
    /**
     * Filter, which ProductQASubForm to fetch.
     */
    where?: ProductQASubFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductQASubForms to fetch.
     */
    orderBy?: Enumerable<ProductQASubFormOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductQASubForms.
     */
    cursor?: ProductQASubFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductQASubForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductQASubForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductQASubForms.
     */
    distinct?: Enumerable<ProductQASubFormScalarFieldEnum>
  }

  /**
   * ProductQASubForm findFirst
   */
  export interface ProductQASubFormFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProductQASubFormFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductQASubForm findFirstOrThrow
   */
  export type ProductQASubFormFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQASubForm
     */
    select?: ProductQASubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductQASubFormInclude<ExtArgs> | null
    /**
     * Filter, which ProductQASubForm to fetch.
     */
    where?: ProductQASubFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductQASubForms to fetch.
     */
    orderBy?: Enumerable<ProductQASubFormOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductQASubForms.
     */
    cursor?: ProductQASubFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductQASubForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductQASubForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductQASubForms.
     */
    distinct?: Enumerable<ProductQASubFormScalarFieldEnum>
  }


  /**
   * ProductQASubForm findMany
   */
  export type ProductQASubFormFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQASubForm
     */
    select?: ProductQASubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductQASubFormInclude<ExtArgs> | null
    /**
     * Filter, which ProductQASubForms to fetch.
     */
    where?: ProductQASubFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductQASubForms to fetch.
     */
    orderBy?: Enumerable<ProductQASubFormOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductQASubForms.
     */
    cursor?: ProductQASubFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductQASubForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductQASubForms.
     */
    skip?: number
    distinct?: Enumerable<ProductQASubFormScalarFieldEnum>
  }


  /**
   * ProductQASubForm create
   */
  export type ProductQASubFormCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQASubForm
     */
    select?: ProductQASubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductQASubFormInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductQASubForm.
     */
    data: XOR<ProductQASubFormCreateInput, ProductQASubFormUncheckedCreateInput>
  }


  /**
   * ProductQASubForm createMany
   */
  export type ProductQASubFormCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductQASubForms.
     */
    data: Enumerable<ProductQASubFormCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductQASubForm update
   */
  export type ProductQASubFormUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQASubForm
     */
    select?: ProductQASubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductQASubFormInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductQASubForm.
     */
    data: XOR<ProductQASubFormUpdateInput, ProductQASubFormUncheckedUpdateInput>
    /**
     * Choose, which ProductQASubForm to update.
     */
    where: ProductQASubFormWhereUniqueInput
  }


  /**
   * ProductQASubForm updateMany
   */
  export type ProductQASubFormUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductQASubForms.
     */
    data: XOR<ProductQASubFormUpdateManyMutationInput, ProductQASubFormUncheckedUpdateManyInput>
    /**
     * Filter which ProductQASubForms to update
     */
    where?: ProductQASubFormWhereInput
  }


  /**
   * ProductQASubForm upsert
   */
  export type ProductQASubFormUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQASubForm
     */
    select?: ProductQASubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductQASubFormInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductQASubForm to update in case it exists.
     */
    where: ProductQASubFormWhereUniqueInput
    /**
     * In case the ProductQASubForm found by the `where` argument doesn't exist, create a new ProductQASubForm with this data.
     */
    create: XOR<ProductQASubFormCreateInput, ProductQASubFormUncheckedCreateInput>
    /**
     * In case the ProductQASubForm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductQASubFormUpdateInput, ProductQASubFormUncheckedUpdateInput>
  }


  /**
   * ProductQASubForm delete
   */
  export type ProductQASubFormDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQASubForm
     */
    select?: ProductQASubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductQASubFormInclude<ExtArgs> | null
    /**
     * Filter which ProductQASubForm to delete.
     */
    where: ProductQASubFormWhereUniqueInput
  }


  /**
   * ProductQASubForm deleteMany
   */
  export type ProductQASubFormDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductQASubForms to delete
     */
    where?: ProductQASubFormWhereInput
  }


  /**
   * ProductQASubForm without action
   */
  export type ProductQASubFormArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQASubForm
     */
    select?: ProductQASubFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductQASubFormInclude<ExtArgs> | null
  }



  /**
   * Model Claim
   */


  export type AggregateClaim = {
    _count: ClaimCountAggregateOutputType | null
    _min: ClaimMinAggregateOutputType | null
    _max: ClaimMaxAggregateOutputType | null
  }

  export type ClaimMinAggregateOutputType = {
    id: string | null
    value: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClaimMaxAggregateOutputType = {
    id: string | null
    value: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClaimCountAggregateOutputType = {
    id: number
    value: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClaimMinAggregateInputType = {
    id?: true
    value?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClaimMaxAggregateInputType = {
    id?: true
    value?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClaimCountAggregateInputType = {
    id?: true
    value?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClaimAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Claim to aggregate.
     */
    where?: ClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claims to fetch.
     */
    orderBy?: Enumerable<ClaimOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Claims
    **/
    _count?: true | ClaimCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClaimMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClaimMaxAggregateInputType
  }

  export type GetClaimAggregateType<T extends ClaimAggregateArgs> = {
        [P in keyof T & keyof AggregateClaim]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClaim[P]>
      : GetScalarType<T[P], AggregateClaim[P]>
  }




  export type ClaimGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ClaimWhereInput
    orderBy?: Enumerable<ClaimOrderByWithAggregationInput>
    by: ClaimScalarFieldEnum[]
    having?: ClaimScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClaimCountAggregateInputType | true
    _min?: ClaimMinAggregateInputType
    _max?: ClaimMaxAggregateInputType
  }


  export type ClaimGroupByOutputType = {
    id: string
    value: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: ClaimCountAggregateOutputType | null
    _min: ClaimMinAggregateOutputType | null
    _max: ClaimMaxAggregateOutputType | null
  }

  type GetClaimGroupByPayload<T extends ClaimGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ClaimGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClaimGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClaimGroupByOutputType[P]>
            : GetScalarType<T[P], ClaimGroupByOutputType[P]>
        }
      >
    >


  export type ClaimSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["claim"]>

  export type ClaimSelectScalar = {
    id?: boolean
    value?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  type ClaimGetPayload<S extends boolean | null | undefined | ClaimArgs> = $Types.GetResult<ClaimPayload, S>

  type ClaimCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ClaimFindManyArgs, 'select' | 'include'> & {
      select?: ClaimCountAggregateInputType | true
    }

  export interface ClaimDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Claim'], meta: { name: 'Claim' } }
    /**
     * Find zero or one Claim that matches the filter.
     * @param {ClaimFindUniqueArgs} args - Arguments to find a Claim
     * @example
     * // Get one Claim
     * const claim = await prisma.claim.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClaimFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ClaimFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Claim'> extends True ? Prisma__ClaimClient<$Types.GetResult<ClaimPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ClaimClient<$Types.GetResult<ClaimPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Claim that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ClaimFindUniqueOrThrowArgs} args - Arguments to find a Claim
     * @example
     * // Get one Claim
     * const claim = await prisma.claim.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClaimFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClaimClient<$Types.GetResult<ClaimPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Claim that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimFindFirstArgs} args - Arguments to find a Claim
     * @example
     * // Get one Claim
     * const claim = await prisma.claim.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClaimFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ClaimFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Claim'> extends True ? Prisma__ClaimClient<$Types.GetResult<ClaimPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ClaimClient<$Types.GetResult<ClaimPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Claim that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimFindFirstOrThrowArgs} args - Arguments to find a Claim
     * @example
     * // Get one Claim
     * const claim = await prisma.claim.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClaimFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClaimClient<$Types.GetResult<ClaimPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Claims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Claims
     * const claims = await prisma.claim.findMany()
     * 
     * // Get first 10 Claims
     * const claims = await prisma.claim.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const claimWithIdOnly = await prisma.claim.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClaimFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ClaimPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Claim.
     * @param {ClaimCreateArgs} args - Arguments to create a Claim.
     * @example
     * // Create one Claim
     * const Claim = await prisma.claim.create({
     *   data: {
     *     // ... data to create a Claim
     *   }
     * })
     * 
    **/
    create<T extends ClaimCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimCreateArgs<ExtArgs>>
    ): Prisma__ClaimClient<$Types.GetResult<ClaimPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Claims.
     *     @param {ClaimCreateManyArgs} args - Arguments to create many Claims.
     *     @example
     *     // Create many Claims
     *     const claim = await prisma.claim.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ClaimCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Claim.
     * @param {ClaimDeleteArgs} args - Arguments to delete one Claim.
     * @example
     * // Delete one Claim
     * const Claim = await prisma.claim.delete({
     *   where: {
     *     // ... filter to delete one Claim
     *   }
     * })
     * 
    **/
    delete<T extends ClaimDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimDeleteArgs<ExtArgs>>
    ): Prisma__ClaimClient<$Types.GetResult<ClaimPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Claim.
     * @param {ClaimUpdateArgs} args - Arguments to update one Claim.
     * @example
     * // Update one Claim
     * const claim = await prisma.claim.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClaimUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimUpdateArgs<ExtArgs>>
    ): Prisma__ClaimClient<$Types.GetResult<ClaimPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Claims.
     * @param {ClaimDeleteManyArgs} args - Arguments to filter Claims to delete.
     * @example
     * // Delete a few Claims
     * const { count } = await prisma.claim.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClaimDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Claims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Claims
     * const claim = await prisma.claim.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClaimUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Claim.
     * @param {ClaimUpsertArgs} args - Arguments to update or create a Claim.
     * @example
     * // Update or create a Claim
     * const claim = await prisma.claim.upsert({
     *   create: {
     *     // ... data to create a Claim
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Claim we want to update
     *   }
     * })
    **/
    upsert<T extends ClaimUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimUpsertArgs<ExtArgs>>
    ): Prisma__ClaimClient<$Types.GetResult<ClaimPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Claims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimCountArgs} args - Arguments to filter Claims to count.
     * @example
     * // Count the number of Claims
     * const count = await prisma.claim.count({
     *   where: {
     *     // ... the filter for the Claims we want to count
     *   }
     * })
    **/
    count<T extends ClaimCountArgs>(
      args?: Subset<T, ClaimCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClaimCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Claim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClaimAggregateArgs>(args: Subset<T, ClaimAggregateArgs>): Prisma.PrismaPromise<GetClaimAggregateType<T>>

    /**
     * Group by Claim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClaimGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClaimGroupByArgs['orderBy'] }
        : { orderBy?: ClaimGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClaimGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClaimGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Claim.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ClaimClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Claim base type for findUnique actions
   */
  export type ClaimFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Filter, which Claim to fetch.
     */
    where: ClaimWhereUniqueInput
  }

  /**
   * Claim findUnique
   */
  export interface ClaimFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ClaimFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Claim findUniqueOrThrow
   */
  export type ClaimFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Filter, which Claim to fetch.
     */
    where: ClaimWhereUniqueInput
  }


  /**
   * Claim base type for findFirst actions
   */
  export type ClaimFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Filter, which Claim to fetch.
     */
    where?: ClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claims to fetch.
     */
    orderBy?: Enumerable<ClaimOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Claims.
     */
    cursor?: ClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Claims.
     */
    distinct?: Enumerable<ClaimScalarFieldEnum>
  }

  /**
   * Claim findFirst
   */
  export interface ClaimFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ClaimFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Claim findFirstOrThrow
   */
  export type ClaimFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Filter, which Claim to fetch.
     */
    where?: ClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claims to fetch.
     */
    orderBy?: Enumerable<ClaimOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Claims.
     */
    cursor?: ClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Claims.
     */
    distinct?: Enumerable<ClaimScalarFieldEnum>
  }


  /**
   * Claim findMany
   */
  export type ClaimFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Filter, which Claims to fetch.
     */
    where?: ClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claims to fetch.
     */
    orderBy?: Enumerable<ClaimOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Claims.
     */
    cursor?: ClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claims.
     */
    skip?: number
    distinct?: Enumerable<ClaimScalarFieldEnum>
  }


  /**
   * Claim create
   */
  export type ClaimCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * The data needed to create a Claim.
     */
    data: XOR<ClaimCreateInput, ClaimUncheckedCreateInput>
  }


  /**
   * Claim createMany
   */
  export type ClaimCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Claims.
     */
    data: Enumerable<ClaimCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Claim update
   */
  export type ClaimUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * The data needed to update a Claim.
     */
    data: XOR<ClaimUpdateInput, ClaimUncheckedUpdateInput>
    /**
     * Choose, which Claim to update.
     */
    where: ClaimWhereUniqueInput
  }


  /**
   * Claim updateMany
   */
  export type ClaimUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Claims.
     */
    data: XOR<ClaimUpdateManyMutationInput, ClaimUncheckedUpdateManyInput>
    /**
     * Filter which Claims to update
     */
    where?: ClaimWhereInput
  }


  /**
   * Claim upsert
   */
  export type ClaimUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * The filter to search for the Claim to update in case it exists.
     */
    where: ClaimWhereUniqueInput
    /**
     * In case the Claim found by the `where` argument doesn't exist, create a new Claim with this data.
     */
    create: XOR<ClaimCreateInput, ClaimUncheckedCreateInput>
    /**
     * In case the Claim was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClaimUpdateInput, ClaimUncheckedUpdateInput>
  }


  /**
   * Claim delete
   */
  export type ClaimDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Filter which Claim to delete.
     */
    where: ClaimWhereUniqueInput
  }


  /**
   * Claim deleteMany
   */
  export type ClaimDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Claims to delete
     */
    where?: ClaimWhereInput
  }


  /**
   * Claim without action
   */
  export type ClaimArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
  }



  /**
   * Model Team
   */


  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    productId: string | null
  }

  export type TeamMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    productId: string | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    userId: number
    createdAt: number
    updatedAt: number
    productId: number
    _all: number
  }


  export type TeamMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: Enumerable<TeamOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
    orderBy?: Enumerable<TeamOrderByWithAggregationInput>
    by: TeamScalarFieldEnum[]
    having?: TeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }


  export type TeamGroupByOutputType = {
    id: string
    name: string
    slug: string
    userId: string
    createdAt: Date
    updatedAt: Date
    productId: string
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type TeamSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productId?: boolean
    product?: boolean | ProductArgs<ExtArgs>
    invitation?: boolean | Team$invitationArgs<ExtArgs>
    teamMember?: boolean | Team$teamMemberArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productId?: boolean
  }

  export type TeamInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    product?: boolean | ProductArgs<ExtArgs>
    invitation?: boolean | Team$invitationArgs<ExtArgs>
    teamMember?: boolean | Team$teamMemberArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeArgs<ExtArgs>
  }


  type TeamGetPayload<S extends boolean | null | undefined | TeamArgs> = $Types.GetResult<TeamPayload, S>

  type TeamCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<TeamFindManyArgs, 'select' | 'include'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface TeamDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Team'], meta: { name: 'Team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TeamFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Team'> extends True ? Prisma__TeamClient<$Types.GetResult<TeamPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__TeamClient<$Types.GetResult<TeamPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Team that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TeamClient<$Types.GetResult<TeamPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TeamFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Team'> extends True ? Prisma__TeamClient<$Types.GetResult<TeamPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__TeamClient<$Types.GetResult<TeamPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Team that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TeamClient<$Types.GetResult<TeamPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TeamFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<TeamPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
    **/
    create<T extends TeamCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TeamCreateArgs<ExtArgs>>
    ): Prisma__TeamClient<$Types.GetResult<TeamPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Teams.
     *     @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     *     @example
     *     // Create many Teams
     *     const team = await prisma.team.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TeamCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
    **/
    delete<T extends TeamDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>
    ): Prisma__TeamClient<$Types.GetResult<TeamPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TeamUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>
    ): Prisma__TeamClient<$Types.GetResult<TeamPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TeamDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TeamUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
    **/
    upsert<T extends TeamUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>
    ): Prisma__TeamClient<$Types.GetResult<TeamPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TeamClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    product<T extends ProductArgs<ExtArgs> = {}>(args?: Subset<T, ProductArgs<ExtArgs>>): Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    invitation<T extends Team$invitationArgs<ExtArgs> = {}>(args?: Subset<T, Team$invitationArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<InvitationPayload<ExtArgs>, T, 'findMany', never>| Null>;

    teamMember<T extends Team$teamMemberArgs<ExtArgs> = {}>(args?: Subset<T, Team$teamMemberArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<TeamMemberPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Team base type for findUnique actions
   */
  export type TeamFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findUnique
   */
  export interface TeamFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends TeamFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }


  /**
   * Team base type for findFirst actions
   */
  export type TeamFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: Enumerable<TeamOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: Enumerable<TeamScalarFieldEnum>
  }

  /**
   * Team findFirst
   */
  export interface TeamFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends TeamFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: Enumerable<TeamOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: Enumerable<TeamScalarFieldEnum>
  }


  /**
   * Team findMany
   */
  export type TeamFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Teams to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: Enumerable<TeamOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    distinct?: Enumerable<TeamScalarFieldEnum>
  }


  /**
   * Team create
   */
  export type TeamCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>
  }


  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teams.
     */
    data: Enumerable<TeamCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Team update
   */
  export type TeamUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput
  }


  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
  }


  /**
   * Team upsert
   */
  export type TeamUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
  }


  /**
   * Team delete
   */
  export type TeamDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput
  }


  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput
  }


  /**
   * Team.invitation
   */
  export type Team$invitationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvitationInclude<ExtArgs> | null
    where?: InvitationWhereInput
    orderBy?: Enumerable<InvitationOrderByWithRelationInput>
    cursor?: InvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<InvitationScalarFieldEnum>
  }


  /**
   * Team.teamMember
   */
  export type Team$teamMemberArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamMemberInclude<ExtArgs> | null
    where?: TeamMemberWhereInput
    orderBy?: Enumerable<TeamMemberOrderByWithRelationInput>
    cursor?: TeamMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TeamMemberScalarFieldEnum>
  }


  /**
   * Team without action
   */
  export type TeamArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamInclude<ExtArgs> | null
  }



  /**
   * Model TeamMember
   */


  export type AggregateTeamMember = {
    _count: TeamMemberCountAggregateOutputType | null
    _avg: TeamMemberAvgAggregateOutputType | null
    _sum: TeamMemberSumAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  export type TeamMemberAvgAggregateOutputType = {
    launchOwnership: number | null
  }

  export type TeamMemberSumAggregateOutputType = {
    launchOwnership: number | null
  }

  export type TeamMemberMinAggregateOutputType = {
    id: string | null
    isLaunchMember: boolean | null
    isLaunchController: boolean | null
    isLaunchOwner: boolean | null
    launchOwnership: number | null
    teamId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamMemberMaxAggregateOutputType = {
    id: string | null
    isLaunchMember: boolean | null
    isLaunchController: boolean | null
    isLaunchOwner: boolean | null
    launchOwnership: number | null
    teamId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamMemberCountAggregateOutputType = {
    id: number
    isLaunchMember: number
    isLaunchController: number
    isLaunchOwner: number
    launchOwnership: number
    teamId: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeamMemberAvgAggregateInputType = {
    launchOwnership?: true
  }

  export type TeamMemberSumAggregateInputType = {
    launchOwnership?: true
  }

  export type TeamMemberMinAggregateInputType = {
    id?: true
    isLaunchMember?: true
    isLaunchController?: true
    isLaunchOwner?: true
    launchOwnership?: true
    teamId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamMemberMaxAggregateInputType = {
    id?: true
    isLaunchMember?: true
    isLaunchController?: true
    isLaunchOwner?: true
    launchOwnership?: true
    teamId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamMemberCountAggregateInputType = {
    id?: true
    isLaunchMember?: true
    isLaunchController?: true
    isLaunchOwner?: true
    launchOwnership?: true
    teamId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeamMemberAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMember to aggregate.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: Enumerable<TeamMemberOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamMembers
    **/
    _count?: true | TeamMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMemberMaxAggregateInputType
  }

  export type GetTeamMemberAggregateType<T extends TeamMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamMember[P]>
      : GetScalarType<T[P], AggregateTeamMember[P]>
  }




  export type TeamMemberGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
    orderBy?: Enumerable<TeamMemberOrderByWithAggregationInput>
    by: TeamMemberScalarFieldEnum[]
    having?: TeamMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamMemberCountAggregateInputType | true
    _avg?: TeamMemberAvgAggregateInputType
    _sum?: TeamMemberSumAggregateInputType
    _min?: TeamMemberMinAggregateInputType
    _max?: TeamMemberMaxAggregateInputType
  }


  export type TeamMemberGroupByOutputType = {
    id: string
    isLaunchMember: boolean
    isLaunchController: boolean
    isLaunchOwner: boolean
    launchOwnership: number
    teamId: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: TeamMemberCountAggregateOutputType | null
    _avg: TeamMemberAvgAggregateOutputType | null
    _sum: TeamMemberSumAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  type GetTeamMemberGroupByPayload<T extends TeamMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TeamMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
            : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
        }
      >
    >


  export type TeamMemberSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isLaunchMember?: boolean
    isLaunchController?: boolean
    isLaunchOwner?: boolean
    launchOwnership?: boolean
    teamId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | TeamArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["teamMember"]>

  export type TeamMemberSelectScalar = {
    id?: boolean
    isLaunchMember?: boolean
    isLaunchController?: boolean
    isLaunchOwner?: boolean
    launchOwnership?: boolean
    teamId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeamMemberInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    team?: boolean | TeamArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
  }


  type TeamMemberGetPayload<S extends boolean | null | undefined | TeamMemberArgs> = $Types.GetResult<TeamMemberPayload, S>

  type TeamMemberCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<TeamMemberFindManyArgs, 'select' | 'include'> & {
      select?: TeamMemberCountAggregateInputType | true
    }

  export interface TeamMemberDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamMember'], meta: { name: 'TeamMember' } }
    /**
     * Find zero or one TeamMember that matches the filter.
     * @param {TeamMemberFindUniqueArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TeamMemberFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TeamMemberFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TeamMember'> extends True ? Prisma__TeamMemberClient<$Types.GetResult<TeamMemberPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__TeamMemberClient<$Types.GetResult<TeamMemberPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one TeamMember that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TeamMemberFindUniqueOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TeamMemberFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TeamMemberFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TeamMemberClient<$Types.GetResult<TeamMemberPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first TeamMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TeamMemberFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TeamMemberFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TeamMember'> extends True ? Prisma__TeamMemberClient<$Types.GetResult<TeamMemberPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__TeamMemberClient<$Types.GetResult<TeamMemberPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first TeamMember that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TeamMemberFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TeamMemberFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TeamMemberClient<$Types.GetResult<TeamMemberPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more TeamMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamMembers
     * const teamMembers = await prisma.teamMember.findMany()
     * 
     * // Get first 10 TeamMembers
     * const teamMembers = await prisma.teamMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TeamMemberFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TeamMemberFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<TeamMemberPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a TeamMember.
     * @param {TeamMemberCreateArgs} args - Arguments to create a TeamMember.
     * @example
     * // Create one TeamMember
     * const TeamMember = await prisma.teamMember.create({
     *   data: {
     *     // ... data to create a TeamMember
     *   }
     * })
     * 
    **/
    create<T extends TeamMemberCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TeamMemberCreateArgs<ExtArgs>>
    ): Prisma__TeamMemberClient<$Types.GetResult<TeamMemberPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many TeamMembers.
     *     @param {TeamMemberCreateManyArgs} args - Arguments to create many TeamMembers.
     *     @example
     *     // Create many TeamMembers
     *     const teamMember = await prisma.teamMember.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TeamMemberCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TeamMemberCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TeamMember.
     * @param {TeamMemberDeleteArgs} args - Arguments to delete one TeamMember.
     * @example
     * // Delete one TeamMember
     * const TeamMember = await prisma.teamMember.delete({
     *   where: {
     *     // ... filter to delete one TeamMember
     *   }
     * })
     * 
    **/
    delete<T extends TeamMemberDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TeamMemberDeleteArgs<ExtArgs>>
    ): Prisma__TeamMemberClient<$Types.GetResult<TeamMemberPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one TeamMember.
     * @param {TeamMemberUpdateArgs} args - Arguments to update one TeamMember.
     * @example
     * // Update one TeamMember
     * const teamMember = await prisma.teamMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TeamMemberUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TeamMemberUpdateArgs<ExtArgs>>
    ): Prisma__TeamMemberClient<$Types.GetResult<TeamMemberPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more TeamMembers.
     * @param {TeamMemberDeleteManyArgs} args - Arguments to filter TeamMembers to delete.
     * @example
     * // Delete a few TeamMembers
     * const { count } = await prisma.teamMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TeamMemberDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TeamMemberDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamMembers
     * const teamMember = await prisma.teamMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TeamMemberUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TeamMemberUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TeamMember.
     * @param {TeamMemberUpsertArgs} args - Arguments to update or create a TeamMember.
     * @example
     * // Update or create a TeamMember
     * const teamMember = await prisma.teamMember.upsert({
     *   create: {
     *     // ... data to create a TeamMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamMember we want to update
     *   }
     * })
    **/
    upsert<T extends TeamMemberUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TeamMemberUpsertArgs<ExtArgs>>
    ): Prisma__TeamMemberClient<$Types.GetResult<TeamMemberPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberCountArgs} args - Arguments to filter TeamMembers to count.
     * @example
     * // Count the number of TeamMembers
     * const count = await prisma.teamMember.count({
     *   where: {
     *     // ... the filter for the TeamMembers we want to count
     *   }
     * })
    **/
    count<T extends TeamMemberCountArgs>(
      args?: Subset<T, TeamMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamMemberAggregateArgs>(args: Subset<T, TeamMemberAggregateArgs>): Prisma.PrismaPromise<GetTeamMemberAggregateType<T>>

    /**
     * Group by TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamMemberGroupByArgs['orderBy'] }
        : { orderBy?: TeamMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TeamMemberClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    team<T extends TeamArgs<ExtArgs> = {}>(args?: Subset<T, TeamArgs<ExtArgs>>): Prisma__TeamClient<$Types.GetResult<TeamPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TeamMember base type for findUnique actions
   */
  export type TeamMemberFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findUnique
   */
  export interface TeamMemberFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends TeamMemberFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TeamMember findUniqueOrThrow
   */
  export type TeamMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }


  /**
   * TeamMember base type for findFirst actions
   */
  export type TeamMemberFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: Enumerable<TeamMemberOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: Enumerable<TeamMemberScalarFieldEnum>
  }

  /**
   * TeamMember findFirst
   */
  export interface TeamMemberFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends TeamMemberFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TeamMember findFirstOrThrow
   */
  export type TeamMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: Enumerable<TeamMemberOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: Enumerable<TeamMemberScalarFieldEnum>
  }


  /**
   * TeamMember findMany
   */
  export type TeamMemberFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMembers to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: Enumerable<TeamMemberOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    distinct?: Enumerable<TeamMemberScalarFieldEnum>
  }


  /**
   * TeamMember create
   */
  export type TeamMemberCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamMember.
     */
    data: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
  }


  /**
   * TeamMember createMany
   */
  export type TeamMemberCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamMembers.
     */
    data: Enumerable<TeamMemberCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TeamMember update
   */
  export type TeamMemberUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamMember.
     */
    data: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
    /**
     * Choose, which TeamMember to update.
     */
    where: TeamMemberWhereUniqueInput
  }


  /**
   * TeamMember updateMany
   */
  export type TeamMemberUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamMembers.
     */
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyInput>
    /**
     * Filter which TeamMembers to update
     */
    where?: TeamMemberWhereInput
  }


  /**
   * TeamMember upsert
   */
  export type TeamMemberUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamMember to update in case it exists.
     */
    where: TeamMemberWhereUniqueInput
    /**
     * In case the TeamMember found by the `where` argument doesn't exist, create a new TeamMember with this data.
     */
    create: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
    /**
     * In case the TeamMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
  }


  /**
   * TeamMember delete
   */
  export type TeamMemberDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter which TeamMember to delete.
     */
    where: TeamMemberWhereUniqueInput
  }


  /**
   * TeamMember deleteMany
   */
  export type TeamMemberDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMembers to delete
     */
    where?: TeamMemberWhereInput
  }


  /**
   * TeamMember without action
   */
  export type TeamMemberArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamMemberInclude<ExtArgs> | null
  }



  /**
   * Model Invitation
   */


  export type AggregateInvitation = {
    _count: InvitationCountAggregateOutputType | null
    _min: InvitationMinAggregateOutputType | null
    _max: InvitationMaxAggregateOutputType | null
  }

  export type InvitationMinAggregateOutputType = {
    id: string | null
    teamId: string | null
    email: string | null
    token: string | null
    expireIn: Date | null
    invitedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvitationMaxAggregateOutputType = {
    id: string | null
    teamId: string | null
    email: string | null
    token: string | null
    expireIn: Date | null
    invitedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvitationCountAggregateOutputType = {
    id: number
    teamId: number
    email: number
    token: number
    expireIn: number
    invitedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvitationMinAggregateInputType = {
    id?: true
    teamId?: true
    email?: true
    token?: true
    expireIn?: true
    invitedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvitationMaxAggregateInputType = {
    id?: true
    teamId?: true
    email?: true
    token?: true
    expireIn?: true
    invitedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvitationCountAggregateInputType = {
    id?: true
    teamId?: true
    email?: true
    token?: true
    expireIn?: true
    invitedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvitationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invitation to aggregate.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: Enumerable<InvitationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invitations
    **/
    _count?: true | InvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvitationMaxAggregateInputType
  }

  export type GetInvitationAggregateType<T extends InvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvitation[P]>
      : GetScalarType<T[P], AggregateInvitation[P]>
  }




  export type InvitationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: InvitationWhereInput
    orderBy?: Enumerable<InvitationOrderByWithAggregationInput>
    by: InvitationScalarFieldEnum[]
    having?: InvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvitationCountAggregateInputType | true
    _min?: InvitationMinAggregateInputType
    _max?: InvitationMaxAggregateInputType
  }


  export type InvitationGroupByOutputType = {
    id: string
    teamId: string
    email: string
    token: string
    expireIn: Date
    invitedBy: string
    createdAt: Date
    updatedAt: Date
    _count: InvitationCountAggregateOutputType | null
    _min: InvitationMinAggregateOutputType | null
    _max: InvitationMaxAggregateOutputType | null
  }

  type GetInvitationGroupByPayload<T extends InvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<InvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvitationGroupByOutputType[P]>
            : GetScalarType<T[P], InvitationGroupByOutputType[P]>
        }
      >
    >


  export type InvitationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    email?: boolean
    token?: boolean
    expireIn?: boolean
    invitedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | TeamArgs<ExtArgs>
  }, ExtArgs["result"]["invitation"]>

  export type InvitationSelectScalar = {
    id?: boolean
    teamId?: boolean
    email?: boolean
    token?: boolean
    expireIn?: boolean
    invitedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvitationInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    team?: boolean | TeamArgs<ExtArgs>
  }


  type InvitationGetPayload<S extends boolean | null | undefined | InvitationArgs> = $Types.GetResult<InvitationPayload, S>

  type InvitationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<InvitationFindManyArgs, 'select' | 'include'> & {
      select?: InvitationCountAggregateInputType | true
    }

  export interface InvitationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invitation'], meta: { name: 'Invitation' } }
    /**
     * Find zero or one Invitation that matches the filter.
     * @param {InvitationFindUniqueArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InvitationFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, InvitationFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Invitation'> extends True ? Prisma__InvitationClient<$Types.GetResult<InvitationPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__InvitationClient<$Types.GetResult<InvitationPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Invitation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InvitationFindUniqueOrThrowArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InvitationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InvitationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InvitationClient<$Types.GetResult<InvitationPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Invitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindFirstArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InvitationFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, InvitationFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Invitation'> extends True ? Prisma__InvitationClient<$Types.GetResult<InvitationPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__InvitationClient<$Types.GetResult<InvitationPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Invitation that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindFirstOrThrowArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InvitationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InvitationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InvitationClient<$Types.GetResult<InvitationPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Invitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invitations
     * const invitations = await prisma.invitation.findMany()
     * 
     * // Get first 10 Invitations
     * const invitations = await prisma.invitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invitationWithIdOnly = await prisma.invitation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InvitationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InvitationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<InvitationPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Invitation.
     * @param {InvitationCreateArgs} args - Arguments to create a Invitation.
     * @example
     * // Create one Invitation
     * const Invitation = await prisma.invitation.create({
     *   data: {
     *     // ... data to create a Invitation
     *   }
     * })
     * 
    **/
    create<T extends InvitationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InvitationCreateArgs<ExtArgs>>
    ): Prisma__InvitationClient<$Types.GetResult<InvitationPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Invitations.
     *     @param {InvitationCreateManyArgs} args - Arguments to create many Invitations.
     *     @example
     *     // Create many Invitations
     *     const invitation = await prisma.invitation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InvitationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InvitationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Invitation.
     * @param {InvitationDeleteArgs} args - Arguments to delete one Invitation.
     * @example
     * // Delete one Invitation
     * const Invitation = await prisma.invitation.delete({
     *   where: {
     *     // ... filter to delete one Invitation
     *   }
     * })
     * 
    **/
    delete<T extends InvitationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InvitationDeleteArgs<ExtArgs>>
    ): Prisma__InvitationClient<$Types.GetResult<InvitationPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Invitation.
     * @param {InvitationUpdateArgs} args - Arguments to update one Invitation.
     * @example
     * // Update one Invitation
     * const invitation = await prisma.invitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InvitationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InvitationUpdateArgs<ExtArgs>>
    ): Prisma__InvitationClient<$Types.GetResult<InvitationPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Invitations.
     * @param {InvitationDeleteManyArgs} args - Arguments to filter Invitations to delete.
     * @example
     * // Delete a few Invitations
     * const { count } = await prisma.invitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InvitationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InvitationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invitations
     * const invitation = await prisma.invitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InvitationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InvitationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invitation.
     * @param {InvitationUpsertArgs} args - Arguments to update or create a Invitation.
     * @example
     * // Update or create a Invitation
     * const invitation = await prisma.invitation.upsert({
     *   create: {
     *     // ... data to create a Invitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invitation we want to update
     *   }
     * })
    **/
    upsert<T extends InvitationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InvitationUpsertArgs<ExtArgs>>
    ): Prisma__InvitationClient<$Types.GetResult<InvitationPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationCountArgs} args - Arguments to filter Invitations to count.
     * @example
     * // Count the number of Invitations
     * const count = await prisma.invitation.count({
     *   where: {
     *     // ... the filter for the Invitations we want to count
     *   }
     * })
    **/
    count<T extends InvitationCountArgs>(
      args?: Subset<T, InvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvitationAggregateArgs>(args: Subset<T, InvitationAggregateArgs>): Prisma.PrismaPromise<GetInvitationAggregateType<T>>

    /**
     * Group by Invitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvitationGroupByArgs['orderBy'] }
        : { orderBy?: InvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Invitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__InvitationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    team<T extends TeamArgs<ExtArgs> = {}>(args?: Subset<T, TeamArgs<ExtArgs>>): Prisma__TeamClient<$Types.GetResult<TeamPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Invitation base type for findUnique actions
   */
  export type InvitationFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation findUnique
   */
  export interface InvitationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends InvitationFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Invitation findUniqueOrThrow
   */
  export type InvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where: InvitationWhereUniqueInput
  }


  /**
   * Invitation base type for findFirst actions
   */
  export type InvitationFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: Enumerable<InvitationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invitations.
     */
    distinct?: Enumerable<InvitationScalarFieldEnum>
  }

  /**
   * Invitation findFirst
   */
  export interface InvitationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends InvitationFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Invitation findFirstOrThrow
   */
  export type InvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: Enumerable<InvitationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invitations.
     */
    distinct?: Enumerable<InvitationScalarFieldEnum>
  }


  /**
   * Invitation findMany
   */
  export type InvitationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitations to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: Enumerable<InvitationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    distinct?: Enumerable<InvitationScalarFieldEnum>
  }


  /**
   * Invitation create
   */
  export type InvitationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a Invitation.
     */
    data: XOR<InvitationCreateInput, InvitationUncheckedCreateInput>
  }


  /**
   * Invitation createMany
   */
  export type InvitationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invitations.
     */
    data: Enumerable<InvitationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Invitation update
   */
  export type InvitationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a Invitation.
     */
    data: XOR<InvitationUpdateInput, InvitationUncheckedUpdateInput>
    /**
     * Choose, which Invitation to update.
     */
    where: InvitationWhereUniqueInput
  }


  /**
   * Invitation updateMany
   */
  export type InvitationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invitations.
     */
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyInput>
    /**
     * Filter which Invitations to update
     */
    where?: InvitationWhereInput
  }


  /**
   * Invitation upsert
   */
  export type InvitationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the Invitation to update in case it exists.
     */
    where: InvitationWhereUniqueInput
    /**
     * In case the Invitation found by the `where` argument doesn't exist, create a new Invitation with this data.
     */
    create: XOR<InvitationCreateInput, InvitationUncheckedCreateInput>
    /**
     * In case the Invitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvitationUpdateInput, InvitationUncheckedUpdateInput>
  }


  /**
   * Invitation delete
   */
  export type InvitationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter which Invitation to delete.
     */
    where: InvitationWhereUniqueInput
  }


  /**
   * Invitation deleteMany
   */
  export type InvitationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invitations to delete
     */
    where?: InvitationWhereInput
  }


  /**
   * Invitation without action
   */
  export type InvitationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvitationInclude<ExtArgs> | null
  }



  /**
   * Model Payment
   */


  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    provider: string | null
    transactionId: string | null
    status: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
    productId: string | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    provider: string | null
    transactionId: string | null
    status: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
    productId: string | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    provider: number
    transactionId: number
    status: number
    email: number
    createdAt: number
    updatedAt: number
    productId: number
    _all: number
  }


  export type PaymentMinAggregateInputType = {
    id?: true
    provider?: true
    transactionId?: true
    status?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    provider?: true
    transactionId?: true
    status?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    provider?: true
    transactionId?: true
    status?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: Enumerable<PaymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: Enumerable<PaymentOrderByWithAggregationInput>
    by: PaymentScalarFieldEnum[]
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }


  export type PaymentGroupByOutputType = {
    id: string
    provider: string
    transactionId: string
    status: string
    email: string
    createdAt: Date
    updatedAt: Date
    productId: string
    _count: PaymentCountAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    transactionId?: boolean
    status?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productId?: boolean
    products?: boolean | ProductArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    provider?: boolean
    transactionId?: boolean
    status?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productId?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    products?: boolean | ProductArgs<ExtArgs>
  }


  type PaymentGetPayload<S extends boolean | null | undefined | PaymentArgs> = $Types.GetResult<PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PaymentFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Payment'> extends True ? Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PaymentFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Payment'> extends True ? Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PaymentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
    **/
    create<T extends PaymentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Payments.
     *     @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     *     @example
     *     // Create many Payments
     *     const payment = await prisma.payment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PaymentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
    **/
    delete<T extends PaymentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PaymentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PaymentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PaymentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
    **/
    upsert<T extends PaymentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    products<T extends ProductArgs<ExtArgs> = {}>(args?: Subset<T, ProductArgs<ExtArgs>>): Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Payment base type for findUnique actions
   */
  export type PaymentFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUnique
   */
  export interface PaymentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PaymentFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }


  /**
   * Payment base type for findFirst actions
   */
  export type PaymentFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: Enumerable<PaymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }

  /**
   * Payment findFirst
   */
  export interface PaymentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PaymentFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: Enumerable<PaymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }


  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: Enumerable<PaymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }


  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }


  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: Enumerable<PaymentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }


  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }


  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }


  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }


  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }


  /**
   * Payment without action
   */
  export type PaymentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
  }



  /**
   * Model Parter
   */


  export type AggregateParter = {
    _count: ParterCountAggregateOutputType | null
    _avg: ParterAvgAggregateOutputType | null
    _sum: ParterSumAggregateOutputType | null
    _min: ParterMinAggregateOutputType | null
    _max: ParterMaxAggregateOutputType | null
  }

  export type ParterAvgAggregateOutputType = {
    serviceScore: number | null
    paymentsMade: number | null
    paymentsDue: number | null
  }

  export type ParterSumAggregateOutputType = {
    serviceScore: number | null
    paymentsMade: number | null
    paymentsDue: number | null
  }

  export type ParterMinAggregateOutputType = {
    id: string | null
    isVerified: boolean | null
    serviceScore: number | null
    paymentsMade: number | null
    paymentsDue: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParterMaxAggregateOutputType = {
    id: string | null
    isVerified: boolean | null
    serviceScore: number | null
    paymentsMade: number | null
    paymentsDue: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParterCountAggregateOutputType = {
    id: number
    isVerified: number
    verificationDocument: number
    serviceScore: number
    paymentsMade: number
    paymentsDue: number
    paymentDetails: number
    countrySupported: number
    serviceSupported: number
    servicesAssigned: number
    servicesCompleted: number
    servicesDeclined: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ParterAvgAggregateInputType = {
    serviceScore?: true
    paymentsMade?: true
    paymentsDue?: true
  }

  export type ParterSumAggregateInputType = {
    serviceScore?: true
    paymentsMade?: true
    paymentsDue?: true
  }

  export type ParterMinAggregateInputType = {
    id?: true
    isVerified?: true
    serviceScore?: true
    paymentsMade?: true
    paymentsDue?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParterMaxAggregateInputType = {
    id?: true
    isVerified?: true
    serviceScore?: true
    paymentsMade?: true
    paymentsDue?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParterCountAggregateInputType = {
    id?: true
    isVerified?: true
    verificationDocument?: true
    serviceScore?: true
    paymentsMade?: true
    paymentsDue?: true
    paymentDetails?: true
    countrySupported?: true
    serviceSupported?: true
    servicesAssigned?: true
    servicesCompleted?: true
    servicesDeclined?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ParterAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parter to aggregate.
     */
    where?: ParterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parters to fetch.
     */
    orderBy?: Enumerable<ParterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Parters
    **/
    _count?: true | ParterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParterMaxAggregateInputType
  }

  export type GetParterAggregateType<T extends ParterAggregateArgs> = {
        [P in keyof T & keyof AggregateParter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParter[P]>
      : GetScalarType<T[P], AggregateParter[P]>
  }




  export type ParterGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ParterWhereInput
    orderBy?: Enumerable<ParterOrderByWithAggregationInput>
    by: ParterScalarFieldEnum[]
    having?: ParterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParterCountAggregateInputType | true
    _avg?: ParterAvgAggregateInputType
    _sum?: ParterSumAggregateInputType
    _min?: ParterMinAggregateInputType
    _max?: ParterMaxAggregateInputType
  }


  export type ParterGroupByOutputType = {
    id: string
    isVerified: boolean
    verificationDocument: string[]
    serviceScore: number
    paymentsMade: number
    paymentsDue: number
    paymentDetails: string[]
    countrySupported: string[]
    serviceSupported: string[]
    servicesAssigned: string[]
    servicesCompleted: string[]
    servicesDeclined: string[]
    createdAt: Date
    updatedAt: Date
    _count: ParterCountAggregateOutputType | null
    _avg: ParterAvgAggregateOutputType | null
    _sum: ParterSumAggregateOutputType | null
    _min: ParterMinAggregateOutputType | null
    _max: ParterMaxAggregateOutputType | null
  }

  type GetParterGroupByPayload<T extends ParterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ParterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParterGroupByOutputType[P]>
            : GetScalarType<T[P], ParterGroupByOutputType[P]>
        }
      >
    >


  export type ParterSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isVerified?: boolean
    verificationDocument?: boolean
    serviceScore?: boolean
    paymentsMade?: boolean
    paymentsDue?: boolean
    paymentDetails?: boolean
    countrySupported?: boolean
    serviceSupported?: boolean
    servicesAssigned?: boolean
    servicesCompleted?: boolean
    servicesDeclined?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["parter"]>

  export type ParterSelectScalar = {
    id?: boolean
    isVerified?: boolean
    verificationDocument?: boolean
    serviceScore?: boolean
    paymentsMade?: boolean
    paymentsDue?: boolean
    paymentDetails?: boolean
    countrySupported?: boolean
    serviceSupported?: boolean
    servicesAssigned?: boolean
    servicesCompleted?: boolean
    servicesDeclined?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  type ParterGetPayload<S extends boolean | null | undefined | ParterArgs> = $Types.GetResult<ParterPayload, S>

  type ParterCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ParterFindManyArgs, 'select' | 'include'> & {
      select?: ParterCountAggregateInputType | true
    }

  export interface ParterDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Parter'], meta: { name: 'Parter' } }
    /**
     * Find zero or one Parter that matches the filter.
     * @param {ParterFindUniqueArgs} args - Arguments to find a Parter
     * @example
     * // Get one Parter
     * const parter = await prisma.parter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ParterFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ParterFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Parter'> extends True ? Prisma__ParterClient<$Types.GetResult<ParterPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ParterClient<$Types.GetResult<ParterPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Parter that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ParterFindUniqueOrThrowArgs} args - Arguments to find a Parter
     * @example
     * // Get one Parter
     * const parter = await prisma.parter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ParterFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ParterFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ParterClient<$Types.GetResult<ParterPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Parter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParterFindFirstArgs} args - Arguments to find a Parter
     * @example
     * // Get one Parter
     * const parter = await prisma.parter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ParterFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ParterFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Parter'> extends True ? Prisma__ParterClient<$Types.GetResult<ParterPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ParterClient<$Types.GetResult<ParterPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Parter that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParterFindFirstOrThrowArgs} args - Arguments to find a Parter
     * @example
     * // Get one Parter
     * const parter = await prisma.parter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ParterFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ParterFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ParterClient<$Types.GetResult<ParterPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Parters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParterFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parters
     * const parters = await prisma.parter.findMany()
     * 
     * // Get first 10 Parters
     * const parters = await prisma.parter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parterWithIdOnly = await prisma.parter.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ParterFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ParterFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ParterPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Parter.
     * @param {ParterCreateArgs} args - Arguments to create a Parter.
     * @example
     * // Create one Parter
     * const Parter = await prisma.parter.create({
     *   data: {
     *     // ... data to create a Parter
     *   }
     * })
     * 
    **/
    create<T extends ParterCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ParterCreateArgs<ExtArgs>>
    ): Prisma__ParterClient<$Types.GetResult<ParterPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Parters.
     *     @param {ParterCreateManyArgs} args - Arguments to create many Parters.
     *     @example
     *     // Create many Parters
     *     const parter = await prisma.parter.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ParterCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ParterCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Parter.
     * @param {ParterDeleteArgs} args - Arguments to delete one Parter.
     * @example
     * // Delete one Parter
     * const Parter = await prisma.parter.delete({
     *   where: {
     *     // ... filter to delete one Parter
     *   }
     * })
     * 
    **/
    delete<T extends ParterDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ParterDeleteArgs<ExtArgs>>
    ): Prisma__ParterClient<$Types.GetResult<ParterPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Parter.
     * @param {ParterUpdateArgs} args - Arguments to update one Parter.
     * @example
     * // Update one Parter
     * const parter = await prisma.parter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ParterUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ParterUpdateArgs<ExtArgs>>
    ): Prisma__ParterClient<$Types.GetResult<ParterPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Parters.
     * @param {ParterDeleteManyArgs} args - Arguments to filter Parters to delete.
     * @example
     * // Delete a few Parters
     * const { count } = await prisma.parter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ParterDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ParterDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parters
     * const parter = await prisma.parter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ParterUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ParterUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Parter.
     * @param {ParterUpsertArgs} args - Arguments to update or create a Parter.
     * @example
     * // Update or create a Parter
     * const parter = await prisma.parter.upsert({
     *   create: {
     *     // ... data to create a Parter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parter we want to update
     *   }
     * })
    **/
    upsert<T extends ParterUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ParterUpsertArgs<ExtArgs>>
    ): Prisma__ParterClient<$Types.GetResult<ParterPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Parters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParterCountArgs} args - Arguments to filter Parters to count.
     * @example
     * // Count the number of Parters
     * const count = await prisma.parter.count({
     *   where: {
     *     // ... the filter for the Parters we want to count
     *   }
     * })
    **/
    count<T extends ParterCountArgs>(
      args?: Subset<T, ParterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParterAggregateArgs>(args: Subset<T, ParterAggregateArgs>): Prisma.PrismaPromise<GetParterAggregateType<T>>

    /**
     * Group by Parter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParterGroupByArgs['orderBy'] }
        : { orderBy?: ParterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Parter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ParterClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Parter base type for findUnique actions
   */
  export type ParterFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parter
     */
    select?: ParterSelect<ExtArgs> | null
    /**
     * Filter, which Parter to fetch.
     */
    where: ParterWhereUniqueInput
  }

  /**
   * Parter findUnique
   */
  export interface ParterFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ParterFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Parter findUniqueOrThrow
   */
  export type ParterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parter
     */
    select?: ParterSelect<ExtArgs> | null
    /**
     * Filter, which Parter to fetch.
     */
    where: ParterWhereUniqueInput
  }


  /**
   * Parter base type for findFirst actions
   */
  export type ParterFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parter
     */
    select?: ParterSelect<ExtArgs> | null
    /**
     * Filter, which Parter to fetch.
     */
    where?: ParterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parters to fetch.
     */
    orderBy?: Enumerable<ParterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parters.
     */
    cursor?: ParterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parters.
     */
    distinct?: Enumerable<ParterScalarFieldEnum>
  }

  /**
   * Parter findFirst
   */
  export interface ParterFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ParterFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Parter findFirstOrThrow
   */
  export type ParterFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parter
     */
    select?: ParterSelect<ExtArgs> | null
    /**
     * Filter, which Parter to fetch.
     */
    where?: ParterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parters to fetch.
     */
    orderBy?: Enumerable<ParterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parters.
     */
    cursor?: ParterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parters.
     */
    distinct?: Enumerable<ParterScalarFieldEnum>
  }


  /**
   * Parter findMany
   */
  export type ParterFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parter
     */
    select?: ParterSelect<ExtArgs> | null
    /**
     * Filter, which Parters to fetch.
     */
    where?: ParterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parters to fetch.
     */
    orderBy?: Enumerable<ParterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Parters.
     */
    cursor?: ParterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parters.
     */
    skip?: number
    distinct?: Enumerable<ParterScalarFieldEnum>
  }


  /**
   * Parter create
   */
  export type ParterCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parter
     */
    select?: ParterSelect<ExtArgs> | null
    /**
     * The data needed to create a Parter.
     */
    data: XOR<ParterCreateInput, ParterUncheckedCreateInput>
  }


  /**
   * Parter createMany
   */
  export type ParterCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Parters.
     */
    data: Enumerable<ParterCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Parter update
   */
  export type ParterUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parter
     */
    select?: ParterSelect<ExtArgs> | null
    /**
     * The data needed to update a Parter.
     */
    data: XOR<ParterUpdateInput, ParterUncheckedUpdateInput>
    /**
     * Choose, which Parter to update.
     */
    where: ParterWhereUniqueInput
  }


  /**
   * Parter updateMany
   */
  export type ParterUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Parters.
     */
    data: XOR<ParterUpdateManyMutationInput, ParterUncheckedUpdateManyInput>
    /**
     * Filter which Parters to update
     */
    where?: ParterWhereInput
  }


  /**
   * Parter upsert
   */
  export type ParterUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parter
     */
    select?: ParterSelect<ExtArgs> | null
    /**
     * The filter to search for the Parter to update in case it exists.
     */
    where: ParterWhereUniqueInput
    /**
     * In case the Parter found by the `where` argument doesn't exist, create a new Parter with this data.
     */
    create: XOR<ParterCreateInput, ParterUncheckedCreateInput>
    /**
     * In case the Parter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParterUpdateInput, ParterUncheckedUpdateInput>
  }


  /**
   * Parter delete
   */
  export type ParterDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parter
     */
    select?: ParterSelect<ExtArgs> | null
    /**
     * Filter which Parter to delete.
     */
    where: ParterWhereUniqueInput
  }


  /**
   * Parter deleteMany
   */
  export type ParterDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parters to delete
     */
    where?: ParterWhereInput
  }


  /**
   * Parter without action
   */
  export type ParterArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parter
     */
    select?: ParterSelect<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const StaffScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    password: 'password',
    phone: 'phone',
    verified: 'verified',
    picture: 'picture',
    resetToken: 'resetToken',
    isDeprecated: 'isDeprecated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StaffScalarFieldEnum = (typeof StaffScalarFieldEnum)[keyof typeof StaffScalarFieldEnum]


  export const CollaboratorScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    password: 'password',
    phone: 'phone',
    picture: 'picture',
    verified: 'verified',
    isPartner: 'isPartner',
    resetToken: 'resetToken',
    isDeprecated: 'isDeprecated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CollaboratorScalarFieldEnum = (typeof CollaboratorScalarFieldEnum)[keyof typeof CollaboratorScalarFieldEnum]


  export const CollaboratorDocumentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    description: 'description',
    isDeprecated: 'isDeprecated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    collaboratorId: 'collaboratorId'
  };

  export type CollaboratorDocumentScalarFieldEnum = (typeof CollaboratorDocumentScalarFieldEnum)[keyof typeof CollaboratorDocumentScalarFieldEnum]


  export const RewardScalarFieldEnum: {
    id: 'id',
    name: 'name',
    url: 'url',
    descrition: 'descrition',
    image: 'image',
    isDeprecated: 'isDeprecated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RewardScalarFieldEnum = (typeof RewardScalarFieldEnum)[keyof typeof RewardScalarFieldEnum]


  export const CountryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    iso: 'iso',
    currency: 'currency',
    code: 'code',
    flagUrl: 'flagUrl',
    isDeprecated: 'isDeprecated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CountryScalarFieldEnum = (typeof CountryScalarFieldEnum)[keyof typeof CountryScalarFieldEnum]


  export const BankScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    url: 'url',
    image: 'image',
    isDeprecated: 'isDeprecated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BankScalarFieldEnum = (typeof BankScalarFieldEnum)[keyof typeof BankScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    body: 'body',
    readStatus: 'readStatus',
    isDeprecated: 'isDeprecated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    scope: 'scope'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    fullName: 'fullName',
    username: 'username',
    email: 'email',
    password: 'password',
    phone: 'phone',
    picture: 'picture',
    isVerified: 'isVerified',
    referral: 'referral',
    country: 'country',
    resetToken: 'resetToken',
    isPartner: 'isPartner',
    isStaff: 'isStaff',
    isPhoneRegistered: 'isPhoneRegistered',
    isPhoneVerified: 'isPhoneVerified',
    isIdentificationRegistered: 'isIdentificationRegistered',
    isIdentificationVerified: 'isIdentificationVerified',
    partnerPermission: 'partnerPermission',
    staffPermission: 'staffPermission',
    userPermission: 'userPermission',
    isDeprecated: 'isDeprecated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserDocumentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    description: 'description',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserDocumentScalarFieldEnum = (typeof UserDocumentScalarFieldEnum)[keyof typeof UserDocumentScalarFieldEnum]


  export const ServiceCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isDeprecated: 'isDeprecated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceCategoryScalarFieldEnum = (typeof ServiceCategoryScalarFieldEnum)[keyof typeof ServiceCategoryScalarFieldEnum]


  export const ServiceCategoryFormScalarFieldEnum: {
    id: 'id',
    question: 'question',
    type: 'type',
    options: 'options',
    compulsory: 'compulsory',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    serviceCategoryId: 'serviceCategoryId'
  };

  export type ServiceCategoryFormScalarFieldEnum = (typeof ServiceCategoryFormScalarFieldEnum)[keyof typeof ServiceCategoryFormScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    code: 'code',
    description: 'description',
    country: 'country',
    price: 'price',
    timeline: 'timeline',
    feature: 'feature',
    categoryForm: 'categoryForm',
    hasShares: 'hasShares',
    numberOfShares: 'numberOfShares',
    hasAgent: 'hasAgent',
    hasOwner: 'hasOwner',
    hasController: 'hasController',
    controllerIsCalled: 'controllerIsCalled',
    OwnerIsCalled: 'OwnerIsCalled',
    agentIsCalled: 'agentIsCalled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    serviceCategoryId: 'serviceCategoryId'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const ServiceTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    serviceId: 'serviceId'
  };

  export type ServiceTemplateScalarFieldEnum = (typeof ServiceTemplateScalarFieldEnum)[keyof typeof ServiceTemplateScalarFieldEnum]


  export const ServiceFormScalarFieldEnum: {
    id: 'id',
    question: 'question',
    type: 'type',
    options: 'options',
    compulsory: 'compulsory',
    fileName: 'fileName',
    fileDescription: 'fileDescription',
    fileType: 'fileType',
    fileLink: 'fileLink',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    serviceId: 'serviceId'
  };

  export type ServiceFormScalarFieldEnum = (typeof ServiceFormScalarFieldEnum)[keyof typeof ServiceFormScalarFieldEnum]


  export const ServiceSubFormScalarFieldEnum: {
    id: 'id',
    question: 'question',
    options: 'options',
    type: 'type',
    compulsory: 'compulsory',
    fileName: 'fileName',
    fileDescription: 'fileDescription',
    fileType: 'fileType',
    fileLink: 'fileLink',
    serviceFormId: 'serviceFormId'
  };

  export type ServiceSubFormScalarFieldEnum = (typeof ServiceSubFormScalarFieldEnum)[keyof typeof ServiceSubFormScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    email: 'email',
    address: 'address',
    paid: 'paid',
    completed: 'completed',
    status: 'status',
    currentState: 'currentState',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    serviceId: 'serviceId',
    userId: 'userId'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ProductQAScalarFieldEnum: {
    id: 'id',
    question: 'question',
    answer: 'answer',
    type: 'type',
    compulsory: 'compulsory',
    isGeneral: 'isGeneral',
    fileName: 'fileName',
    fileDescription: 'fileDescription',
    fileType: 'fileType',
    fileLink: 'fileLink',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    productId: 'productId'
  };

  export type ProductQAScalarFieldEnum = (typeof ProductQAScalarFieldEnum)[keyof typeof ProductQAScalarFieldEnum]


  export const ProductQASubFormScalarFieldEnum: {
    id: 'id',
    question: 'question',
    answer: 'answer',
    type: 'type',
    compulsory: 'compulsory',
    productQAId: 'productQAId'
  };

  export type ProductQASubFormScalarFieldEnum = (typeof ProductQASubFormScalarFieldEnum)[keyof typeof ProductQASubFormScalarFieldEnum]


  export const ClaimScalarFieldEnum: {
    id: 'id',
    value: 'value',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClaimScalarFieldEnum = (typeof ClaimScalarFieldEnum)[keyof typeof ClaimScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    productId: 'productId'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const TeamMemberScalarFieldEnum: {
    id: 'id',
    isLaunchMember: 'isLaunchMember',
    isLaunchController: 'isLaunchController',
    isLaunchOwner: 'isLaunchOwner',
    launchOwnership: 'launchOwnership',
    teamId: 'teamId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeamMemberScalarFieldEnum = (typeof TeamMemberScalarFieldEnum)[keyof typeof TeamMemberScalarFieldEnum]


  export const InvitationScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    email: 'email',
    token: 'token',
    expireIn: 'expireIn',
    invitedBy: 'invitedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvitationScalarFieldEnum = (typeof InvitationScalarFieldEnum)[keyof typeof InvitationScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    provider: 'provider',
    transactionId: 'transactionId',
    status: 'status',
    email: 'email',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    productId: 'productId'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const ParterScalarFieldEnum: {
    id: 'id',
    isVerified: 'isVerified',
    verificationDocument: 'verificationDocument',
    serviceScore: 'serviceScore',
    paymentsMade: 'paymentsMade',
    paymentsDue: 'paymentsDue',
    paymentDetails: 'paymentDetails',
    countrySupported: 'countrySupported',
    serviceSupported: 'serviceSupported',
    servicesAssigned: 'servicesAssigned',
    servicesCompleted: 'servicesCompleted',
    servicesDeclined: 'servicesDeclined',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ParterScalarFieldEnum = (typeof ParterScalarFieldEnum)[keyof typeof ParterScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Deep Input Types
   */


  export type StaffWhereInput = {
    AND?: Enumerable<StaffWhereInput>
    OR?: Enumerable<StaffWhereInput>
    NOT?: Enumerable<StaffWhereInput>
    id?: StringFilter | string
    firstName?: StringFilter | string
    lastName?: StringFilter | string
    email?: StringFilter | string
    password?: StringFilter | string
    phone?: StringFilter | string
    verified?: BoolFilter | boolean
    picture?: StringNullableFilter | string | null
    resetToken?: StringNullableFilter | string | null
    isDeprecated?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type StaffOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    verified?: SortOrder
    picture?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffWhereUniqueInput = {
    id?: string
    email?: string
  }

  export type StaffOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    verified?: SortOrder
    picture?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StaffCountOrderByAggregateInput
    _max?: StaffMaxOrderByAggregateInput
    _min?: StaffMinOrderByAggregateInput
  }

  export type StaffScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StaffScalarWhereWithAggregatesInput>
    OR?: Enumerable<StaffScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StaffScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    firstName?: StringWithAggregatesFilter | string
    lastName?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    phone?: StringWithAggregatesFilter | string
    verified?: BoolWithAggregatesFilter | boolean
    picture?: StringNullableWithAggregatesFilter | string | null
    resetToken?: StringNullableWithAggregatesFilter | string | null
    isDeprecated?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CollaboratorWhereInput = {
    AND?: Enumerable<CollaboratorWhereInput>
    OR?: Enumerable<CollaboratorWhereInput>
    NOT?: Enumerable<CollaboratorWhereInput>
    id?: StringFilter | string
    firstName?: StringFilter | string
    lastName?: StringFilter | string
    email?: StringFilter | string
    password?: StringFilter | string
    phone?: StringFilter | string
    picture?: StringNullableFilter | string | null
    verified?: BoolFilter | boolean
    isPartner?: BoolFilter | boolean
    resetToken?: StringNullableFilter | string | null
    isDeprecated?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    collaboratorDocument?: CollaboratorDocumentListRelationFilter
  }

  export type CollaboratorOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    picture?: SortOrderInput | SortOrder
    verified?: SortOrder
    isPartner?: SortOrder
    resetToken?: SortOrderInput | SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    collaboratorDocument?: CollaboratorDocumentOrderByRelationAggregateInput
  }

  export type CollaboratorWhereUniqueInput = {
    id?: string
    email?: string
  }

  export type CollaboratorOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    picture?: SortOrderInput | SortOrder
    verified?: SortOrder
    isPartner?: SortOrder
    resetToken?: SortOrderInput | SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CollaboratorCountOrderByAggregateInput
    _max?: CollaboratorMaxOrderByAggregateInput
    _min?: CollaboratorMinOrderByAggregateInput
  }

  export type CollaboratorScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CollaboratorScalarWhereWithAggregatesInput>
    OR?: Enumerable<CollaboratorScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CollaboratorScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    firstName?: StringWithAggregatesFilter | string
    lastName?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    phone?: StringWithAggregatesFilter | string
    picture?: StringNullableWithAggregatesFilter | string | null
    verified?: BoolWithAggregatesFilter | boolean
    isPartner?: BoolWithAggregatesFilter | boolean
    resetToken?: StringNullableWithAggregatesFilter | string | null
    isDeprecated?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CollaboratorDocumentWhereInput = {
    AND?: Enumerable<CollaboratorDocumentWhereInput>
    OR?: Enumerable<CollaboratorDocumentWhereInput>
    NOT?: Enumerable<CollaboratorDocumentWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    type?: StringFilter | string
    description?: StringFilter | string
    isDeprecated?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    collaboratorId?: StringFilter | string
    collaborator?: XOR<CollaboratorRelationFilter, CollaboratorWhereInput>
  }

  export type CollaboratorDocumentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    collaboratorId?: SortOrder
    collaborator?: CollaboratorOrderByWithRelationInput
  }

  export type CollaboratorDocumentWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type CollaboratorDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    collaboratorId?: SortOrder
    _count?: CollaboratorDocumentCountOrderByAggregateInput
    _max?: CollaboratorDocumentMaxOrderByAggregateInput
    _min?: CollaboratorDocumentMinOrderByAggregateInput
  }

  export type CollaboratorDocumentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CollaboratorDocumentScalarWhereWithAggregatesInput>
    OR?: Enumerable<CollaboratorDocumentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CollaboratorDocumentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    isDeprecated?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    collaboratorId?: StringWithAggregatesFilter | string
  }

  export type RewardWhereInput = {
    AND?: Enumerable<RewardWhereInput>
    OR?: Enumerable<RewardWhereInput>
    NOT?: Enumerable<RewardWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    url?: StringFilter | string
    descrition?: StringFilter | string
    image?: StringFilter | string
    isDeprecated?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type RewardOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    descrition?: SortOrder
    image?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RewardWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type RewardOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    descrition?: SortOrder
    image?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RewardCountOrderByAggregateInput
    _max?: RewardMaxOrderByAggregateInput
    _min?: RewardMinOrderByAggregateInput
  }

  export type RewardScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RewardScalarWhereWithAggregatesInput>
    OR?: Enumerable<RewardScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RewardScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    url?: StringWithAggregatesFilter | string
    descrition?: StringWithAggregatesFilter | string
    image?: StringWithAggregatesFilter | string
    isDeprecated?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CountryWhereInput = {
    AND?: Enumerable<CountryWhereInput>
    OR?: Enumerable<CountryWhereInput>
    NOT?: Enumerable<CountryWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    iso?: StringFilter | string
    currency?: StringFilter | string
    code?: StringFilter | string
    flagUrl?: StringFilter | string
    isDeprecated?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type CountryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    iso?: SortOrder
    currency?: SortOrder
    code?: SortOrder
    flagUrl?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CountryWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type CountryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    iso?: SortOrder
    currency?: SortOrder
    code?: SortOrder
    flagUrl?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CountryCountOrderByAggregateInput
    _max?: CountryMaxOrderByAggregateInput
    _min?: CountryMinOrderByAggregateInput
  }

  export type CountryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CountryScalarWhereWithAggregatesInput>
    OR?: Enumerable<CountryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CountryScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    iso?: StringWithAggregatesFilter | string
    currency?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    flagUrl?: StringWithAggregatesFilter | string
    isDeprecated?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type BankWhereInput = {
    AND?: Enumerable<BankWhereInput>
    OR?: Enumerable<BankWhereInput>
    NOT?: Enumerable<BankWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    code?: StringFilter | string
    url?: StringFilter | string
    image?: StringFilter | string
    isDeprecated?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type BankOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    url?: SortOrder
    image?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type BankOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    url?: SortOrder
    image?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BankCountOrderByAggregateInput
    _max?: BankMaxOrderByAggregateInput
    _min?: BankMinOrderByAggregateInput
  }

  export type BankScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BankScalarWhereWithAggregatesInput>
    OR?: Enumerable<BankScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BankScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    url?: StringWithAggregatesFilter | string
    image?: StringWithAggregatesFilter | string
    isDeprecated?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type NotificationWhereInput = {
    AND?: Enumerable<NotificationWhereInput>
    OR?: Enumerable<NotificationWhereInput>
    NOT?: Enumerable<NotificationWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    body?: StringFilter | string
    readStatus?: BoolFilter | boolean
    isDeprecated?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    body?: SortOrder
    readStatus?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationWhereUniqueInput = {
    id?: string
  }

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    body?: SortOrder
    readStatus?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<NotificationScalarWhereWithAggregatesInput>
    OR?: Enumerable<NotificationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<NotificationScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    body?: StringWithAggregatesFilter | string
    readStatus?: BoolWithAggregatesFilter | boolean
    isDeprecated?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AccountWhereInput = {
    AND?: Enumerable<AccountWhereInput>
    OR?: Enumerable<AccountWhereInput>
    NOT?: Enumerable<AccountWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    type?: StringFilter | string
    provider?: StringFilter | string
    scope?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    scope?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = {
    id?: string
  }

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    scope?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AccountScalarWhereWithAggregatesInput>
    OR?: Enumerable<AccountScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AccountScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    provider?: StringWithAggregatesFilter | string
    scope?: StringWithAggregatesFilter | string
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    fullName?: StringFilter | string
    username?: StringNullableFilter | string | null
    email?: StringFilter | string
    password?: StringFilter | string
    phone?: StringNullableFilter | string | null
    picture?: StringNullableFilter | string | null
    isVerified?: BoolFilter | boolean
    referral?: StringFilter | string
    country?: StringNullableFilter | string | null
    resetToken?: StringNullableFilter | string | null
    isPartner?: BoolFilter | boolean
    isStaff?: BoolFilter | boolean
    isPhoneRegistered?: BoolFilter | boolean
    isPhoneVerified?: BoolFilter | boolean
    isIdentificationRegistered?: BoolFilter | boolean
    isIdentificationVerified?: BoolFilter | boolean
    partnerPermission?: StringNullableListFilter
    staffPermission?: StringNullableListFilter
    userPermission?: StringNullableListFilter
    isDeprecated?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    teamMember?: TeamMemberListRelationFilter
    account?: AccountListRelationFilter
    product?: ProductListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    fullName?: SortOrder
    username?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrderInput | SortOrder
    picture?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    referral?: SortOrder
    country?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    isPartner?: SortOrder
    isStaff?: SortOrder
    isPhoneRegistered?: SortOrder
    isPhoneVerified?: SortOrder
    isIdentificationRegistered?: SortOrder
    isIdentificationVerified?: SortOrder
    partnerPermission?: SortOrder
    staffPermission?: SortOrder
    userPermission?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teamMember?: TeamMemberOrderByRelationAggregateInput
    account?: AccountOrderByRelationAggregateInput
    product?: ProductOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: string
    email?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    fullName?: SortOrder
    username?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrderInput | SortOrder
    picture?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    referral?: SortOrder
    country?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    isPartner?: SortOrder
    isStaff?: SortOrder
    isPhoneRegistered?: SortOrder
    isPhoneVerified?: SortOrder
    isIdentificationRegistered?: SortOrder
    isIdentificationVerified?: SortOrder
    partnerPermission?: SortOrder
    staffPermission?: SortOrder
    userPermission?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    fullName?: StringWithAggregatesFilter | string
    username?: StringNullableWithAggregatesFilter | string | null
    email?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    phone?: StringNullableWithAggregatesFilter | string | null
    picture?: StringNullableWithAggregatesFilter | string | null
    isVerified?: BoolWithAggregatesFilter | boolean
    referral?: StringWithAggregatesFilter | string
    country?: StringNullableWithAggregatesFilter | string | null
    resetToken?: StringNullableWithAggregatesFilter | string | null
    isPartner?: BoolWithAggregatesFilter | boolean
    isStaff?: BoolWithAggregatesFilter | boolean
    isPhoneRegistered?: BoolWithAggregatesFilter | boolean
    isPhoneVerified?: BoolWithAggregatesFilter | boolean
    isIdentificationRegistered?: BoolWithAggregatesFilter | boolean
    isIdentificationVerified?: BoolWithAggregatesFilter | boolean
    partnerPermission?: StringNullableListFilter
    staffPermission?: StringNullableListFilter
    userPermission?: StringNullableListFilter
    isDeprecated?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserDocumentWhereInput = {
    AND?: Enumerable<UserDocumentWhereInput>
    OR?: Enumerable<UserDocumentWhereInput>
    NOT?: Enumerable<UserDocumentWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    type?: StringFilter | string
    description?: StringFilter | string
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UserDocumentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserDocumentWhereUniqueInput = {
    id?: string
  }

  export type UserDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserDocumentCountOrderByAggregateInput
    _max?: UserDocumentMaxOrderByAggregateInput
    _min?: UserDocumentMinOrderByAggregateInput
  }

  export type UserDocumentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserDocumentScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserDocumentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserDocumentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ServiceCategoryWhereInput = {
    AND?: Enumerable<ServiceCategoryWhereInput>
    OR?: Enumerable<ServiceCategoryWhereInput>
    NOT?: Enumerable<ServiceCategoryWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    description?: StringFilter | string
    isDeprecated?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    services?: ServiceListRelationFilter
    form?: ServiceCategoryFormListRelationFilter
  }

  export type ServiceCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    services?: ServiceOrderByRelationAggregateInput
    form?: ServiceCategoryFormOrderByRelationAggregateInput
  }

  export type ServiceCategoryWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type ServiceCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceCategoryCountOrderByAggregateInput
    _max?: ServiceCategoryMaxOrderByAggregateInput
    _min?: ServiceCategoryMinOrderByAggregateInput
  }

  export type ServiceCategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ServiceCategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<ServiceCategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ServiceCategoryScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    isDeprecated?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ServiceCategoryFormWhereInput = {
    AND?: Enumerable<ServiceCategoryFormWhereInput>
    OR?: Enumerable<ServiceCategoryFormWhereInput>
    NOT?: Enumerable<ServiceCategoryFormWhereInput>
    id?: StringFilter | string
    question?: StringFilter | string
    type?: StringFilter | string
    options?: StringNullableListFilter
    compulsory?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    serviceCategoryId?: StringFilter | string
    category?: XOR<ServiceCategoryRelationFilter, ServiceCategoryWhereInput>
  }

  export type ServiceCategoryFormOrderByWithRelationInput = {
    id?: SortOrder
    question?: SortOrder
    type?: SortOrder
    options?: SortOrder
    compulsory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceCategoryId?: SortOrder
    category?: ServiceCategoryOrderByWithRelationInput
  }

  export type ServiceCategoryFormWhereUniqueInput = {
    id?: string
  }

  export type ServiceCategoryFormOrderByWithAggregationInput = {
    id?: SortOrder
    question?: SortOrder
    type?: SortOrder
    options?: SortOrder
    compulsory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceCategoryId?: SortOrder
    _count?: ServiceCategoryFormCountOrderByAggregateInput
    _max?: ServiceCategoryFormMaxOrderByAggregateInput
    _min?: ServiceCategoryFormMinOrderByAggregateInput
  }

  export type ServiceCategoryFormScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ServiceCategoryFormScalarWhereWithAggregatesInput>
    OR?: Enumerable<ServiceCategoryFormScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ServiceCategoryFormScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    question?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    options?: StringNullableListFilter
    compulsory?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    serviceCategoryId?: StringWithAggregatesFilter | string
  }

  export type ServiceWhereInput = {
    AND?: Enumerable<ServiceWhereInput>
    OR?: Enumerable<ServiceWhereInput>
    NOT?: Enumerable<ServiceWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    type?: StringFilter | string
    code?: StringFilter | string
    description?: StringFilter | string
    country?: StringFilter | string
    price?: StringFilter | string
    timeline?: StringFilter | string
    feature?: StringNullableListFilter
    categoryForm?: StringNullableListFilter
    hasShares?: BoolFilter | boolean
    numberOfShares?: StringFilter | string
    hasAgent?: BoolFilter | boolean
    hasOwner?: BoolFilter | boolean
    hasController?: BoolFilter | boolean
    controllerIsCalled?: StringNullableFilter | string | null
    OwnerIsCalled?: StringNullableFilter | string | null
    agentIsCalled?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    serviceCategoryId?: StringFilter | string
    category?: XOR<ServiceCategoryRelationFilter, ServiceCategoryWhereInput>
    products?: ProductListRelationFilter
    templates?: ServiceTemplateListRelationFilter
    forms?: ServiceFormListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    code?: SortOrder
    description?: SortOrder
    country?: SortOrder
    price?: SortOrder
    timeline?: SortOrder
    feature?: SortOrder
    categoryForm?: SortOrder
    hasShares?: SortOrder
    numberOfShares?: SortOrder
    hasAgent?: SortOrder
    hasOwner?: SortOrder
    hasController?: SortOrder
    controllerIsCalled?: SortOrderInput | SortOrder
    OwnerIsCalled?: SortOrderInput | SortOrder
    agentIsCalled?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceCategoryId?: SortOrder
    category?: ServiceCategoryOrderByWithRelationInput
    products?: ProductOrderByRelationAggregateInput
    templates?: ServiceTemplateOrderByRelationAggregateInput
    forms?: ServiceFormOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = {
    id?: string
  }

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    code?: SortOrder
    description?: SortOrder
    country?: SortOrder
    price?: SortOrder
    timeline?: SortOrder
    feature?: SortOrder
    categoryForm?: SortOrder
    hasShares?: SortOrder
    numberOfShares?: SortOrder
    hasAgent?: SortOrder
    hasOwner?: SortOrder
    hasController?: SortOrder
    controllerIsCalled?: SortOrderInput | SortOrder
    OwnerIsCalled?: SortOrderInput | SortOrder
    agentIsCalled?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceCategoryId?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ServiceScalarWhereWithAggregatesInput>
    OR?: Enumerable<ServiceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ServiceScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    country?: StringWithAggregatesFilter | string
    price?: StringWithAggregatesFilter | string
    timeline?: StringWithAggregatesFilter | string
    feature?: StringNullableListFilter
    categoryForm?: StringNullableListFilter
    hasShares?: BoolWithAggregatesFilter | boolean
    numberOfShares?: StringWithAggregatesFilter | string
    hasAgent?: BoolWithAggregatesFilter | boolean
    hasOwner?: BoolWithAggregatesFilter | boolean
    hasController?: BoolWithAggregatesFilter | boolean
    controllerIsCalled?: StringNullableWithAggregatesFilter | string | null
    OwnerIsCalled?: StringNullableWithAggregatesFilter | string | null
    agentIsCalled?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    serviceCategoryId?: StringWithAggregatesFilter | string
  }

  export type ServiceTemplateWhereInput = {
    AND?: Enumerable<ServiceTemplateWhereInput>
    OR?: Enumerable<ServiceTemplateWhereInput>
    NOT?: Enumerable<ServiceTemplateWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    type?: StringFilter | string
    description?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    serviceId?: StringFilter | string
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
  }

  export type ServiceTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceId?: SortOrder
    service?: ServiceOrderByWithRelationInput
  }

  export type ServiceTemplateWhereUniqueInput = {
    id?: string
  }

  export type ServiceTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceId?: SortOrder
    _count?: ServiceTemplateCountOrderByAggregateInput
    _max?: ServiceTemplateMaxOrderByAggregateInput
    _min?: ServiceTemplateMinOrderByAggregateInput
  }

  export type ServiceTemplateScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ServiceTemplateScalarWhereWithAggregatesInput>
    OR?: Enumerable<ServiceTemplateScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ServiceTemplateScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    serviceId?: StringWithAggregatesFilter | string
  }

  export type ServiceFormWhereInput = {
    AND?: Enumerable<ServiceFormWhereInput>
    OR?: Enumerable<ServiceFormWhereInput>
    NOT?: Enumerable<ServiceFormWhereInput>
    id?: StringFilter | string
    question?: StringFilter | string
    type?: StringFilter | string
    options?: StringNullableListFilter
    compulsory?: BoolFilter | boolean
    fileName?: StringFilter | string
    fileDescription?: StringFilter | string
    fileType?: StringFilter | string
    fileLink?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    serviceId?: StringFilter | string
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
    serviceSubForm?: ServiceSubFormListRelationFilter
  }

  export type ServiceFormOrderByWithRelationInput = {
    id?: SortOrder
    question?: SortOrder
    type?: SortOrder
    options?: SortOrder
    compulsory?: SortOrder
    fileName?: SortOrder
    fileDescription?: SortOrder
    fileType?: SortOrder
    fileLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceId?: SortOrder
    service?: ServiceOrderByWithRelationInput
    serviceSubForm?: ServiceSubFormOrderByRelationAggregateInput
  }

  export type ServiceFormWhereUniqueInput = {
    id?: string
  }

  export type ServiceFormOrderByWithAggregationInput = {
    id?: SortOrder
    question?: SortOrder
    type?: SortOrder
    options?: SortOrder
    compulsory?: SortOrder
    fileName?: SortOrder
    fileDescription?: SortOrder
    fileType?: SortOrder
    fileLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceId?: SortOrder
    _count?: ServiceFormCountOrderByAggregateInput
    _max?: ServiceFormMaxOrderByAggregateInput
    _min?: ServiceFormMinOrderByAggregateInput
  }

  export type ServiceFormScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ServiceFormScalarWhereWithAggregatesInput>
    OR?: Enumerable<ServiceFormScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ServiceFormScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    question?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    options?: StringNullableListFilter
    compulsory?: BoolWithAggregatesFilter | boolean
    fileName?: StringWithAggregatesFilter | string
    fileDescription?: StringWithAggregatesFilter | string
    fileType?: StringWithAggregatesFilter | string
    fileLink?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    serviceId?: StringWithAggregatesFilter | string
  }

  export type ServiceSubFormWhereInput = {
    AND?: Enumerable<ServiceSubFormWhereInput>
    OR?: Enumerable<ServiceSubFormWhereInput>
    NOT?: Enumerable<ServiceSubFormWhereInput>
    id?: StringFilter | string
    question?: StringFilter | string
    options?: StringNullableListFilter
    type?: StringFilter | string
    compulsory?: BoolFilter | boolean
    fileName?: StringFilter | string
    fileDescription?: StringFilter | string
    fileType?: StringFilter | string
    fileLink?: StringFilter | string
    serviceFormId?: StringFilter | string
    serviceForm?: XOR<ServiceFormRelationFilter, ServiceFormWhereInput>
  }

  export type ServiceSubFormOrderByWithRelationInput = {
    id?: SortOrder
    question?: SortOrder
    options?: SortOrder
    type?: SortOrder
    compulsory?: SortOrder
    fileName?: SortOrder
    fileDescription?: SortOrder
    fileType?: SortOrder
    fileLink?: SortOrder
    serviceFormId?: SortOrder
    serviceForm?: ServiceFormOrderByWithRelationInput
  }

  export type ServiceSubFormWhereUniqueInput = {
    id?: string
  }

  export type ServiceSubFormOrderByWithAggregationInput = {
    id?: SortOrder
    question?: SortOrder
    options?: SortOrder
    type?: SortOrder
    compulsory?: SortOrder
    fileName?: SortOrder
    fileDescription?: SortOrder
    fileType?: SortOrder
    fileLink?: SortOrder
    serviceFormId?: SortOrder
    _count?: ServiceSubFormCountOrderByAggregateInput
    _max?: ServiceSubFormMaxOrderByAggregateInput
    _min?: ServiceSubFormMinOrderByAggregateInput
  }

  export type ServiceSubFormScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ServiceSubFormScalarWhereWithAggregatesInput>
    OR?: Enumerable<ServiceSubFormScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ServiceSubFormScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    question?: StringWithAggregatesFilter | string
    options?: StringNullableListFilter
    type?: StringWithAggregatesFilter | string
    compulsory?: BoolWithAggregatesFilter | boolean
    fileName?: StringWithAggregatesFilter | string
    fileDescription?: StringWithAggregatesFilter | string
    fileType?: StringWithAggregatesFilter | string
    fileLink?: StringWithAggregatesFilter | string
    serviceFormId?: StringWithAggregatesFilter | string
  }

  export type ProductWhereInput = {
    AND?: Enumerable<ProductWhereInput>
    OR?: Enumerable<ProductWhereInput>
    NOT?: Enumerable<ProductWhereInput>
    id?: StringFilter | string
    email?: StringNullableFilter | string | null
    address?: StringNullableFilter | string | null
    paid?: BoolFilter | boolean
    completed?: BoolFilter | boolean
    status?: StringFilter | string
    currentState?: EnumProductActivityStageFilter | ProductActivityStage
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    serviceId?: StringNullableFilter | string | null
    userId?: StringFilter | string
    Team?: TeamListRelationFilter
    service?: XOR<ServiceRelationFilter, ServiceWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    Payment?: PaymentListRelationFilter
    productQA?: ProductQAListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    paid?: SortOrder
    completed?: SortOrder
    status?: SortOrder
    currentState?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceId?: SortOrderInput | SortOrder
    userId?: SortOrder
    Team?: TeamOrderByRelationAggregateInput
    service?: ServiceOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    Payment?: PaymentOrderByRelationAggregateInput
    productQA?: ProductQAOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = {
    id?: string
  }

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    paid?: SortOrder
    completed?: SortOrder
    status?: SortOrder
    currentState?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceId?: SortOrderInput | SortOrder
    userId?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    email?: StringNullableWithAggregatesFilter | string | null
    address?: StringNullableWithAggregatesFilter | string | null
    paid?: BoolWithAggregatesFilter | boolean
    completed?: BoolWithAggregatesFilter | boolean
    status?: StringWithAggregatesFilter | string
    currentState?: EnumProductActivityStageWithAggregatesFilter | ProductActivityStage
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    serviceId?: StringNullableWithAggregatesFilter | string | null
    userId?: StringWithAggregatesFilter | string
  }

  export type ProductQAWhereInput = {
    AND?: Enumerable<ProductQAWhereInput>
    OR?: Enumerable<ProductQAWhereInput>
    NOT?: Enumerable<ProductQAWhereInput>
    id?: StringFilter | string
    question?: StringFilter | string
    answer?: StringNullableListFilter
    type?: StringFilter | string
    compulsory?: BoolFilter | boolean
    isGeneral?: BoolFilter | boolean
    fileName?: StringFilter | string
    fileDescription?: StringFilter | string
    fileType?: StringFilter | string
    fileLink?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    productId?: StringFilter | string
    products?: XOR<ProductRelationFilter, ProductWhereInput>
    productSubForm?: ProductQASubFormListRelationFilter
  }

  export type ProductQAOrderByWithRelationInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    type?: SortOrder
    compulsory?: SortOrder
    isGeneral?: SortOrder
    fileName?: SortOrder
    fileDescription?: SortOrder
    fileType?: SortOrder
    fileLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
    products?: ProductOrderByWithRelationInput
    productSubForm?: ProductQASubFormOrderByRelationAggregateInput
  }

  export type ProductQAWhereUniqueInput = {
    id?: string
  }

  export type ProductQAOrderByWithAggregationInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    type?: SortOrder
    compulsory?: SortOrder
    isGeneral?: SortOrder
    fileName?: SortOrder
    fileDescription?: SortOrder
    fileType?: SortOrder
    fileLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
    _count?: ProductQACountOrderByAggregateInput
    _max?: ProductQAMaxOrderByAggregateInput
    _min?: ProductQAMinOrderByAggregateInput
  }

  export type ProductQAScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductQAScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductQAScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductQAScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    question?: StringWithAggregatesFilter | string
    answer?: StringNullableListFilter
    type?: StringWithAggregatesFilter | string
    compulsory?: BoolWithAggregatesFilter | boolean
    isGeneral?: BoolWithAggregatesFilter | boolean
    fileName?: StringWithAggregatesFilter | string
    fileDescription?: StringWithAggregatesFilter | string
    fileType?: StringWithAggregatesFilter | string
    fileLink?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    productId?: StringWithAggregatesFilter | string
  }

  export type ProductQASubFormWhereInput = {
    AND?: Enumerable<ProductQASubFormWhereInput>
    OR?: Enumerable<ProductQASubFormWhereInput>
    NOT?: Enumerable<ProductQASubFormWhereInput>
    id?: StringFilter | string
    question?: StringFilter | string
    answer?: StringNullableListFilter
    type?: StringFilter | string
    compulsory?: BoolFilter | boolean
    productQAId?: StringFilter | string
    productQA?: XOR<ProductQARelationFilter, ProductQAWhereInput>
  }

  export type ProductQASubFormOrderByWithRelationInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    type?: SortOrder
    compulsory?: SortOrder
    productQAId?: SortOrder
    productQA?: ProductQAOrderByWithRelationInput
  }

  export type ProductQASubFormWhereUniqueInput = {
    id?: string
  }

  export type ProductQASubFormOrderByWithAggregationInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    type?: SortOrder
    compulsory?: SortOrder
    productQAId?: SortOrder
    _count?: ProductQASubFormCountOrderByAggregateInput
    _max?: ProductQASubFormMaxOrderByAggregateInput
    _min?: ProductQASubFormMinOrderByAggregateInput
  }

  export type ProductQASubFormScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductQASubFormScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductQASubFormScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductQASubFormScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    question?: StringWithAggregatesFilter | string
    answer?: StringNullableListFilter
    type?: StringWithAggregatesFilter | string
    compulsory?: BoolWithAggregatesFilter | boolean
    productQAId?: StringWithAggregatesFilter | string
  }

  export type ClaimWhereInput = {
    AND?: Enumerable<ClaimWhereInput>
    OR?: Enumerable<ClaimWhereInput>
    NOT?: Enumerable<ClaimWhereInput>
    id?: StringFilter | string
    value?: StringFilter | string
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ClaimOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClaimWhereUniqueInput = {
    id?: string
  }

  export type ClaimOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClaimCountOrderByAggregateInput
    _max?: ClaimMaxOrderByAggregateInput
    _min?: ClaimMinOrderByAggregateInput
  }

  export type ClaimScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ClaimScalarWhereWithAggregatesInput>
    OR?: Enumerable<ClaimScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ClaimScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    value?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TeamWhereInput = {
    AND?: Enumerable<TeamWhereInput>
    OR?: Enumerable<TeamWhereInput>
    NOT?: Enumerable<TeamWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    slug?: StringFilter | string
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    productId?: StringFilter | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    invitation?: InvitationListRelationFilter
    teamMember?: TeamMemberListRelationFilter
  }

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
    product?: ProductOrderByWithRelationInput
    invitation?: InvitationOrderByRelationAggregateInput
    teamMember?: TeamMemberOrderByRelationAggregateInput
  }

  export type TeamWhereUniqueInput = {
    id?: string
  }

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
    _count?: TeamCountOrderByAggregateInput
    _max?: TeamMaxOrderByAggregateInput
    _min?: TeamMinOrderByAggregateInput
  }

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TeamScalarWhereWithAggregatesInput>
    OR?: Enumerable<TeamScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TeamScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    productId?: StringWithAggregatesFilter | string
  }

  export type TeamMemberWhereInput = {
    AND?: Enumerable<TeamMemberWhereInput>
    OR?: Enumerable<TeamMemberWhereInput>
    NOT?: Enumerable<TeamMemberWhereInput>
    id?: StringFilter | string
    isLaunchMember?: BoolFilter | boolean
    isLaunchController?: BoolFilter | boolean
    isLaunchOwner?: BoolFilter | boolean
    launchOwnership?: IntFilter | number
    teamId?: StringFilter | string
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    team?: XOR<TeamRelationFilter, TeamWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TeamMemberOrderByWithRelationInput = {
    id?: SortOrder
    isLaunchMember?: SortOrder
    isLaunchController?: SortOrder
    isLaunchOwner?: SortOrder
    launchOwnership?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    team?: TeamOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TeamMemberWhereUniqueInput = {
    id?: string
  }

  export type TeamMemberOrderByWithAggregationInput = {
    id?: SortOrder
    isLaunchMember?: SortOrder
    isLaunchController?: SortOrder
    isLaunchOwner?: SortOrder
    launchOwnership?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeamMemberCountOrderByAggregateInput
    _avg?: TeamMemberAvgOrderByAggregateInput
    _max?: TeamMemberMaxOrderByAggregateInput
    _min?: TeamMemberMinOrderByAggregateInput
    _sum?: TeamMemberSumOrderByAggregateInput
  }

  export type TeamMemberScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TeamMemberScalarWhereWithAggregatesInput>
    OR?: Enumerable<TeamMemberScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TeamMemberScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    isLaunchMember?: BoolWithAggregatesFilter | boolean
    isLaunchController?: BoolWithAggregatesFilter | boolean
    isLaunchOwner?: BoolWithAggregatesFilter | boolean
    launchOwnership?: IntWithAggregatesFilter | number
    teamId?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type InvitationWhereInput = {
    AND?: Enumerable<InvitationWhereInput>
    OR?: Enumerable<InvitationWhereInput>
    NOT?: Enumerable<InvitationWhereInput>
    id?: StringFilter | string
    teamId?: StringFilter | string
    email?: StringFilter | string
    token?: StringFilter | string
    expireIn?: DateTimeFilter | Date | string
    invitedBy?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    team?: XOR<TeamRelationFilter, TeamWhereInput>
  }

  export type InvitationOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expireIn?: SortOrder
    invitedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    team?: TeamOrderByWithRelationInput
  }

  export type InvitationWhereUniqueInput = {
    id?: string
  }

  export type InvitationOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expireIn?: SortOrder
    invitedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvitationCountOrderByAggregateInput
    _max?: InvitationMaxOrderByAggregateInput
    _min?: InvitationMinOrderByAggregateInput
  }

  export type InvitationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<InvitationScalarWhereWithAggregatesInput>
    OR?: Enumerable<InvitationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<InvitationScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    teamId?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    token?: StringWithAggregatesFilter | string
    expireIn?: DateTimeWithAggregatesFilter | Date | string
    invitedBy?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PaymentWhereInput = {
    AND?: Enumerable<PaymentWhereInput>
    OR?: Enumerable<PaymentWhereInput>
    NOT?: Enumerable<PaymentWhereInput>
    id?: StringFilter | string
    provider?: StringFilter | string
    transactionId?: StringFilter | string
    status?: StringFilter | string
    email?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    productId?: StringFilter | string
    products?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    provider?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
    products?: ProductOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = {
    id?: string
  }

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    provider?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PaymentScalarWhereWithAggregatesInput>
    OR?: Enumerable<PaymentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PaymentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    provider?: StringWithAggregatesFilter | string
    transactionId?: StringWithAggregatesFilter | string
    status?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    productId?: StringWithAggregatesFilter | string
  }

  export type ParterWhereInput = {
    AND?: Enumerable<ParterWhereInput>
    OR?: Enumerable<ParterWhereInput>
    NOT?: Enumerable<ParterWhereInput>
    id?: StringFilter | string
    isVerified?: BoolFilter | boolean
    verificationDocument?: StringNullableListFilter
    serviceScore?: IntFilter | number
    paymentsMade?: IntFilter | number
    paymentsDue?: IntFilter | number
    paymentDetails?: StringNullableListFilter
    countrySupported?: StringNullableListFilter
    serviceSupported?: StringNullableListFilter
    servicesAssigned?: StringNullableListFilter
    servicesCompleted?: StringNullableListFilter
    servicesDeclined?: StringNullableListFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ParterOrderByWithRelationInput = {
    id?: SortOrder
    isVerified?: SortOrder
    verificationDocument?: SortOrder
    serviceScore?: SortOrder
    paymentsMade?: SortOrder
    paymentsDue?: SortOrder
    paymentDetails?: SortOrder
    countrySupported?: SortOrder
    serviceSupported?: SortOrder
    servicesAssigned?: SortOrder
    servicesCompleted?: SortOrder
    servicesDeclined?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParterWhereUniqueInput = {
    id?: string
  }

  export type ParterOrderByWithAggregationInput = {
    id?: SortOrder
    isVerified?: SortOrder
    verificationDocument?: SortOrder
    serviceScore?: SortOrder
    paymentsMade?: SortOrder
    paymentsDue?: SortOrder
    paymentDetails?: SortOrder
    countrySupported?: SortOrder
    serviceSupported?: SortOrder
    servicesAssigned?: SortOrder
    servicesCompleted?: SortOrder
    servicesDeclined?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ParterCountOrderByAggregateInput
    _avg?: ParterAvgOrderByAggregateInput
    _max?: ParterMaxOrderByAggregateInput
    _min?: ParterMinOrderByAggregateInput
    _sum?: ParterSumOrderByAggregateInput
  }

  export type ParterScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ParterScalarWhereWithAggregatesInput>
    OR?: Enumerable<ParterScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ParterScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    isVerified?: BoolWithAggregatesFilter | boolean
    verificationDocument?: StringNullableListFilter
    serviceScore?: IntWithAggregatesFilter | number
    paymentsMade?: IntWithAggregatesFilter | number
    paymentsDue?: IntWithAggregatesFilter | number
    paymentDetails?: StringNullableListFilter
    countrySupported?: StringNullableListFilter
    serviceSupported?: StringNullableListFilter
    servicesAssigned?: StringNullableListFilter
    servicesCompleted?: StringNullableListFilter
    servicesDeclined?: StringNullableListFilter
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type StaffCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    password: string
    phone: string
    verified: boolean
    picture?: string | null
    resetToken?: string | null
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    password: string
    phone: string
    verified: boolean
    picture?: string | null
    resetToken?: string | null
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffCreateManyInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    password: string
    phone: string
    verified: boolean
    picture?: string | null
    resetToken?: string | null
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollaboratorCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    password: string
    phone: string
    picture?: string | null
    verified: boolean
    isPartner: boolean
    resetToken?: string | null
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    collaboratorDocument?: CollaboratorDocumentCreateNestedManyWithoutCollaboratorInput
  }

  export type CollaboratorUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    password: string
    phone: string
    picture?: string | null
    verified: boolean
    isPartner: boolean
    resetToken?: string | null
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    collaboratorDocument?: CollaboratorDocumentUncheckedCreateNestedManyWithoutCollaboratorInput
  }

  export type CollaboratorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collaboratorDocument?: CollaboratorDocumentUpdateManyWithoutCollaboratorNestedInput
  }

  export type CollaboratorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collaboratorDocument?: CollaboratorDocumentUncheckedUpdateManyWithoutCollaboratorNestedInput
  }

  export type CollaboratorCreateManyInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    password: string
    phone: string
    picture?: string | null
    verified: boolean
    isPartner: boolean
    resetToken?: string | null
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CollaboratorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollaboratorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollaboratorDocumentCreateInput = {
    id?: string
    name: string
    type: string
    description: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    collaborator: CollaboratorCreateNestedOneWithoutCollaboratorDocumentInput
  }

  export type CollaboratorDocumentUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    description: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    collaboratorId: string
  }

  export type CollaboratorDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collaborator?: CollaboratorUpdateOneRequiredWithoutCollaboratorDocumentNestedInput
  }

  export type CollaboratorDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collaboratorId?: StringFieldUpdateOperationsInput | string
  }

  export type CollaboratorDocumentCreateManyInput = {
    id?: string
    name: string
    type: string
    description: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    collaboratorId: string
  }

  export type CollaboratorDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollaboratorDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collaboratorId?: StringFieldUpdateOperationsInput | string
  }

  export type RewardCreateInput = {
    id?: string
    name: string
    url: string
    descrition: string
    image: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RewardUncheckedCreateInput = {
    id?: string
    name: string
    url: string
    descrition: string
    image: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RewardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    descrition?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    descrition?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardCreateManyInput = {
    id?: string
    name: string
    url: string
    descrition: string
    image: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RewardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    descrition?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    descrition?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryCreateInput = {
    id?: string
    name: string
    iso: string
    currency: string
    code: string
    flagUrl: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CountryUncheckedCreateInput = {
    id?: string
    name: string
    iso: string
    currency: string
    code: string
    flagUrl: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CountryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iso?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    flagUrl?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iso?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    flagUrl?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryCreateManyInput = {
    id?: string
    name: string
    iso: string
    currency: string
    code: string
    flagUrl: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CountryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iso?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    flagUrl?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iso?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    flagUrl?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankCreateInput = {
    id?: string
    name: string
    code: string
    url: string
    image: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    url: string
    image: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankCreateManyInput = {
    id?: string
    name: string
    code: string
    url: string
    image: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    body: string
    readStatus: boolean
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    title: string
    body: string
    readStatus: boolean
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    title: string
    body: string
    readStatus: boolean
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    scope: string
    user: UserCreateNestedOneWithoutAccountInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    scope: string
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    scope: string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateInput = {
    id?: string
    fullName: string
    username?: string | null
    email: string
    password: string
    phone?: string | null
    picture?: string | null
    isVerified?: boolean
    referral: string
    country?: string | null
    resetToken?: string | null
    isPartner?: boolean
    isStaff?: boolean
    isPhoneRegistered?: boolean
    isPhoneVerified?: boolean
    isIdentificationRegistered?: boolean
    isIdentificationVerified?: boolean
    partnerPermission?: UserCreatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserCreatestaffPermissionInput | Enumerable<string>
    userPermission?: UserCreateuserPermissionInput | Enumerable<string>
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamMember?: TeamMemberCreateNestedManyWithoutUserInput
    account?: AccountCreateNestedManyWithoutUserInput
    product?: ProductCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    fullName: string
    username?: string | null
    email: string
    password: string
    phone?: string | null
    picture?: string | null
    isVerified?: boolean
    referral: string
    country?: string | null
    resetToken?: string | null
    isPartner?: boolean
    isStaff?: boolean
    isPhoneRegistered?: boolean
    isPhoneVerified?: boolean
    isIdentificationRegistered?: boolean
    isIdentificationVerified?: boolean
    partnerPermission?: UserCreatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserCreatestaffPermissionInput | Enumerable<string>
    userPermission?: UserCreateuserPermissionInput | Enumerable<string>
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamMember?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    account?: AccountUncheckedCreateNestedManyWithoutUserInput
    product?: ProductUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    referral?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    isStaff?: BoolFieldUpdateOperationsInput | boolean
    isPhoneRegistered?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationRegistered?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationVerified?: BoolFieldUpdateOperationsInput | boolean
    partnerPermission?: UserUpdatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserUpdatestaffPermissionInput | Enumerable<string>
    userPermission?: UserUpdateuserPermissionInput | Enumerable<string>
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMember?: TeamMemberUpdateManyWithoutUserNestedInput
    account?: AccountUpdateManyWithoutUserNestedInput
    product?: ProductUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    referral?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    isStaff?: BoolFieldUpdateOperationsInput | boolean
    isPhoneRegistered?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationRegistered?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationVerified?: BoolFieldUpdateOperationsInput | boolean
    partnerPermission?: UserUpdatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserUpdatestaffPermissionInput | Enumerable<string>
    userPermission?: UserUpdateuserPermissionInput | Enumerable<string>
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMember?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    account?: AccountUncheckedUpdateManyWithoutUserNestedInput
    product?: ProductUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    fullName: string
    username?: string | null
    email: string
    password: string
    phone?: string | null
    picture?: string | null
    isVerified?: boolean
    referral: string
    country?: string | null
    resetToken?: string | null
    isPartner?: boolean
    isStaff?: boolean
    isPhoneRegistered?: boolean
    isPhoneVerified?: boolean
    isIdentificationRegistered?: boolean
    isIdentificationVerified?: boolean
    partnerPermission?: UserCreatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserCreatestaffPermissionInput | Enumerable<string>
    userPermission?: UserCreateuserPermissionInput | Enumerable<string>
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    referral?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    isStaff?: BoolFieldUpdateOperationsInput | boolean
    isPhoneRegistered?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationRegistered?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationVerified?: BoolFieldUpdateOperationsInput | boolean
    partnerPermission?: UserUpdatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserUpdatestaffPermissionInput | Enumerable<string>
    userPermission?: UserUpdateuserPermissionInput | Enumerable<string>
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    referral?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    isStaff?: BoolFieldUpdateOperationsInput | boolean
    isPhoneRegistered?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationRegistered?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationVerified?: BoolFieldUpdateOperationsInput | boolean
    partnerPermission?: UserUpdatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserUpdatestaffPermissionInput | Enumerable<string>
    userPermission?: UserUpdateuserPermissionInput | Enumerable<string>
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserDocumentCreateInput = {
    id?: string
    name: string
    type: string
    description: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserDocumentUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    description: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserDocumentCreateManyInput = {
    id?: string
    name: string
    type: string
    description: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCategoryCreateInput = {
    id?: string
    name: string
    description: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceCreateNestedManyWithoutCategoryInput
    form?: ServiceCategoryFormCreateNestedManyWithoutCategoryInput
  }

  export type ServiceCategoryUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutCategoryInput
    form?: ServiceCategoryFormUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ServiceCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUpdateManyWithoutCategoryNestedInput
    form?: ServiceCategoryFormUpdateManyWithoutCategoryNestedInput
  }

  export type ServiceCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutCategoryNestedInput
    form?: ServiceCategoryFormUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ServiceCategoryCreateManyInput = {
    id?: string
    name: string
    description: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCategoryFormCreateInput = {
    id?: string
    question: string
    type: string
    options?: ServiceCategoryFormCreateoptionsInput | Enumerable<string>
    compulsory?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category: ServiceCategoryCreateNestedOneWithoutFormInput
  }

  export type ServiceCategoryFormUncheckedCreateInput = {
    id?: string
    question: string
    type: string
    options?: ServiceCategoryFormCreateoptionsInput | Enumerable<string>
    compulsory?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceCategoryId: string
  }

  export type ServiceCategoryFormUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: ServiceCategoryFormUpdateoptionsInput | Enumerable<string>
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ServiceCategoryUpdateOneRequiredWithoutFormNestedInput
  }

  export type ServiceCategoryFormUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: ServiceCategoryFormUpdateoptionsInput | Enumerable<string>
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceCategoryId?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceCategoryFormCreateManyInput = {
    id?: string
    question: string
    type: string
    options?: ServiceCategoryFormCreateoptionsInput | Enumerable<string>
    compulsory?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceCategoryId: string
  }

  export type ServiceCategoryFormUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: ServiceCategoryFormUpdateoptionsInput | Enumerable<string>
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCategoryFormUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: ServiceCategoryFormUpdateoptionsInput | Enumerable<string>
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceCategoryId?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceCreateInput = {
    id?: string
    name: string
    type: string
    code: string
    description: string
    country: string
    price: string
    timeline: string
    feature?: ServiceCreatefeatureInput | Enumerable<string>
    categoryForm?: ServiceCreatecategoryFormInput | Enumerable<string>
    hasShares?: boolean
    numberOfShares: string
    hasAgent?: boolean
    hasOwner?: boolean
    hasController?: boolean
    controllerIsCalled?: string | null
    OwnerIsCalled?: string | null
    agentIsCalled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category: ServiceCategoryCreateNestedOneWithoutServicesInput
    products?: ProductCreateNestedManyWithoutServiceInput
    templates?: ServiceTemplateCreateNestedManyWithoutServiceInput
    forms?: ServiceFormCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    code: string
    description: string
    country: string
    price: string
    timeline: string
    feature?: ServiceCreatefeatureInput | Enumerable<string>
    categoryForm?: ServiceCreatecategoryFormInput | Enumerable<string>
    hasShares?: boolean
    numberOfShares: string
    hasAgent?: boolean
    hasOwner?: boolean
    hasController?: boolean
    controllerIsCalled?: string | null
    OwnerIsCalled?: string | null
    agentIsCalled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceCategoryId: string
    products?: ProductUncheckedCreateNestedManyWithoutServiceInput
    templates?: ServiceTemplateUncheckedCreateNestedManyWithoutServiceInput
    forms?: ServiceFormUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    timeline?: StringFieldUpdateOperationsInput | string
    feature?: ServiceUpdatefeatureInput | Enumerable<string>
    categoryForm?: ServiceUpdatecategoryFormInput | Enumerable<string>
    hasShares?: BoolFieldUpdateOperationsInput | boolean
    numberOfShares?: StringFieldUpdateOperationsInput | string
    hasAgent?: BoolFieldUpdateOperationsInput | boolean
    hasOwner?: BoolFieldUpdateOperationsInput | boolean
    hasController?: BoolFieldUpdateOperationsInput | boolean
    controllerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    agentIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ServiceCategoryUpdateOneRequiredWithoutServicesNestedInput
    products?: ProductUpdateManyWithoutServiceNestedInput
    templates?: ServiceTemplateUpdateManyWithoutServiceNestedInput
    forms?: ServiceFormUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    timeline?: StringFieldUpdateOperationsInput | string
    feature?: ServiceUpdatefeatureInput | Enumerable<string>
    categoryForm?: ServiceUpdatecategoryFormInput | Enumerable<string>
    hasShares?: BoolFieldUpdateOperationsInput | boolean
    numberOfShares?: StringFieldUpdateOperationsInput | string
    hasAgent?: BoolFieldUpdateOperationsInput | boolean
    hasOwner?: BoolFieldUpdateOperationsInput | boolean
    hasController?: BoolFieldUpdateOperationsInput | boolean
    controllerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    agentIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceCategoryId?: StringFieldUpdateOperationsInput | string
    products?: ProductUncheckedUpdateManyWithoutServiceNestedInput
    templates?: ServiceTemplateUncheckedUpdateManyWithoutServiceNestedInput
    forms?: ServiceFormUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: string
    name: string
    type: string
    code: string
    description: string
    country: string
    price: string
    timeline: string
    feature?: ServiceCreatefeatureInput | Enumerable<string>
    categoryForm?: ServiceCreatecategoryFormInput | Enumerable<string>
    hasShares?: boolean
    numberOfShares: string
    hasAgent?: boolean
    hasOwner?: boolean
    hasController?: boolean
    controllerIsCalled?: string | null
    OwnerIsCalled?: string | null
    agentIsCalled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceCategoryId: string
  }

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    timeline?: StringFieldUpdateOperationsInput | string
    feature?: ServiceUpdatefeatureInput | Enumerable<string>
    categoryForm?: ServiceUpdatecategoryFormInput | Enumerable<string>
    hasShares?: BoolFieldUpdateOperationsInput | boolean
    numberOfShares?: StringFieldUpdateOperationsInput | string
    hasAgent?: BoolFieldUpdateOperationsInput | boolean
    hasOwner?: BoolFieldUpdateOperationsInput | boolean
    hasController?: BoolFieldUpdateOperationsInput | boolean
    controllerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    agentIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    timeline?: StringFieldUpdateOperationsInput | string
    feature?: ServiceUpdatefeatureInput | Enumerable<string>
    categoryForm?: ServiceUpdatecategoryFormInput | Enumerable<string>
    hasShares?: BoolFieldUpdateOperationsInput | boolean
    numberOfShares?: StringFieldUpdateOperationsInput | string
    hasAgent?: BoolFieldUpdateOperationsInput | boolean
    hasOwner?: BoolFieldUpdateOperationsInput | boolean
    hasController?: BoolFieldUpdateOperationsInput | boolean
    controllerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    agentIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceCategoryId?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceTemplateCreateInput = {
    id?: string
    name: string
    type: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    service: ServiceCreateNestedOneWithoutTemplatesInput
  }

  export type ServiceTemplateUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceId: string
  }

  export type ServiceTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutTemplatesNestedInput
  }

  export type ServiceTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceTemplateCreateManyInput = {
    id?: string
    name: string
    type: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceId: string
  }

  export type ServiceTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceFormCreateInput = {
    id?: string
    question: string
    type: string
    options?: ServiceFormCreateoptionsInput | Enumerable<string>
    compulsory?: boolean
    fileName: string
    fileDescription: string
    fileType: string
    fileLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
    service: ServiceCreateNestedOneWithoutFormsInput
    serviceSubForm?: ServiceSubFormCreateNestedManyWithoutServiceFormInput
  }

  export type ServiceFormUncheckedCreateInput = {
    id?: string
    question: string
    type: string
    options?: ServiceFormCreateoptionsInput | Enumerable<string>
    compulsory?: boolean
    fileName: string
    fileDescription: string
    fileType: string
    fileLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceId: string
    serviceSubForm?: ServiceSubFormUncheckedCreateNestedManyWithoutServiceFormInput
  }

  export type ServiceFormUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: ServiceFormUpdateoptionsInput | Enumerable<string>
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    fileName?: StringFieldUpdateOperationsInput | string
    fileDescription?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutFormsNestedInput
    serviceSubForm?: ServiceSubFormUpdateManyWithoutServiceFormNestedInput
  }

  export type ServiceFormUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: ServiceFormUpdateoptionsInput | Enumerable<string>
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    fileName?: StringFieldUpdateOperationsInput | string
    fileDescription?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceId?: StringFieldUpdateOperationsInput | string
    serviceSubForm?: ServiceSubFormUncheckedUpdateManyWithoutServiceFormNestedInput
  }

  export type ServiceFormCreateManyInput = {
    id?: string
    question: string
    type: string
    options?: ServiceFormCreateoptionsInput | Enumerable<string>
    compulsory?: boolean
    fileName: string
    fileDescription: string
    fileType: string
    fileLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceId: string
  }

  export type ServiceFormUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: ServiceFormUpdateoptionsInput | Enumerable<string>
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    fileName?: StringFieldUpdateOperationsInput | string
    fileDescription?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceFormUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: ServiceFormUpdateoptionsInput | Enumerable<string>
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    fileName?: StringFieldUpdateOperationsInput | string
    fileDescription?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceSubFormCreateInput = {
    id?: string
    question: string
    options?: ServiceSubFormCreateoptionsInput | Enumerable<string>
    type: string
    compulsory?: boolean
    fileName: string
    fileDescription: string
    fileType: string
    fileLink: string
    serviceForm: ServiceFormCreateNestedOneWithoutServiceSubFormInput
  }

  export type ServiceSubFormUncheckedCreateInput = {
    id?: string
    question: string
    options?: ServiceSubFormCreateoptionsInput | Enumerable<string>
    type: string
    compulsory?: boolean
    fileName: string
    fileDescription: string
    fileType: string
    fileLink: string
    serviceFormId: string
  }

  export type ServiceSubFormUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: ServiceSubFormUpdateoptionsInput | Enumerable<string>
    type?: StringFieldUpdateOperationsInput | string
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    fileName?: StringFieldUpdateOperationsInput | string
    fileDescription?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileLink?: StringFieldUpdateOperationsInput | string
    serviceForm?: ServiceFormUpdateOneRequiredWithoutServiceSubFormNestedInput
  }

  export type ServiceSubFormUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: ServiceSubFormUpdateoptionsInput | Enumerable<string>
    type?: StringFieldUpdateOperationsInput | string
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    fileName?: StringFieldUpdateOperationsInput | string
    fileDescription?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileLink?: StringFieldUpdateOperationsInput | string
    serviceFormId?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceSubFormCreateManyInput = {
    id?: string
    question: string
    options?: ServiceSubFormCreateoptionsInput | Enumerable<string>
    type: string
    compulsory?: boolean
    fileName: string
    fileDescription: string
    fileType: string
    fileLink: string
    serviceFormId: string
  }

  export type ServiceSubFormUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: ServiceSubFormUpdateoptionsInput | Enumerable<string>
    type?: StringFieldUpdateOperationsInput | string
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    fileName?: StringFieldUpdateOperationsInput | string
    fileDescription?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileLink?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceSubFormUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: ServiceSubFormUpdateoptionsInput | Enumerable<string>
    type?: StringFieldUpdateOperationsInput | string
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    fileName?: StringFieldUpdateOperationsInput | string
    fileDescription?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileLink?: StringFieldUpdateOperationsInput | string
    serviceFormId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductCreateInput = {
    id?: string
    email?: string | null
    address?: string | null
    paid?: boolean
    completed?: boolean
    status?: string
    currentState?: ProductActivityStage
    createdAt?: Date | string
    updatedAt?: Date | string
    Team?: TeamCreateNestedManyWithoutProductInput
    service?: ServiceCreateNestedOneWithoutProductsInput
    user: UserCreateNestedOneWithoutProductInput
    Payment?: PaymentCreateNestedManyWithoutProductsInput
    productQA?: ProductQACreateNestedManyWithoutProductsInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    email?: string | null
    address?: string | null
    paid?: boolean
    completed?: boolean
    status?: string
    currentState?: ProductActivityStage
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceId?: string | null
    userId: string
    Team?: TeamUncheckedCreateNestedManyWithoutProductInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutProductsInput
    productQA?: ProductQAUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    currentState?: EnumProductActivityStageFieldUpdateOperationsInput | ProductActivityStage
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Team?: TeamUpdateManyWithoutProductNestedInput
    service?: ServiceUpdateOneWithoutProductsNestedInput
    user?: UserUpdateOneRequiredWithoutProductNestedInput
    Payment?: PaymentUpdateManyWithoutProductsNestedInput
    productQA?: ProductQAUpdateManyWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    currentState?: EnumProductActivityStageFieldUpdateOperationsInput | ProductActivityStage
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    Team?: TeamUncheckedUpdateManyWithoutProductNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutProductsNestedInput
    productQA?: ProductQAUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    email?: string | null
    address?: string | null
    paid?: boolean
    completed?: boolean
    status?: string
    currentState?: ProductActivityStage
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceId?: string | null
    userId: string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    currentState?: EnumProductActivityStageFieldUpdateOperationsInput | ProductActivityStage
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    currentState?: EnumProductActivityStageFieldUpdateOperationsInput | ProductActivityStage
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductQACreateInput = {
    id?: string
    question: string
    answer?: ProductQACreateanswerInput | Enumerable<string>
    type: string
    compulsory?: boolean
    isGeneral?: boolean
    fileName: string
    fileDescription: string
    fileType: string
    fileLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products: ProductCreateNestedOneWithoutProductQAInput
    productSubForm?: ProductQASubFormCreateNestedManyWithoutProductQAInput
  }

  export type ProductQAUncheckedCreateInput = {
    id?: string
    question: string
    answer?: ProductQACreateanswerInput | Enumerable<string>
    type: string
    compulsory?: boolean
    isGeneral?: boolean
    fileName: string
    fileDescription: string
    fileType: string
    fileLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
    productId: string
    productSubForm?: ProductQASubFormUncheckedCreateNestedManyWithoutProductQAInput
  }

  export type ProductQAUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: ProductQAUpdateanswerInput | Enumerable<string>
    type?: StringFieldUpdateOperationsInput | string
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    isGeneral?: BoolFieldUpdateOperationsInput | boolean
    fileName?: StringFieldUpdateOperationsInput | string
    fileDescription?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateOneRequiredWithoutProductQANestedInput
    productSubForm?: ProductQASubFormUpdateManyWithoutProductQANestedInput
  }

  export type ProductQAUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: ProductQAUpdateanswerInput | Enumerable<string>
    type?: StringFieldUpdateOperationsInput | string
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    isGeneral?: BoolFieldUpdateOperationsInput | boolean
    fileName?: StringFieldUpdateOperationsInput | string
    fileDescription?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: StringFieldUpdateOperationsInput | string
    productSubForm?: ProductQASubFormUncheckedUpdateManyWithoutProductQANestedInput
  }

  export type ProductQACreateManyInput = {
    id?: string
    question: string
    answer?: ProductQACreateanswerInput | Enumerable<string>
    type: string
    compulsory?: boolean
    isGeneral?: boolean
    fileName: string
    fileDescription: string
    fileType: string
    fileLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
    productId: string
  }

  export type ProductQAUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: ProductQAUpdateanswerInput | Enumerable<string>
    type?: StringFieldUpdateOperationsInput | string
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    isGeneral?: BoolFieldUpdateOperationsInput | boolean
    fileName?: StringFieldUpdateOperationsInput | string
    fileDescription?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductQAUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: ProductQAUpdateanswerInput | Enumerable<string>
    type?: StringFieldUpdateOperationsInput | string
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    isGeneral?: BoolFieldUpdateOperationsInput | boolean
    fileName?: StringFieldUpdateOperationsInput | string
    fileDescription?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductQASubFormCreateInput = {
    id?: string
    question: string
    answer?: ProductQASubFormCreateanswerInput | Enumerable<string>
    type: string
    compulsory?: boolean
    productQA: ProductQACreateNestedOneWithoutProductSubFormInput
  }

  export type ProductQASubFormUncheckedCreateInput = {
    id?: string
    question: string
    answer?: ProductQASubFormCreateanswerInput | Enumerable<string>
    type: string
    compulsory?: boolean
    productQAId: string
  }

  export type ProductQASubFormUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: ProductQASubFormUpdateanswerInput | Enumerable<string>
    type?: StringFieldUpdateOperationsInput | string
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    productQA?: ProductQAUpdateOneRequiredWithoutProductSubFormNestedInput
  }

  export type ProductQASubFormUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: ProductQASubFormUpdateanswerInput | Enumerable<string>
    type?: StringFieldUpdateOperationsInput | string
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    productQAId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductQASubFormCreateManyInput = {
    id?: string
    question: string
    answer?: ProductQASubFormCreateanswerInput | Enumerable<string>
    type: string
    compulsory?: boolean
    productQAId: string
  }

  export type ProductQASubFormUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: ProductQASubFormUpdateanswerInput | Enumerable<string>
    type?: StringFieldUpdateOperationsInput | string
    compulsory?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductQASubFormUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: ProductQASubFormUpdateanswerInput | Enumerable<string>
    type?: StringFieldUpdateOperationsInput | string
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    productQAId?: StringFieldUpdateOperationsInput | string
  }

  export type ClaimCreateInput = {
    id?: string
    value: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClaimUncheckedCreateInput = {
    id?: string
    value: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClaimUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClaimUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClaimCreateManyInput = {
    id?: string
    value: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClaimUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClaimUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamCreateInput = {
    id?: string
    name: string
    slug: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutTeamInput
    invitation?: InvitationCreateNestedManyWithoutTeamInput
    teamMember?: TeamMemberCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    productId: string
    invitation?: InvitationUncheckedCreateNestedManyWithoutTeamInput
    teamMember?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutTeamNestedInput
    invitation?: InvitationUpdateManyWithoutTeamNestedInput
    teamMember?: TeamMemberUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: StringFieldUpdateOperationsInput | string
    invitation?: InvitationUncheckedUpdateManyWithoutTeamNestedInput
    teamMember?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamCreateManyInput = {
    id?: string
    name: string
    slug: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    productId: string
  }

  export type TeamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type TeamMemberCreateInput = {
    id?: string
    isLaunchMember: boolean
    isLaunchController: boolean
    isLaunchOwner: boolean
    launchOwnership: number
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutTeamMemberInput
    user: UserCreateNestedOneWithoutTeamMemberInput
  }

  export type TeamMemberUncheckedCreateInput = {
    id?: string
    isLaunchMember: boolean
    isLaunchController: boolean
    isLaunchOwner: boolean
    launchOwnership: number
    teamId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isLaunchMember?: BoolFieldUpdateOperationsInput | boolean
    isLaunchController?: BoolFieldUpdateOperationsInput | boolean
    isLaunchOwner?: BoolFieldUpdateOperationsInput | boolean
    launchOwnership?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutTeamMemberNestedInput
    user?: UserUpdateOneRequiredWithoutTeamMemberNestedInput
  }

  export type TeamMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isLaunchMember?: BoolFieldUpdateOperationsInput | boolean
    isLaunchController?: BoolFieldUpdateOperationsInput | boolean
    isLaunchOwner?: BoolFieldUpdateOperationsInput | boolean
    launchOwnership?: IntFieldUpdateOperationsInput | number
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberCreateManyInput = {
    id?: string
    isLaunchMember: boolean
    isLaunchController: boolean
    isLaunchOwner: boolean
    launchOwnership: number
    teamId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isLaunchMember?: BoolFieldUpdateOperationsInput | boolean
    isLaunchController?: BoolFieldUpdateOperationsInput | boolean
    isLaunchOwner?: BoolFieldUpdateOperationsInput | boolean
    launchOwnership?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isLaunchMember?: BoolFieldUpdateOperationsInput | boolean
    isLaunchController?: BoolFieldUpdateOperationsInput | boolean
    isLaunchOwner?: BoolFieldUpdateOperationsInput | boolean
    launchOwnership?: IntFieldUpdateOperationsInput | number
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationCreateInput = {
    id?: string
    email: string
    token: string
    expireIn: Date | string
    invitedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutInvitationInput
  }

  export type InvitationUncheckedCreateInput = {
    id?: string
    teamId: string
    email: string
    token: string
    expireIn: Date | string
    invitedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expireIn?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutInvitationNestedInput
  }

  export type InvitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expireIn?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationCreateManyInput = {
    id?: string
    teamId: string
    email: string
    token: string
    expireIn: Date | string
    invitedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expireIn?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expireIn?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    provider: string
    transactionId: string
    status: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products: ProductCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    provider: string
    transactionId: string
    status: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    productId: string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateOneRequiredWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    provider: string
    transactionId: string
    status: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    productId: string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type ParterCreateInput = {
    id?: string
    isVerified: boolean
    verificationDocument?: ParterCreateverificationDocumentInput | Enumerable<string>
    serviceScore: number
    paymentsMade: number
    paymentsDue: number
    paymentDetails?: ParterCreatepaymentDetailsInput | Enumerable<string>
    countrySupported?: ParterCreatecountrySupportedInput | Enumerable<string>
    serviceSupported?: ParterCreateserviceSupportedInput | Enumerable<string>
    servicesAssigned?: ParterCreateservicesAssignedInput | Enumerable<string>
    servicesCompleted?: ParterCreateservicesCompletedInput | Enumerable<string>
    servicesDeclined?: ParterCreateservicesDeclinedInput | Enumerable<string>
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParterUncheckedCreateInput = {
    id?: string
    isVerified: boolean
    verificationDocument?: ParterCreateverificationDocumentInput | Enumerable<string>
    serviceScore: number
    paymentsMade: number
    paymentsDue: number
    paymentDetails?: ParterCreatepaymentDetailsInput | Enumerable<string>
    countrySupported?: ParterCreatecountrySupportedInput | Enumerable<string>
    serviceSupported?: ParterCreateserviceSupportedInput | Enumerable<string>
    servicesAssigned?: ParterCreateservicesAssignedInput | Enumerable<string>
    servicesCompleted?: ParterCreateservicesCompletedInput | Enumerable<string>
    servicesDeclined?: ParterCreateservicesDeclinedInput | Enumerable<string>
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationDocument?: ParterUpdateverificationDocumentInput | Enumerable<string>
    serviceScore?: IntFieldUpdateOperationsInput | number
    paymentsMade?: IntFieldUpdateOperationsInput | number
    paymentsDue?: IntFieldUpdateOperationsInput | number
    paymentDetails?: ParterUpdatepaymentDetailsInput | Enumerable<string>
    countrySupported?: ParterUpdatecountrySupportedInput | Enumerable<string>
    serviceSupported?: ParterUpdateserviceSupportedInput | Enumerable<string>
    servicesAssigned?: ParterUpdateservicesAssignedInput | Enumerable<string>
    servicesCompleted?: ParterUpdateservicesCompletedInput | Enumerable<string>
    servicesDeclined?: ParterUpdateservicesDeclinedInput | Enumerable<string>
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationDocument?: ParterUpdateverificationDocumentInput | Enumerable<string>
    serviceScore?: IntFieldUpdateOperationsInput | number
    paymentsMade?: IntFieldUpdateOperationsInput | number
    paymentsDue?: IntFieldUpdateOperationsInput | number
    paymentDetails?: ParterUpdatepaymentDetailsInput | Enumerable<string>
    countrySupported?: ParterUpdatecountrySupportedInput | Enumerable<string>
    serviceSupported?: ParterUpdateserviceSupportedInput | Enumerable<string>
    servicesAssigned?: ParterUpdateservicesAssignedInput | Enumerable<string>
    servicesCompleted?: ParterUpdateservicesCompletedInput | Enumerable<string>
    servicesDeclined?: ParterUpdateservicesDeclinedInput | Enumerable<string>
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParterCreateManyInput = {
    id?: string
    isVerified: boolean
    verificationDocument?: ParterCreateverificationDocumentInput | Enumerable<string>
    serviceScore: number
    paymentsMade: number
    paymentsDue: number
    paymentDetails?: ParterCreatepaymentDetailsInput | Enumerable<string>
    countrySupported?: ParterCreatecountrySupportedInput | Enumerable<string>
    serviceSupported?: ParterCreateserviceSupportedInput | Enumerable<string>
    servicesAssigned?: ParterCreateservicesAssignedInput | Enumerable<string>
    servicesCompleted?: ParterCreateservicesCompletedInput | Enumerable<string>
    servicesDeclined?: ParterCreateservicesDeclinedInput | Enumerable<string>
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationDocument?: ParterUpdateverificationDocumentInput | Enumerable<string>
    serviceScore?: IntFieldUpdateOperationsInput | number
    paymentsMade?: IntFieldUpdateOperationsInput | number
    paymentsDue?: IntFieldUpdateOperationsInput | number
    paymentDetails?: ParterUpdatepaymentDetailsInput | Enumerable<string>
    countrySupported?: ParterUpdatecountrySupportedInput | Enumerable<string>
    serviceSupported?: ParterUpdateserviceSupportedInput | Enumerable<string>
    servicesAssigned?: ParterUpdateservicesAssignedInput | Enumerable<string>
    servicesCompleted?: ParterUpdateservicesCompletedInput | Enumerable<string>
    servicesDeclined?: ParterUpdateservicesDeclinedInput | Enumerable<string>
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationDocument?: ParterUpdateverificationDocumentInput | Enumerable<string>
    serviceScore?: IntFieldUpdateOperationsInput | number
    paymentsMade?: IntFieldUpdateOperationsInput | number
    paymentsDue?: IntFieldUpdateOperationsInput | number
    paymentDetails?: ParterUpdatepaymentDetailsInput | Enumerable<string>
    countrySupported?: ParterUpdatecountrySupportedInput | Enumerable<string>
    serviceSupported?: ParterUpdateserviceSupportedInput | Enumerable<string>
    servicesAssigned?: ParterUpdateservicesAssignedInput | Enumerable<string>
    servicesCompleted?: ParterUpdateservicesCompletedInput | Enumerable<string>
    servicesDeclined?: ParterUpdateservicesDeclinedInput | Enumerable<string>
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type StaffCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    verified?: SortOrder
    picture?: SortOrder
    resetToken?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    verified?: SortOrder
    picture?: SortOrder
    resetToken?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    verified?: SortOrder
    picture?: SortOrder
    resetToken?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type CollaboratorDocumentListRelationFilter = {
    every?: CollaboratorDocumentWhereInput
    some?: CollaboratorDocumentWhereInput
    none?: CollaboratorDocumentWhereInput
  }

  export type CollaboratorDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CollaboratorCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    picture?: SortOrder
    verified?: SortOrder
    isPartner?: SortOrder
    resetToken?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CollaboratorMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    picture?: SortOrder
    verified?: SortOrder
    isPartner?: SortOrder
    resetToken?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CollaboratorMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    picture?: SortOrder
    verified?: SortOrder
    isPartner?: SortOrder
    resetToken?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CollaboratorRelationFilter = {
    is?: CollaboratorWhereInput | null
    isNot?: CollaboratorWhereInput | null
  }

  export type CollaboratorDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    collaboratorId?: SortOrder
  }

  export type CollaboratorDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    collaboratorId?: SortOrder
  }

  export type CollaboratorDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    collaboratorId?: SortOrder
  }

  export type RewardCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    descrition?: SortOrder
    image?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RewardMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    descrition?: SortOrder
    image?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RewardMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    descrition?: SortOrder
    image?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CountryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    iso?: SortOrder
    currency?: SortOrder
    code?: SortOrder
    flagUrl?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CountryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    iso?: SortOrder
    currency?: SortOrder
    code?: SortOrder
    flagUrl?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CountryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    iso?: SortOrder
    currency?: SortOrder
    code?: SortOrder
    flagUrl?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    url?: SortOrder
    image?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    url?: SortOrder
    image?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    url?: SortOrder
    image?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    body?: SortOrder
    readStatus?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    body?: SortOrder
    readStatus?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    body?: SortOrder
    readStatus?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    scope?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    scope?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    scope?: SortOrder
  }

  export type StringNullableListFilter = {
    equals?: Enumerable<string> | null
    has?: string | null
    hasEvery?: Enumerable<string>
    hasSome?: Enumerable<string>
    isEmpty?: boolean
  }

  export type TeamMemberListRelationFilter = {
    every?: TeamMemberWhereInput
    some?: TeamMemberWhereInput
    none?: TeamMemberWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type TeamMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    picture?: SortOrder
    isVerified?: SortOrder
    referral?: SortOrder
    country?: SortOrder
    resetToken?: SortOrder
    isPartner?: SortOrder
    isStaff?: SortOrder
    isPhoneRegistered?: SortOrder
    isPhoneVerified?: SortOrder
    isIdentificationRegistered?: SortOrder
    isIdentificationVerified?: SortOrder
    partnerPermission?: SortOrder
    staffPermission?: SortOrder
    userPermission?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    picture?: SortOrder
    isVerified?: SortOrder
    referral?: SortOrder
    country?: SortOrder
    resetToken?: SortOrder
    isPartner?: SortOrder
    isStaff?: SortOrder
    isPhoneRegistered?: SortOrder
    isPhoneVerified?: SortOrder
    isIdentificationRegistered?: SortOrder
    isIdentificationVerified?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    picture?: SortOrder
    isVerified?: SortOrder
    referral?: SortOrder
    country?: SortOrder
    resetToken?: SortOrder
    isPartner?: SortOrder
    isStaff?: SortOrder
    isPhoneRegistered?: SortOrder
    isPhoneVerified?: SortOrder
    isIdentificationRegistered?: SortOrder
    isIdentificationVerified?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceListRelationFilter = {
    every?: ServiceWhereInput
    some?: ServiceWhereInput
    none?: ServiceWhereInput
  }

  export type ServiceCategoryFormListRelationFilter = {
    every?: ServiceCategoryFormWhereInput
    some?: ServiceCategoryFormWhereInput
    none?: ServiceCategoryFormWhereInput
  }

  export type ServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceCategoryFormOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isDeprecated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceCategoryRelationFilter = {
    is?: ServiceCategoryWhereInput | null
    isNot?: ServiceCategoryWhereInput | null
  }

  export type ServiceCategoryFormCountOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    type?: SortOrder
    options?: SortOrder
    compulsory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceCategoryId?: SortOrder
  }

  export type ServiceCategoryFormMaxOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    type?: SortOrder
    compulsory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceCategoryId?: SortOrder
  }

  export type ServiceCategoryFormMinOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    type?: SortOrder
    compulsory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceCategoryId?: SortOrder
  }

  export type ServiceTemplateListRelationFilter = {
    every?: ServiceTemplateWhereInput
    some?: ServiceTemplateWhereInput
    none?: ServiceTemplateWhereInput
  }

  export type ServiceFormListRelationFilter = {
    every?: ServiceFormWhereInput
    some?: ServiceFormWhereInput
    none?: ServiceFormWhereInput
  }

  export type ServiceTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceFormOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    code?: SortOrder
    description?: SortOrder
    country?: SortOrder
    price?: SortOrder
    timeline?: SortOrder
    feature?: SortOrder
    categoryForm?: SortOrder
    hasShares?: SortOrder
    numberOfShares?: SortOrder
    hasAgent?: SortOrder
    hasOwner?: SortOrder
    hasController?: SortOrder
    controllerIsCalled?: SortOrder
    OwnerIsCalled?: SortOrder
    agentIsCalled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceCategoryId?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    code?: SortOrder
    description?: SortOrder
    country?: SortOrder
    price?: SortOrder
    timeline?: SortOrder
    hasShares?: SortOrder
    numberOfShares?: SortOrder
    hasAgent?: SortOrder
    hasOwner?: SortOrder
    hasController?: SortOrder
    controllerIsCalled?: SortOrder
    OwnerIsCalled?: SortOrder
    agentIsCalled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceCategoryId?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    code?: SortOrder
    description?: SortOrder
    country?: SortOrder
    price?: SortOrder
    timeline?: SortOrder
    hasShares?: SortOrder
    numberOfShares?: SortOrder
    hasAgent?: SortOrder
    hasOwner?: SortOrder
    hasController?: SortOrder
    controllerIsCalled?: SortOrder
    OwnerIsCalled?: SortOrder
    agentIsCalled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceCategoryId?: SortOrder
  }

  export type ServiceRelationFilter = {
    is?: ServiceWhereInput | null
    isNot?: ServiceWhereInput | null
  }

  export type ServiceTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceId?: SortOrder
  }

  export type ServiceTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceId?: SortOrder
  }

  export type ServiceTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceId?: SortOrder
  }

  export type ServiceSubFormListRelationFilter = {
    every?: ServiceSubFormWhereInput
    some?: ServiceSubFormWhereInput
    none?: ServiceSubFormWhereInput
  }

  export type ServiceSubFormOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceFormCountOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    type?: SortOrder
    options?: SortOrder
    compulsory?: SortOrder
    fileName?: SortOrder
    fileDescription?: SortOrder
    fileType?: SortOrder
    fileLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceId?: SortOrder
  }

  export type ServiceFormMaxOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    type?: SortOrder
    compulsory?: SortOrder
    fileName?: SortOrder
    fileDescription?: SortOrder
    fileType?: SortOrder
    fileLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceId?: SortOrder
  }

  export type ServiceFormMinOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    type?: SortOrder
    compulsory?: SortOrder
    fileName?: SortOrder
    fileDescription?: SortOrder
    fileType?: SortOrder
    fileLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceId?: SortOrder
  }

  export type ServiceFormRelationFilter = {
    is?: ServiceFormWhereInput | null
    isNot?: ServiceFormWhereInput | null
  }

  export type ServiceSubFormCountOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    options?: SortOrder
    type?: SortOrder
    compulsory?: SortOrder
    fileName?: SortOrder
    fileDescription?: SortOrder
    fileType?: SortOrder
    fileLink?: SortOrder
    serviceFormId?: SortOrder
  }

  export type ServiceSubFormMaxOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    type?: SortOrder
    compulsory?: SortOrder
    fileName?: SortOrder
    fileDescription?: SortOrder
    fileType?: SortOrder
    fileLink?: SortOrder
    serviceFormId?: SortOrder
  }

  export type ServiceSubFormMinOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    type?: SortOrder
    compulsory?: SortOrder
    fileName?: SortOrder
    fileDescription?: SortOrder
    fileType?: SortOrder
    fileLink?: SortOrder
    serviceFormId?: SortOrder
  }

  export type EnumProductActivityStageFilter = {
    equals?: ProductActivityStage
    in?: Enumerable<ProductActivityStage>
    notIn?: Enumerable<ProductActivityStage>
    not?: NestedEnumProductActivityStageFilter | ProductActivityStage
  }

  export type TeamListRelationFilter = {
    every?: TeamWhereInput
    some?: TeamWhereInput
    none?: TeamWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type ProductQAListRelationFilter = {
    every?: ProductQAWhereInput
    some?: ProductQAWhereInput
    none?: ProductQAWhereInput
  }

  export type TeamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductQAOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    address?: SortOrder
    paid?: SortOrder
    completed?: SortOrder
    status?: SortOrder
    currentState?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceId?: SortOrder
    userId?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    address?: SortOrder
    paid?: SortOrder
    completed?: SortOrder
    status?: SortOrder
    currentState?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceId?: SortOrder
    userId?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    address?: SortOrder
    paid?: SortOrder
    completed?: SortOrder
    status?: SortOrder
    currentState?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceId?: SortOrder
    userId?: SortOrder
  }

  export type EnumProductActivityStageWithAggregatesFilter = {
    equals?: ProductActivityStage
    in?: Enumerable<ProductActivityStage>
    notIn?: Enumerable<ProductActivityStage>
    not?: NestedEnumProductActivityStageWithAggregatesFilter | ProductActivityStage
    _count?: NestedIntFilter
    _min?: NestedEnumProductActivityStageFilter
    _max?: NestedEnumProductActivityStageFilter
  }

  export type ProductRelationFilter = {
    is?: ProductWhereInput | null
    isNot?: ProductWhereInput | null
  }

  export type ProductQASubFormListRelationFilter = {
    every?: ProductQASubFormWhereInput
    some?: ProductQASubFormWhereInput
    none?: ProductQASubFormWhereInput
  }

  export type ProductQASubFormOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductQACountOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    type?: SortOrder
    compulsory?: SortOrder
    isGeneral?: SortOrder
    fileName?: SortOrder
    fileDescription?: SortOrder
    fileType?: SortOrder
    fileLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type ProductQAMaxOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    type?: SortOrder
    compulsory?: SortOrder
    isGeneral?: SortOrder
    fileName?: SortOrder
    fileDescription?: SortOrder
    fileType?: SortOrder
    fileLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type ProductQAMinOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    type?: SortOrder
    compulsory?: SortOrder
    isGeneral?: SortOrder
    fileName?: SortOrder
    fileDescription?: SortOrder
    fileType?: SortOrder
    fileLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type ProductQARelationFilter = {
    is?: ProductQAWhereInput | null
    isNot?: ProductQAWhereInput | null
  }

  export type ProductQASubFormCountOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    type?: SortOrder
    compulsory?: SortOrder
    productQAId?: SortOrder
  }

  export type ProductQASubFormMaxOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    type?: SortOrder
    compulsory?: SortOrder
    productQAId?: SortOrder
  }

  export type ProductQASubFormMinOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    type?: SortOrder
    compulsory?: SortOrder
    productQAId?: SortOrder
  }

  export type ClaimCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClaimMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClaimMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvitationListRelationFilter = {
    every?: InvitationWhereInput
    some?: InvitationWhereInput
    none?: InvitationWhereInput
  }

  export type InvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type TeamRelationFilter = {
    is?: TeamWhereInput | null
    isNot?: TeamWhereInput | null
  }

  export type TeamMemberCountOrderByAggregateInput = {
    id?: SortOrder
    isLaunchMember?: SortOrder
    isLaunchController?: SortOrder
    isLaunchOwner?: SortOrder
    launchOwnership?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMemberAvgOrderByAggregateInput = {
    launchOwnership?: SortOrder
  }

  export type TeamMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    isLaunchMember?: SortOrder
    isLaunchController?: SortOrder
    isLaunchOwner?: SortOrder
    launchOwnership?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMemberMinOrderByAggregateInput = {
    id?: SortOrder
    isLaunchMember?: SortOrder
    isLaunchController?: SortOrder
    isLaunchOwner?: SortOrder
    launchOwnership?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMemberSumOrderByAggregateInput = {
    launchOwnership?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type InvitationCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expireIn?: SortOrder
    invitedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expireIn?: SortOrder
    invitedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvitationMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expireIn?: SortOrder
    invitedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type ParterCountOrderByAggregateInput = {
    id?: SortOrder
    isVerified?: SortOrder
    verificationDocument?: SortOrder
    serviceScore?: SortOrder
    paymentsMade?: SortOrder
    paymentsDue?: SortOrder
    paymentDetails?: SortOrder
    countrySupported?: SortOrder
    serviceSupported?: SortOrder
    servicesAssigned?: SortOrder
    servicesCompleted?: SortOrder
    servicesDeclined?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParterAvgOrderByAggregateInput = {
    serviceScore?: SortOrder
    paymentsMade?: SortOrder
    paymentsDue?: SortOrder
  }

  export type ParterMaxOrderByAggregateInput = {
    id?: SortOrder
    isVerified?: SortOrder
    serviceScore?: SortOrder
    paymentsMade?: SortOrder
    paymentsDue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParterMinOrderByAggregateInput = {
    id?: SortOrder
    isVerified?: SortOrder
    serviceScore?: SortOrder
    paymentsMade?: SortOrder
    paymentsDue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParterSumOrderByAggregateInput = {
    serviceScore?: SortOrder
    paymentsMade?: SortOrder
    paymentsDue?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CollaboratorDocumentCreateNestedManyWithoutCollaboratorInput = {
    create?: XOR<Enumerable<CollaboratorDocumentCreateWithoutCollaboratorInput>, Enumerable<CollaboratorDocumentUncheckedCreateWithoutCollaboratorInput>>
    connectOrCreate?: Enumerable<CollaboratorDocumentCreateOrConnectWithoutCollaboratorInput>
    createMany?: CollaboratorDocumentCreateManyCollaboratorInputEnvelope
    connect?: Enumerable<CollaboratorDocumentWhereUniqueInput>
  }

  export type CollaboratorDocumentUncheckedCreateNestedManyWithoutCollaboratorInput = {
    create?: XOR<Enumerable<CollaboratorDocumentCreateWithoutCollaboratorInput>, Enumerable<CollaboratorDocumentUncheckedCreateWithoutCollaboratorInput>>
    connectOrCreate?: Enumerable<CollaboratorDocumentCreateOrConnectWithoutCollaboratorInput>
    createMany?: CollaboratorDocumentCreateManyCollaboratorInputEnvelope
    connect?: Enumerable<CollaboratorDocumentWhereUniqueInput>
  }

  export type CollaboratorDocumentUpdateManyWithoutCollaboratorNestedInput = {
    create?: XOR<Enumerable<CollaboratorDocumentCreateWithoutCollaboratorInput>, Enumerable<CollaboratorDocumentUncheckedCreateWithoutCollaboratorInput>>
    connectOrCreate?: Enumerable<CollaboratorDocumentCreateOrConnectWithoutCollaboratorInput>
    upsert?: Enumerable<CollaboratorDocumentUpsertWithWhereUniqueWithoutCollaboratorInput>
    createMany?: CollaboratorDocumentCreateManyCollaboratorInputEnvelope
    set?: Enumerable<CollaboratorDocumentWhereUniqueInput>
    disconnect?: Enumerable<CollaboratorDocumentWhereUniqueInput>
    delete?: Enumerable<CollaboratorDocumentWhereUniqueInput>
    connect?: Enumerable<CollaboratorDocumentWhereUniqueInput>
    update?: Enumerable<CollaboratorDocumentUpdateWithWhereUniqueWithoutCollaboratorInput>
    updateMany?: Enumerable<CollaboratorDocumentUpdateManyWithWhereWithoutCollaboratorInput>
    deleteMany?: Enumerable<CollaboratorDocumentScalarWhereInput>
  }

  export type CollaboratorDocumentUncheckedUpdateManyWithoutCollaboratorNestedInput = {
    create?: XOR<Enumerable<CollaboratorDocumentCreateWithoutCollaboratorInput>, Enumerable<CollaboratorDocumentUncheckedCreateWithoutCollaboratorInput>>
    connectOrCreate?: Enumerable<CollaboratorDocumentCreateOrConnectWithoutCollaboratorInput>
    upsert?: Enumerable<CollaboratorDocumentUpsertWithWhereUniqueWithoutCollaboratorInput>
    createMany?: CollaboratorDocumentCreateManyCollaboratorInputEnvelope
    set?: Enumerable<CollaboratorDocumentWhereUniqueInput>
    disconnect?: Enumerable<CollaboratorDocumentWhereUniqueInput>
    delete?: Enumerable<CollaboratorDocumentWhereUniqueInput>
    connect?: Enumerable<CollaboratorDocumentWhereUniqueInput>
    update?: Enumerable<CollaboratorDocumentUpdateWithWhereUniqueWithoutCollaboratorInput>
    updateMany?: Enumerable<CollaboratorDocumentUpdateManyWithWhereWithoutCollaboratorInput>
    deleteMany?: Enumerable<CollaboratorDocumentScalarWhereInput>
  }

  export type CollaboratorCreateNestedOneWithoutCollaboratorDocumentInput = {
    create?: XOR<CollaboratorCreateWithoutCollaboratorDocumentInput, CollaboratorUncheckedCreateWithoutCollaboratorDocumentInput>
    connectOrCreate?: CollaboratorCreateOrConnectWithoutCollaboratorDocumentInput
    connect?: CollaboratorWhereUniqueInput
  }

  export type CollaboratorUpdateOneRequiredWithoutCollaboratorDocumentNestedInput = {
    create?: XOR<CollaboratorCreateWithoutCollaboratorDocumentInput, CollaboratorUncheckedCreateWithoutCollaboratorDocumentInput>
    connectOrCreate?: CollaboratorCreateOrConnectWithoutCollaboratorDocumentInput
    upsert?: CollaboratorUpsertWithoutCollaboratorDocumentInput
    connect?: CollaboratorWhereUniqueInput
    update?: XOR<CollaboratorUpdateWithoutCollaboratorDocumentInput, CollaboratorUncheckedUpdateWithoutCollaboratorDocumentInput>
  }

  export type UserCreateNestedOneWithoutAccountInput = {
    create?: XOR<UserCreateWithoutAccountInput, UserUncheckedCreateWithoutAccountInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccountNestedInput = {
    create?: XOR<UserCreateWithoutAccountInput, UserUncheckedCreateWithoutAccountInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountInput
    upsert?: UserUpsertWithoutAccountInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAccountInput, UserUncheckedUpdateWithoutAccountInput>
  }

  export type UserCreatepartnerPermissionInput = {
    set: Enumerable<string>
  }

  export type UserCreatestaffPermissionInput = {
    set: Enumerable<string>
  }

  export type UserCreateuserPermissionInput = {
    set: Enumerable<string>
  }

  export type TeamMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TeamMemberCreateWithoutUserInput>, Enumerable<TeamMemberUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TeamMemberCreateOrConnectWithoutUserInput>
    createMany?: TeamMemberCreateManyUserInputEnvelope
    connect?: Enumerable<TeamMemberWhereUniqueInput>
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: Enumerable<AccountWhereUniqueInput>
  }

  export type ProductCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ProductCreateWithoutUserInput>, Enumerable<ProductUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutUserInput>
    createMany?: ProductCreateManyUserInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type TeamMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TeamMemberCreateWithoutUserInput>, Enumerable<TeamMemberUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TeamMemberCreateOrConnectWithoutUserInput>
    createMany?: TeamMemberCreateManyUserInputEnvelope
    connect?: Enumerable<TeamMemberWhereUniqueInput>
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: Enumerable<AccountWhereUniqueInput>
  }

  export type ProductUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ProductCreateWithoutUserInput>, Enumerable<ProductUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutUserInput>
    createMany?: ProductCreateManyUserInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type UserUpdatepartnerPermissionInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type UserUpdatestaffPermissionInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type UserUpdateuserPermissionInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type TeamMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<TeamMemberCreateWithoutUserInput>, Enumerable<TeamMemberUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TeamMemberCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TeamMemberUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TeamMemberCreateManyUserInputEnvelope
    set?: Enumerable<TeamMemberWhereUniqueInput>
    disconnect?: Enumerable<TeamMemberWhereUniqueInput>
    delete?: Enumerable<TeamMemberWhereUniqueInput>
    connect?: Enumerable<TeamMemberWhereUniqueInput>
    update?: Enumerable<TeamMemberUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TeamMemberUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TeamMemberScalarWhereInput>
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AccountUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    set?: Enumerable<AccountWhereUniqueInput>
    disconnect?: Enumerable<AccountWhereUniqueInput>
    delete?: Enumerable<AccountWhereUniqueInput>
    connect?: Enumerable<AccountWhereUniqueInput>
    update?: Enumerable<AccountUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AccountUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AccountScalarWhereInput>
  }

  export type ProductUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ProductCreateWithoutUserInput>, Enumerable<ProductUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ProductCreateManyUserInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type TeamMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<TeamMemberCreateWithoutUserInput>, Enumerable<TeamMemberUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TeamMemberCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TeamMemberUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TeamMemberCreateManyUserInputEnvelope
    set?: Enumerable<TeamMemberWhereUniqueInput>
    disconnect?: Enumerable<TeamMemberWhereUniqueInput>
    delete?: Enumerable<TeamMemberWhereUniqueInput>
    connect?: Enumerable<TeamMemberWhereUniqueInput>
    update?: Enumerable<TeamMemberUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TeamMemberUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TeamMemberScalarWhereInput>
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AccountUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    set?: Enumerable<AccountWhereUniqueInput>
    disconnect?: Enumerable<AccountWhereUniqueInput>
    delete?: Enumerable<AccountWhereUniqueInput>
    connect?: Enumerable<AccountWhereUniqueInput>
    update?: Enumerable<AccountUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AccountUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AccountScalarWhereInput>
  }

  export type ProductUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ProductCreateWithoutUserInput>, Enumerable<ProductUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ProductCreateManyUserInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type ServiceCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<ServiceCreateWithoutCategoryInput>, Enumerable<ServiceUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<ServiceCreateOrConnectWithoutCategoryInput>
    createMany?: ServiceCreateManyCategoryInputEnvelope
    connect?: Enumerable<ServiceWhereUniqueInput>
  }

  export type ServiceCategoryFormCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<ServiceCategoryFormCreateWithoutCategoryInput>, Enumerable<ServiceCategoryFormUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<ServiceCategoryFormCreateOrConnectWithoutCategoryInput>
    createMany?: ServiceCategoryFormCreateManyCategoryInputEnvelope
    connect?: Enumerable<ServiceCategoryFormWhereUniqueInput>
  }

  export type ServiceUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<ServiceCreateWithoutCategoryInput>, Enumerable<ServiceUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<ServiceCreateOrConnectWithoutCategoryInput>
    createMany?: ServiceCreateManyCategoryInputEnvelope
    connect?: Enumerable<ServiceWhereUniqueInput>
  }

  export type ServiceCategoryFormUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<ServiceCategoryFormCreateWithoutCategoryInput>, Enumerable<ServiceCategoryFormUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<ServiceCategoryFormCreateOrConnectWithoutCategoryInput>
    createMany?: ServiceCategoryFormCreateManyCategoryInputEnvelope
    connect?: Enumerable<ServiceCategoryFormWhereUniqueInput>
  }

  export type ServiceUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<ServiceCreateWithoutCategoryInput>, Enumerable<ServiceUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<ServiceCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<ServiceUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: ServiceCreateManyCategoryInputEnvelope
    set?: Enumerable<ServiceWhereUniqueInput>
    disconnect?: Enumerable<ServiceWhereUniqueInput>
    delete?: Enumerable<ServiceWhereUniqueInput>
    connect?: Enumerable<ServiceWhereUniqueInput>
    update?: Enumerable<ServiceUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<ServiceUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<ServiceScalarWhereInput>
  }

  export type ServiceCategoryFormUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<ServiceCategoryFormCreateWithoutCategoryInput>, Enumerable<ServiceCategoryFormUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<ServiceCategoryFormCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<ServiceCategoryFormUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: ServiceCategoryFormCreateManyCategoryInputEnvelope
    set?: Enumerable<ServiceCategoryFormWhereUniqueInput>
    disconnect?: Enumerable<ServiceCategoryFormWhereUniqueInput>
    delete?: Enumerable<ServiceCategoryFormWhereUniqueInput>
    connect?: Enumerable<ServiceCategoryFormWhereUniqueInput>
    update?: Enumerable<ServiceCategoryFormUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<ServiceCategoryFormUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<ServiceCategoryFormScalarWhereInput>
  }

  export type ServiceUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<ServiceCreateWithoutCategoryInput>, Enumerable<ServiceUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<ServiceCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<ServiceUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: ServiceCreateManyCategoryInputEnvelope
    set?: Enumerable<ServiceWhereUniqueInput>
    disconnect?: Enumerable<ServiceWhereUniqueInput>
    delete?: Enumerable<ServiceWhereUniqueInput>
    connect?: Enumerable<ServiceWhereUniqueInput>
    update?: Enumerable<ServiceUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<ServiceUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<ServiceScalarWhereInput>
  }

  export type ServiceCategoryFormUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<ServiceCategoryFormCreateWithoutCategoryInput>, Enumerable<ServiceCategoryFormUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<ServiceCategoryFormCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<ServiceCategoryFormUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: ServiceCategoryFormCreateManyCategoryInputEnvelope
    set?: Enumerable<ServiceCategoryFormWhereUniqueInput>
    disconnect?: Enumerable<ServiceCategoryFormWhereUniqueInput>
    delete?: Enumerable<ServiceCategoryFormWhereUniqueInput>
    connect?: Enumerable<ServiceCategoryFormWhereUniqueInput>
    update?: Enumerable<ServiceCategoryFormUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<ServiceCategoryFormUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<ServiceCategoryFormScalarWhereInput>
  }

  export type ServiceCategoryFormCreateoptionsInput = {
    set: Enumerable<string>
  }

  export type ServiceCategoryCreateNestedOneWithoutFormInput = {
    create?: XOR<ServiceCategoryCreateWithoutFormInput, ServiceCategoryUncheckedCreateWithoutFormInput>
    connectOrCreate?: ServiceCategoryCreateOrConnectWithoutFormInput
    connect?: ServiceCategoryWhereUniqueInput
  }

  export type ServiceCategoryFormUpdateoptionsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ServiceCategoryUpdateOneRequiredWithoutFormNestedInput = {
    create?: XOR<ServiceCategoryCreateWithoutFormInput, ServiceCategoryUncheckedCreateWithoutFormInput>
    connectOrCreate?: ServiceCategoryCreateOrConnectWithoutFormInput
    upsert?: ServiceCategoryUpsertWithoutFormInput
    connect?: ServiceCategoryWhereUniqueInput
    update?: XOR<ServiceCategoryUpdateWithoutFormInput, ServiceCategoryUncheckedUpdateWithoutFormInput>
  }

  export type ServiceCreatefeatureInput = {
    set: Enumerable<string>
  }

  export type ServiceCreatecategoryFormInput = {
    set: Enumerable<string>
  }

  export type ServiceCategoryCreateNestedOneWithoutServicesInput = {
    create?: XOR<ServiceCategoryCreateWithoutServicesInput, ServiceCategoryUncheckedCreateWithoutServicesInput>
    connectOrCreate?: ServiceCategoryCreateOrConnectWithoutServicesInput
    connect?: ServiceCategoryWhereUniqueInput
  }

  export type ProductCreateNestedManyWithoutServiceInput = {
    create?: XOR<Enumerable<ProductCreateWithoutServiceInput>, Enumerable<ProductUncheckedCreateWithoutServiceInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutServiceInput>
    createMany?: ProductCreateManyServiceInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type ServiceTemplateCreateNestedManyWithoutServiceInput = {
    create?: XOR<Enumerable<ServiceTemplateCreateWithoutServiceInput>, Enumerable<ServiceTemplateUncheckedCreateWithoutServiceInput>>
    connectOrCreate?: Enumerable<ServiceTemplateCreateOrConnectWithoutServiceInput>
    createMany?: ServiceTemplateCreateManyServiceInputEnvelope
    connect?: Enumerable<ServiceTemplateWhereUniqueInput>
  }

  export type ServiceFormCreateNestedManyWithoutServiceInput = {
    create?: XOR<Enumerable<ServiceFormCreateWithoutServiceInput>, Enumerable<ServiceFormUncheckedCreateWithoutServiceInput>>
    connectOrCreate?: Enumerable<ServiceFormCreateOrConnectWithoutServiceInput>
    createMany?: ServiceFormCreateManyServiceInputEnvelope
    connect?: Enumerable<ServiceFormWhereUniqueInput>
  }

  export type ProductUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<Enumerable<ProductCreateWithoutServiceInput>, Enumerable<ProductUncheckedCreateWithoutServiceInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutServiceInput>
    createMany?: ProductCreateManyServiceInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type ServiceTemplateUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<Enumerable<ServiceTemplateCreateWithoutServiceInput>, Enumerable<ServiceTemplateUncheckedCreateWithoutServiceInput>>
    connectOrCreate?: Enumerable<ServiceTemplateCreateOrConnectWithoutServiceInput>
    createMany?: ServiceTemplateCreateManyServiceInputEnvelope
    connect?: Enumerable<ServiceTemplateWhereUniqueInput>
  }

  export type ServiceFormUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<Enumerable<ServiceFormCreateWithoutServiceInput>, Enumerable<ServiceFormUncheckedCreateWithoutServiceInput>>
    connectOrCreate?: Enumerable<ServiceFormCreateOrConnectWithoutServiceInput>
    createMany?: ServiceFormCreateManyServiceInputEnvelope
    connect?: Enumerable<ServiceFormWhereUniqueInput>
  }

  export type ServiceUpdatefeatureInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ServiceUpdatecategoryFormInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ServiceCategoryUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<ServiceCategoryCreateWithoutServicesInput, ServiceCategoryUncheckedCreateWithoutServicesInput>
    connectOrCreate?: ServiceCategoryCreateOrConnectWithoutServicesInput
    upsert?: ServiceCategoryUpsertWithoutServicesInput
    connect?: ServiceCategoryWhereUniqueInput
    update?: XOR<ServiceCategoryUpdateWithoutServicesInput, ServiceCategoryUncheckedUpdateWithoutServicesInput>
  }

  export type ProductUpdateManyWithoutServiceNestedInput = {
    create?: XOR<Enumerable<ProductCreateWithoutServiceInput>, Enumerable<ProductUncheckedCreateWithoutServiceInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutServiceInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutServiceInput>
    createMany?: ProductCreateManyServiceInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutServiceInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutServiceInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type ServiceTemplateUpdateManyWithoutServiceNestedInput = {
    create?: XOR<Enumerable<ServiceTemplateCreateWithoutServiceInput>, Enumerable<ServiceTemplateUncheckedCreateWithoutServiceInput>>
    connectOrCreate?: Enumerable<ServiceTemplateCreateOrConnectWithoutServiceInput>
    upsert?: Enumerable<ServiceTemplateUpsertWithWhereUniqueWithoutServiceInput>
    createMany?: ServiceTemplateCreateManyServiceInputEnvelope
    set?: Enumerable<ServiceTemplateWhereUniqueInput>
    disconnect?: Enumerable<ServiceTemplateWhereUniqueInput>
    delete?: Enumerable<ServiceTemplateWhereUniqueInput>
    connect?: Enumerable<ServiceTemplateWhereUniqueInput>
    update?: Enumerable<ServiceTemplateUpdateWithWhereUniqueWithoutServiceInput>
    updateMany?: Enumerable<ServiceTemplateUpdateManyWithWhereWithoutServiceInput>
    deleteMany?: Enumerable<ServiceTemplateScalarWhereInput>
  }

  export type ServiceFormUpdateManyWithoutServiceNestedInput = {
    create?: XOR<Enumerable<ServiceFormCreateWithoutServiceInput>, Enumerable<ServiceFormUncheckedCreateWithoutServiceInput>>
    connectOrCreate?: Enumerable<ServiceFormCreateOrConnectWithoutServiceInput>
    upsert?: Enumerable<ServiceFormUpsertWithWhereUniqueWithoutServiceInput>
    createMany?: ServiceFormCreateManyServiceInputEnvelope
    set?: Enumerable<ServiceFormWhereUniqueInput>
    disconnect?: Enumerable<ServiceFormWhereUniqueInput>
    delete?: Enumerable<ServiceFormWhereUniqueInput>
    connect?: Enumerable<ServiceFormWhereUniqueInput>
    update?: Enumerable<ServiceFormUpdateWithWhereUniqueWithoutServiceInput>
    updateMany?: Enumerable<ServiceFormUpdateManyWithWhereWithoutServiceInput>
    deleteMany?: Enumerable<ServiceFormScalarWhereInput>
  }

  export type ProductUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<Enumerable<ProductCreateWithoutServiceInput>, Enumerable<ProductUncheckedCreateWithoutServiceInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutServiceInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutServiceInput>
    createMany?: ProductCreateManyServiceInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutServiceInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutServiceInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type ServiceTemplateUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<Enumerable<ServiceTemplateCreateWithoutServiceInput>, Enumerable<ServiceTemplateUncheckedCreateWithoutServiceInput>>
    connectOrCreate?: Enumerable<ServiceTemplateCreateOrConnectWithoutServiceInput>
    upsert?: Enumerable<ServiceTemplateUpsertWithWhereUniqueWithoutServiceInput>
    createMany?: ServiceTemplateCreateManyServiceInputEnvelope
    set?: Enumerable<ServiceTemplateWhereUniqueInput>
    disconnect?: Enumerable<ServiceTemplateWhereUniqueInput>
    delete?: Enumerable<ServiceTemplateWhereUniqueInput>
    connect?: Enumerable<ServiceTemplateWhereUniqueInput>
    update?: Enumerable<ServiceTemplateUpdateWithWhereUniqueWithoutServiceInput>
    updateMany?: Enumerable<ServiceTemplateUpdateManyWithWhereWithoutServiceInput>
    deleteMany?: Enumerable<ServiceTemplateScalarWhereInput>
  }

  export type ServiceFormUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<Enumerable<ServiceFormCreateWithoutServiceInput>, Enumerable<ServiceFormUncheckedCreateWithoutServiceInput>>
    connectOrCreate?: Enumerable<ServiceFormCreateOrConnectWithoutServiceInput>
    upsert?: Enumerable<ServiceFormUpsertWithWhereUniqueWithoutServiceInput>
    createMany?: ServiceFormCreateManyServiceInputEnvelope
    set?: Enumerable<ServiceFormWhereUniqueInput>
    disconnect?: Enumerable<ServiceFormWhereUniqueInput>
    delete?: Enumerable<ServiceFormWhereUniqueInput>
    connect?: Enumerable<ServiceFormWhereUniqueInput>
    update?: Enumerable<ServiceFormUpdateWithWhereUniqueWithoutServiceInput>
    updateMany?: Enumerable<ServiceFormUpdateManyWithWhereWithoutServiceInput>
    deleteMany?: Enumerable<ServiceFormScalarWhereInput>
  }

  export type ServiceCreateNestedOneWithoutTemplatesInput = {
    create?: XOR<ServiceCreateWithoutTemplatesInput, ServiceUncheckedCreateWithoutTemplatesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutTemplatesInput
    connect?: ServiceWhereUniqueInput
  }

  export type ServiceUpdateOneRequiredWithoutTemplatesNestedInput = {
    create?: XOR<ServiceCreateWithoutTemplatesInput, ServiceUncheckedCreateWithoutTemplatesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutTemplatesInput
    upsert?: ServiceUpsertWithoutTemplatesInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<ServiceUpdateWithoutTemplatesInput, ServiceUncheckedUpdateWithoutTemplatesInput>
  }

  export type ServiceFormCreateoptionsInput = {
    set: Enumerable<string>
  }

  export type ServiceCreateNestedOneWithoutFormsInput = {
    create?: XOR<ServiceCreateWithoutFormsInput, ServiceUncheckedCreateWithoutFormsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutFormsInput
    connect?: ServiceWhereUniqueInput
  }

  export type ServiceSubFormCreateNestedManyWithoutServiceFormInput = {
    create?: XOR<Enumerable<ServiceSubFormCreateWithoutServiceFormInput>, Enumerable<ServiceSubFormUncheckedCreateWithoutServiceFormInput>>
    connectOrCreate?: Enumerable<ServiceSubFormCreateOrConnectWithoutServiceFormInput>
    createMany?: ServiceSubFormCreateManyServiceFormInputEnvelope
    connect?: Enumerable<ServiceSubFormWhereUniqueInput>
  }

  export type ServiceSubFormUncheckedCreateNestedManyWithoutServiceFormInput = {
    create?: XOR<Enumerable<ServiceSubFormCreateWithoutServiceFormInput>, Enumerable<ServiceSubFormUncheckedCreateWithoutServiceFormInput>>
    connectOrCreate?: Enumerable<ServiceSubFormCreateOrConnectWithoutServiceFormInput>
    createMany?: ServiceSubFormCreateManyServiceFormInputEnvelope
    connect?: Enumerable<ServiceSubFormWhereUniqueInput>
  }

  export type ServiceFormUpdateoptionsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ServiceUpdateOneRequiredWithoutFormsNestedInput = {
    create?: XOR<ServiceCreateWithoutFormsInput, ServiceUncheckedCreateWithoutFormsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutFormsInput
    upsert?: ServiceUpsertWithoutFormsInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<ServiceUpdateWithoutFormsInput, ServiceUncheckedUpdateWithoutFormsInput>
  }

  export type ServiceSubFormUpdateManyWithoutServiceFormNestedInput = {
    create?: XOR<Enumerable<ServiceSubFormCreateWithoutServiceFormInput>, Enumerable<ServiceSubFormUncheckedCreateWithoutServiceFormInput>>
    connectOrCreate?: Enumerable<ServiceSubFormCreateOrConnectWithoutServiceFormInput>
    upsert?: Enumerable<ServiceSubFormUpsertWithWhereUniqueWithoutServiceFormInput>
    createMany?: ServiceSubFormCreateManyServiceFormInputEnvelope
    set?: Enumerable<ServiceSubFormWhereUniqueInput>
    disconnect?: Enumerable<ServiceSubFormWhereUniqueInput>
    delete?: Enumerable<ServiceSubFormWhereUniqueInput>
    connect?: Enumerable<ServiceSubFormWhereUniqueInput>
    update?: Enumerable<ServiceSubFormUpdateWithWhereUniqueWithoutServiceFormInput>
    updateMany?: Enumerable<ServiceSubFormUpdateManyWithWhereWithoutServiceFormInput>
    deleteMany?: Enumerable<ServiceSubFormScalarWhereInput>
  }

  export type ServiceSubFormUncheckedUpdateManyWithoutServiceFormNestedInput = {
    create?: XOR<Enumerable<ServiceSubFormCreateWithoutServiceFormInput>, Enumerable<ServiceSubFormUncheckedCreateWithoutServiceFormInput>>
    connectOrCreate?: Enumerable<ServiceSubFormCreateOrConnectWithoutServiceFormInput>
    upsert?: Enumerable<ServiceSubFormUpsertWithWhereUniqueWithoutServiceFormInput>
    createMany?: ServiceSubFormCreateManyServiceFormInputEnvelope
    set?: Enumerable<ServiceSubFormWhereUniqueInput>
    disconnect?: Enumerable<ServiceSubFormWhereUniqueInput>
    delete?: Enumerable<ServiceSubFormWhereUniqueInput>
    connect?: Enumerable<ServiceSubFormWhereUniqueInput>
    update?: Enumerable<ServiceSubFormUpdateWithWhereUniqueWithoutServiceFormInput>
    updateMany?: Enumerable<ServiceSubFormUpdateManyWithWhereWithoutServiceFormInput>
    deleteMany?: Enumerable<ServiceSubFormScalarWhereInput>
  }

  export type ServiceSubFormCreateoptionsInput = {
    set: Enumerable<string>
  }

  export type ServiceFormCreateNestedOneWithoutServiceSubFormInput = {
    create?: XOR<ServiceFormCreateWithoutServiceSubFormInput, ServiceFormUncheckedCreateWithoutServiceSubFormInput>
    connectOrCreate?: ServiceFormCreateOrConnectWithoutServiceSubFormInput
    connect?: ServiceFormWhereUniqueInput
  }

  export type ServiceSubFormUpdateoptionsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ServiceFormUpdateOneRequiredWithoutServiceSubFormNestedInput = {
    create?: XOR<ServiceFormCreateWithoutServiceSubFormInput, ServiceFormUncheckedCreateWithoutServiceSubFormInput>
    connectOrCreate?: ServiceFormCreateOrConnectWithoutServiceSubFormInput
    upsert?: ServiceFormUpsertWithoutServiceSubFormInput
    connect?: ServiceFormWhereUniqueInput
    update?: XOR<ServiceFormUpdateWithoutServiceSubFormInput, ServiceFormUncheckedUpdateWithoutServiceSubFormInput>
  }

  export type TeamCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<TeamCreateWithoutProductInput>, Enumerable<TeamUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<TeamCreateOrConnectWithoutProductInput>
    createMany?: TeamCreateManyProductInputEnvelope
    connect?: Enumerable<TeamWhereUniqueInput>
  }

  export type ServiceCreateNestedOneWithoutProductsInput = {
    create?: XOR<ServiceCreateWithoutProductsInput, ServiceUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutProductsInput
    connect?: ServiceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProductInput = {
    create?: XOR<UserCreateWithoutProductInput, UserUncheckedCreateWithoutProductInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductInput
    connect?: UserWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutProductsInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutProductsInput>, Enumerable<PaymentUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutProductsInput>
    createMany?: PaymentCreateManyProductsInputEnvelope
    connect?: Enumerable<PaymentWhereUniqueInput>
  }

  export type ProductQACreateNestedManyWithoutProductsInput = {
    create?: XOR<Enumerable<ProductQACreateWithoutProductsInput>, Enumerable<ProductQAUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<ProductQACreateOrConnectWithoutProductsInput>
    createMany?: ProductQACreateManyProductsInputEnvelope
    connect?: Enumerable<ProductQAWhereUniqueInput>
  }

  export type TeamUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<TeamCreateWithoutProductInput>, Enumerable<TeamUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<TeamCreateOrConnectWithoutProductInput>
    createMany?: TeamCreateManyProductInputEnvelope
    connect?: Enumerable<TeamWhereUniqueInput>
  }

  export type PaymentUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutProductsInput>, Enumerable<PaymentUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutProductsInput>
    createMany?: PaymentCreateManyProductsInputEnvelope
    connect?: Enumerable<PaymentWhereUniqueInput>
  }

  export type ProductQAUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<Enumerable<ProductQACreateWithoutProductsInput>, Enumerable<ProductQAUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<ProductQACreateOrConnectWithoutProductsInput>
    createMany?: ProductQACreateManyProductsInputEnvelope
    connect?: Enumerable<ProductQAWhereUniqueInput>
  }

  export type EnumProductActivityStageFieldUpdateOperationsInput = {
    set?: ProductActivityStage
  }

  export type TeamUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<TeamCreateWithoutProductInput>, Enumerable<TeamUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<TeamCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<TeamUpsertWithWhereUniqueWithoutProductInput>
    createMany?: TeamCreateManyProductInputEnvelope
    set?: Enumerable<TeamWhereUniqueInput>
    disconnect?: Enumerable<TeamWhereUniqueInput>
    delete?: Enumerable<TeamWhereUniqueInput>
    connect?: Enumerable<TeamWhereUniqueInput>
    update?: Enumerable<TeamUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<TeamUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<TeamScalarWhereInput>
  }

  export type ServiceUpdateOneWithoutProductsNestedInput = {
    create?: XOR<ServiceCreateWithoutProductsInput, ServiceUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutProductsInput
    upsert?: ServiceUpsertWithoutProductsInput
    disconnect?: boolean
    delete?: boolean
    connect?: ServiceWhereUniqueInput
    update?: XOR<ServiceUpdateWithoutProductsInput, ServiceUncheckedUpdateWithoutProductsInput>
  }

  export type UserUpdateOneRequiredWithoutProductNestedInput = {
    create?: XOR<UserCreateWithoutProductInput, UserUncheckedCreateWithoutProductInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductInput
    upsert?: UserUpsertWithoutProductInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutProductInput, UserUncheckedUpdateWithoutProductInput>
  }

  export type PaymentUpdateManyWithoutProductsNestedInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutProductsInput>, Enumerable<PaymentUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutProductsInput>
    upsert?: Enumerable<PaymentUpsertWithWhereUniqueWithoutProductsInput>
    createMany?: PaymentCreateManyProductsInputEnvelope
    set?: Enumerable<PaymentWhereUniqueInput>
    disconnect?: Enumerable<PaymentWhereUniqueInput>
    delete?: Enumerable<PaymentWhereUniqueInput>
    connect?: Enumerable<PaymentWhereUniqueInput>
    update?: Enumerable<PaymentUpdateWithWhereUniqueWithoutProductsInput>
    updateMany?: Enumerable<PaymentUpdateManyWithWhereWithoutProductsInput>
    deleteMany?: Enumerable<PaymentScalarWhereInput>
  }

  export type ProductQAUpdateManyWithoutProductsNestedInput = {
    create?: XOR<Enumerable<ProductQACreateWithoutProductsInput>, Enumerable<ProductQAUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<ProductQACreateOrConnectWithoutProductsInput>
    upsert?: Enumerable<ProductQAUpsertWithWhereUniqueWithoutProductsInput>
    createMany?: ProductQACreateManyProductsInputEnvelope
    set?: Enumerable<ProductQAWhereUniqueInput>
    disconnect?: Enumerable<ProductQAWhereUniqueInput>
    delete?: Enumerable<ProductQAWhereUniqueInput>
    connect?: Enumerable<ProductQAWhereUniqueInput>
    update?: Enumerable<ProductQAUpdateWithWhereUniqueWithoutProductsInput>
    updateMany?: Enumerable<ProductQAUpdateManyWithWhereWithoutProductsInput>
    deleteMany?: Enumerable<ProductQAScalarWhereInput>
  }

  export type TeamUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<TeamCreateWithoutProductInput>, Enumerable<TeamUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<TeamCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<TeamUpsertWithWhereUniqueWithoutProductInput>
    createMany?: TeamCreateManyProductInputEnvelope
    set?: Enumerable<TeamWhereUniqueInput>
    disconnect?: Enumerable<TeamWhereUniqueInput>
    delete?: Enumerable<TeamWhereUniqueInput>
    connect?: Enumerable<TeamWhereUniqueInput>
    update?: Enumerable<TeamUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<TeamUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<TeamScalarWhereInput>
  }

  export type PaymentUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutProductsInput>, Enumerable<PaymentUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutProductsInput>
    upsert?: Enumerable<PaymentUpsertWithWhereUniqueWithoutProductsInput>
    createMany?: PaymentCreateManyProductsInputEnvelope
    set?: Enumerable<PaymentWhereUniqueInput>
    disconnect?: Enumerable<PaymentWhereUniqueInput>
    delete?: Enumerable<PaymentWhereUniqueInput>
    connect?: Enumerable<PaymentWhereUniqueInput>
    update?: Enumerable<PaymentUpdateWithWhereUniqueWithoutProductsInput>
    updateMany?: Enumerable<PaymentUpdateManyWithWhereWithoutProductsInput>
    deleteMany?: Enumerable<PaymentScalarWhereInput>
  }

  export type ProductQAUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<Enumerable<ProductQACreateWithoutProductsInput>, Enumerable<ProductQAUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<ProductQACreateOrConnectWithoutProductsInput>
    upsert?: Enumerable<ProductQAUpsertWithWhereUniqueWithoutProductsInput>
    createMany?: ProductQACreateManyProductsInputEnvelope
    set?: Enumerable<ProductQAWhereUniqueInput>
    disconnect?: Enumerable<ProductQAWhereUniqueInput>
    delete?: Enumerable<ProductQAWhereUniqueInput>
    connect?: Enumerable<ProductQAWhereUniqueInput>
    update?: Enumerable<ProductQAUpdateWithWhereUniqueWithoutProductsInput>
    updateMany?: Enumerable<ProductQAUpdateManyWithWhereWithoutProductsInput>
    deleteMany?: Enumerable<ProductQAScalarWhereInput>
  }

  export type ProductQACreateanswerInput = {
    set: Enumerable<string>
  }

  export type ProductCreateNestedOneWithoutProductQAInput = {
    create?: XOR<ProductCreateWithoutProductQAInput, ProductUncheckedCreateWithoutProductQAInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductQAInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductQASubFormCreateNestedManyWithoutProductQAInput = {
    create?: XOR<Enumerable<ProductQASubFormCreateWithoutProductQAInput>, Enumerable<ProductQASubFormUncheckedCreateWithoutProductQAInput>>
    connectOrCreate?: Enumerable<ProductQASubFormCreateOrConnectWithoutProductQAInput>
    createMany?: ProductQASubFormCreateManyProductQAInputEnvelope
    connect?: Enumerable<ProductQASubFormWhereUniqueInput>
  }

  export type ProductQASubFormUncheckedCreateNestedManyWithoutProductQAInput = {
    create?: XOR<Enumerable<ProductQASubFormCreateWithoutProductQAInput>, Enumerable<ProductQASubFormUncheckedCreateWithoutProductQAInput>>
    connectOrCreate?: Enumerable<ProductQASubFormCreateOrConnectWithoutProductQAInput>
    createMany?: ProductQASubFormCreateManyProductQAInputEnvelope
    connect?: Enumerable<ProductQASubFormWhereUniqueInput>
  }

  export type ProductQAUpdateanswerInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ProductUpdateOneRequiredWithoutProductQANestedInput = {
    create?: XOR<ProductCreateWithoutProductQAInput, ProductUncheckedCreateWithoutProductQAInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductQAInput
    upsert?: ProductUpsertWithoutProductQAInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutProductQAInput, ProductUncheckedUpdateWithoutProductQAInput>
  }

  export type ProductQASubFormUpdateManyWithoutProductQANestedInput = {
    create?: XOR<Enumerable<ProductQASubFormCreateWithoutProductQAInput>, Enumerable<ProductQASubFormUncheckedCreateWithoutProductQAInput>>
    connectOrCreate?: Enumerable<ProductQASubFormCreateOrConnectWithoutProductQAInput>
    upsert?: Enumerable<ProductQASubFormUpsertWithWhereUniqueWithoutProductQAInput>
    createMany?: ProductQASubFormCreateManyProductQAInputEnvelope
    set?: Enumerable<ProductQASubFormWhereUniqueInput>
    disconnect?: Enumerable<ProductQASubFormWhereUniqueInput>
    delete?: Enumerable<ProductQASubFormWhereUniqueInput>
    connect?: Enumerable<ProductQASubFormWhereUniqueInput>
    update?: Enumerable<ProductQASubFormUpdateWithWhereUniqueWithoutProductQAInput>
    updateMany?: Enumerable<ProductQASubFormUpdateManyWithWhereWithoutProductQAInput>
    deleteMany?: Enumerable<ProductQASubFormScalarWhereInput>
  }

  export type ProductQASubFormUncheckedUpdateManyWithoutProductQANestedInput = {
    create?: XOR<Enumerable<ProductQASubFormCreateWithoutProductQAInput>, Enumerable<ProductQASubFormUncheckedCreateWithoutProductQAInput>>
    connectOrCreate?: Enumerable<ProductQASubFormCreateOrConnectWithoutProductQAInput>
    upsert?: Enumerable<ProductQASubFormUpsertWithWhereUniqueWithoutProductQAInput>
    createMany?: ProductQASubFormCreateManyProductQAInputEnvelope
    set?: Enumerable<ProductQASubFormWhereUniqueInput>
    disconnect?: Enumerable<ProductQASubFormWhereUniqueInput>
    delete?: Enumerable<ProductQASubFormWhereUniqueInput>
    connect?: Enumerable<ProductQASubFormWhereUniqueInput>
    update?: Enumerable<ProductQASubFormUpdateWithWhereUniqueWithoutProductQAInput>
    updateMany?: Enumerable<ProductQASubFormUpdateManyWithWhereWithoutProductQAInput>
    deleteMany?: Enumerable<ProductQASubFormScalarWhereInput>
  }

  export type ProductQASubFormCreateanswerInput = {
    set: Enumerable<string>
  }

  export type ProductQACreateNestedOneWithoutProductSubFormInput = {
    create?: XOR<ProductQACreateWithoutProductSubFormInput, ProductQAUncheckedCreateWithoutProductSubFormInput>
    connectOrCreate?: ProductQACreateOrConnectWithoutProductSubFormInput
    connect?: ProductQAWhereUniqueInput
  }

  export type ProductQASubFormUpdateanswerInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ProductQAUpdateOneRequiredWithoutProductSubFormNestedInput = {
    create?: XOR<ProductQACreateWithoutProductSubFormInput, ProductQAUncheckedCreateWithoutProductSubFormInput>
    connectOrCreate?: ProductQACreateOrConnectWithoutProductSubFormInput
    upsert?: ProductQAUpsertWithoutProductSubFormInput
    connect?: ProductQAWhereUniqueInput
    update?: XOR<ProductQAUpdateWithoutProductSubFormInput, ProductQAUncheckedUpdateWithoutProductSubFormInput>
  }

  export type ProductCreateNestedOneWithoutTeamInput = {
    create?: XOR<ProductCreateWithoutTeamInput, ProductUncheckedCreateWithoutTeamInput>
    connectOrCreate?: ProductCreateOrConnectWithoutTeamInput
    connect?: ProductWhereUniqueInput
  }

  export type InvitationCreateNestedManyWithoutTeamInput = {
    create?: XOR<Enumerable<InvitationCreateWithoutTeamInput>, Enumerable<InvitationUncheckedCreateWithoutTeamInput>>
    connectOrCreate?: Enumerable<InvitationCreateOrConnectWithoutTeamInput>
    createMany?: InvitationCreateManyTeamInputEnvelope
    connect?: Enumerable<InvitationWhereUniqueInput>
  }

  export type TeamMemberCreateNestedManyWithoutTeamInput = {
    create?: XOR<Enumerable<TeamMemberCreateWithoutTeamInput>, Enumerable<TeamMemberUncheckedCreateWithoutTeamInput>>
    connectOrCreate?: Enumerable<TeamMemberCreateOrConnectWithoutTeamInput>
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    connect?: Enumerable<TeamMemberWhereUniqueInput>
  }

  export type InvitationUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<Enumerable<InvitationCreateWithoutTeamInput>, Enumerable<InvitationUncheckedCreateWithoutTeamInput>>
    connectOrCreate?: Enumerable<InvitationCreateOrConnectWithoutTeamInput>
    createMany?: InvitationCreateManyTeamInputEnvelope
    connect?: Enumerable<InvitationWhereUniqueInput>
  }

  export type TeamMemberUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<Enumerable<TeamMemberCreateWithoutTeamInput>, Enumerable<TeamMemberUncheckedCreateWithoutTeamInput>>
    connectOrCreate?: Enumerable<TeamMemberCreateOrConnectWithoutTeamInput>
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    connect?: Enumerable<TeamMemberWhereUniqueInput>
  }

  export type ProductUpdateOneRequiredWithoutTeamNestedInput = {
    create?: XOR<ProductCreateWithoutTeamInput, ProductUncheckedCreateWithoutTeamInput>
    connectOrCreate?: ProductCreateOrConnectWithoutTeamInput
    upsert?: ProductUpsertWithoutTeamInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutTeamInput, ProductUncheckedUpdateWithoutTeamInput>
  }

  export type InvitationUpdateManyWithoutTeamNestedInput = {
    create?: XOR<Enumerable<InvitationCreateWithoutTeamInput>, Enumerable<InvitationUncheckedCreateWithoutTeamInput>>
    connectOrCreate?: Enumerable<InvitationCreateOrConnectWithoutTeamInput>
    upsert?: Enumerable<InvitationUpsertWithWhereUniqueWithoutTeamInput>
    createMany?: InvitationCreateManyTeamInputEnvelope
    set?: Enumerable<InvitationWhereUniqueInput>
    disconnect?: Enumerable<InvitationWhereUniqueInput>
    delete?: Enumerable<InvitationWhereUniqueInput>
    connect?: Enumerable<InvitationWhereUniqueInput>
    update?: Enumerable<InvitationUpdateWithWhereUniqueWithoutTeamInput>
    updateMany?: Enumerable<InvitationUpdateManyWithWhereWithoutTeamInput>
    deleteMany?: Enumerable<InvitationScalarWhereInput>
  }

  export type TeamMemberUpdateManyWithoutTeamNestedInput = {
    create?: XOR<Enumerable<TeamMemberCreateWithoutTeamInput>, Enumerable<TeamMemberUncheckedCreateWithoutTeamInput>>
    connectOrCreate?: Enumerable<TeamMemberCreateOrConnectWithoutTeamInput>
    upsert?: Enumerable<TeamMemberUpsertWithWhereUniqueWithoutTeamInput>
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    set?: Enumerable<TeamMemberWhereUniqueInput>
    disconnect?: Enumerable<TeamMemberWhereUniqueInput>
    delete?: Enumerable<TeamMemberWhereUniqueInput>
    connect?: Enumerable<TeamMemberWhereUniqueInput>
    update?: Enumerable<TeamMemberUpdateWithWhereUniqueWithoutTeamInput>
    updateMany?: Enumerable<TeamMemberUpdateManyWithWhereWithoutTeamInput>
    deleteMany?: Enumerable<TeamMemberScalarWhereInput>
  }

  export type InvitationUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<Enumerable<InvitationCreateWithoutTeamInput>, Enumerable<InvitationUncheckedCreateWithoutTeamInput>>
    connectOrCreate?: Enumerable<InvitationCreateOrConnectWithoutTeamInput>
    upsert?: Enumerable<InvitationUpsertWithWhereUniqueWithoutTeamInput>
    createMany?: InvitationCreateManyTeamInputEnvelope
    set?: Enumerable<InvitationWhereUniqueInput>
    disconnect?: Enumerable<InvitationWhereUniqueInput>
    delete?: Enumerable<InvitationWhereUniqueInput>
    connect?: Enumerable<InvitationWhereUniqueInput>
    update?: Enumerable<InvitationUpdateWithWhereUniqueWithoutTeamInput>
    updateMany?: Enumerable<InvitationUpdateManyWithWhereWithoutTeamInput>
    deleteMany?: Enumerable<InvitationScalarWhereInput>
  }

  export type TeamMemberUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<Enumerable<TeamMemberCreateWithoutTeamInput>, Enumerable<TeamMemberUncheckedCreateWithoutTeamInput>>
    connectOrCreate?: Enumerable<TeamMemberCreateOrConnectWithoutTeamInput>
    upsert?: Enumerable<TeamMemberUpsertWithWhereUniqueWithoutTeamInput>
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    set?: Enumerable<TeamMemberWhereUniqueInput>
    disconnect?: Enumerable<TeamMemberWhereUniqueInput>
    delete?: Enumerable<TeamMemberWhereUniqueInput>
    connect?: Enumerable<TeamMemberWhereUniqueInput>
    update?: Enumerable<TeamMemberUpdateWithWhereUniqueWithoutTeamInput>
    updateMany?: Enumerable<TeamMemberUpdateManyWithWhereWithoutTeamInput>
    deleteMany?: Enumerable<TeamMemberScalarWhereInput>
  }

  export type TeamCreateNestedOneWithoutTeamMemberInput = {
    create?: XOR<TeamCreateWithoutTeamMemberInput, TeamUncheckedCreateWithoutTeamMemberInput>
    connectOrCreate?: TeamCreateOrConnectWithoutTeamMemberInput
    connect?: TeamWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTeamMemberInput = {
    create?: XOR<UserCreateWithoutTeamMemberInput, UserUncheckedCreateWithoutTeamMemberInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamMemberInput
    connect?: UserWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TeamUpdateOneRequiredWithoutTeamMemberNestedInput = {
    create?: XOR<TeamCreateWithoutTeamMemberInput, TeamUncheckedCreateWithoutTeamMemberInput>
    connectOrCreate?: TeamCreateOrConnectWithoutTeamMemberInput
    upsert?: TeamUpsertWithoutTeamMemberInput
    connect?: TeamWhereUniqueInput
    update?: XOR<TeamUpdateWithoutTeamMemberInput, TeamUncheckedUpdateWithoutTeamMemberInput>
  }

  export type UserUpdateOneRequiredWithoutTeamMemberNestedInput = {
    create?: XOR<UserCreateWithoutTeamMemberInput, UserUncheckedCreateWithoutTeamMemberInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamMemberInput
    upsert?: UserUpsertWithoutTeamMemberInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutTeamMemberInput, UserUncheckedUpdateWithoutTeamMemberInput>
  }

  export type TeamCreateNestedOneWithoutInvitationInput = {
    create?: XOR<TeamCreateWithoutInvitationInput, TeamUncheckedCreateWithoutInvitationInput>
    connectOrCreate?: TeamCreateOrConnectWithoutInvitationInput
    connect?: TeamWhereUniqueInput
  }

  export type TeamUpdateOneRequiredWithoutInvitationNestedInput = {
    create?: XOR<TeamCreateWithoutInvitationInput, TeamUncheckedCreateWithoutInvitationInput>
    connectOrCreate?: TeamCreateOrConnectWithoutInvitationInput
    upsert?: TeamUpsertWithoutInvitationInput
    connect?: TeamWhereUniqueInput
    update?: XOR<TeamUpdateWithoutInvitationInput, TeamUncheckedUpdateWithoutInvitationInput>
  }

  export type ProductCreateNestedOneWithoutPaymentInput = {
    create?: XOR<ProductCreateWithoutPaymentInput, ProductUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPaymentInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutPaymentNestedInput = {
    create?: XOR<ProductCreateWithoutPaymentInput, ProductUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPaymentInput
    upsert?: ProductUpsertWithoutPaymentInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutPaymentInput, ProductUncheckedUpdateWithoutPaymentInput>
  }

  export type ParterCreateverificationDocumentInput = {
    set: Enumerable<string>
  }

  export type ParterCreatepaymentDetailsInput = {
    set: Enumerable<string>
  }

  export type ParterCreatecountrySupportedInput = {
    set: Enumerable<string>
  }

  export type ParterCreateserviceSupportedInput = {
    set: Enumerable<string>
  }

  export type ParterCreateservicesAssignedInput = {
    set: Enumerable<string>
  }

  export type ParterCreateservicesCompletedInput = {
    set: Enumerable<string>
  }

  export type ParterCreateservicesDeclinedInput = {
    set: Enumerable<string>
  }

  export type ParterUpdateverificationDocumentInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ParterUpdatepaymentDetailsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ParterUpdatecountrySupportedInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ParterUpdateserviceSupportedInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ParterUpdateservicesAssignedInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ParterUpdateservicesCompletedInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ParterUpdateservicesDeclinedInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedEnumProductActivityStageFilter = {
    equals?: ProductActivityStage
    in?: Enumerable<ProductActivityStage>
    notIn?: Enumerable<ProductActivityStage>
    not?: NestedEnumProductActivityStageFilter | ProductActivityStage
  }

  export type NestedEnumProductActivityStageWithAggregatesFilter = {
    equals?: ProductActivityStage
    in?: Enumerable<ProductActivityStage>
    notIn?: Enumerable<ProductActivityStage>
    not?: NestedEnumProductActivityStageWithAggregatesFilter | ProductActivityStage
    _count?: NestedIntFilter
    _min?: NestedEnumProductActivityStageFilter
    _max?: NestedEnumProductActivityStageFilter
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type CollaboratorDocumentCreateWithoutCollaboratorInput = {
    id?: string
    name: string
    type: string
    description: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CollaboratorDocumentUncheckedCreateWithoutCollaboratorInput = {
    id?: string
    name: string
    type: string
    description: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CollaboratorDocumentCreateOrConnectWithoutCollaboratorInput = {
    where: CollaboratorDocumentWhereUniqueInput
    create: XOR<CollaboratorDocumentCreateWithoutCollaboratorInput, CollaboratorDocumentUncheckedCreateWithoutCollaboratorInput>
  }

  export type CollaboratorDocumentCreateManyCollaboratorInputEnvelope = {
    data: Enumerable<CollaboratorDocumentCreateManyCollaboratorInput>
    skipDuplicates?: boolean
  }

  export type CollaboratorDocumentUpsertWithWhereUniqueWithoutCollaboratorInput = {
    where: CollaboratorDocumentWhereUniqueInput
    update: XOR<CollaboratorDocumentUpdateWithoutCollaboratorInput, CollaboratorDocumentUncheckedUpdateWithoutCollaboratorInput>
    create: XOR<CollaboratorDocumentCreateWithoutCollaboratorInput, CollaboratorDocumentUncheckedCreateWithoutCollaboratorInput>
  }

  export type CollaboratorDocumentUpdateWithWhereUniqueWithoutCollaboratorInput = {
    where: CollaboratorDocumentWhereUniqueInput
    data: XOR<CollaboratorDocumentUpdateWithoutCollaboratorInput, CollaboratorDocumentUncheckedUpdateWithoutCollaboratorInput>
  }

  export type CollaboratorDocumentUpdateManyWithWhereWithoutCollaboratorInput = {
    where: CollaboratorDocumentScalarWhereInput
    data: XOR<CollaboratorDocumentUpdateManyMutationInput, CollaboratorDocumentUncheckedUpdateManyWithoutCollaboratorDocumentInput>
  }

  export type CollaboratorDocumentScalarWhereInput = {
    AND?: Enumerable<CollaboratorDocumentScalarWhereInput>
    OR?: Enumerable<CollaboratorDocumentScalarWhereInput>
    NOT?: Enumerable<CollaboratorDocumentScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    type?: StringFilter | string
    description?: StringFilter | string
    isDeprecated?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    collaboratorId?: StringFilter | string
  }

  export type CollaboratorCreateWithoutCollaboratorDocumentInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    password: string
    phone: string
    picture?: string | null
    verified: boolean
    isPartner: boolean
    resetToken?: string | null
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CollaboratorUncheckedCreateWithoutCollaboratorDocumentInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    password: string
    phone: string
    picture?: string | null
    verified: boolean
    isPartner: boolean
    resetToken?: string | null
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CollaboratorCreateOrConnectWithoutCollaboratorDocumentInput = {
    where: CollaboratorWhereUniqueInput
    create: XOR<CollaboratorCreateWithoutCollaboratorDocumentInput, CollaboratorUncheckedCreateWithoutCollaboratorDocumentInput>
  }

  export type CollaboratorUpsertWithoutCollaboratorDocumentInput = {
    update: XOR<CollaboratorUpdateWithoutCollaboratorDocumentInput, CollaboratorUncheckedUpdateWithoutCollaboratorDocumentInput>
    create: XOR<CollaboratorCreateWithoutCollaboratorDocumentInput, CollaboratorUncheckedCreateWithoutCollaboratorDocumentInput>
  }

  export type CollaboratorUpdateWithoutCollaboratorDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollaboratorUncheckedUpdateWithoutCollaboratorDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutAccountInput = {
    id?: string
    fullName: string
    username?: string | null
    email: string
    password: string
    phone?: string | null
    picture?: string | null
    isVerified?: boolean
    referral: string
    country?: string | null
    resetToken?: string | null
    isPartner?: boolean
    isStaff?: boolean
    isPhoneRegistered?: boolean
    isPhoneVerified?: boolean
    isIdentificationRegistered?: boolean
    isIdentificationVerified?: boolean
    partnerPermission?: UserCreatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserCreatestaffPermissionInput | Enumerable<string>
    userPermission?: UserCreateuserPermissionInput | Enumerable<string>
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamMember?: TeamMemberCreateNestedManyWithoutUserInput
    product?: ProductCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountInput = {
    id?: string
    fullName: string
    username?: string | null
    email: string
    password: string
    phone?: string | null
    picture?: string | null
    isVerified?: boolean
    referral: string
    country?: string | null
    resetToken?: string | null
    isPartner?: boolean
    isStaff?: boolean
    isPhoneRegistered?: boolean
    isPhoneVerified?: boolean
    isIdentificationRegistered?: boolean
    isIdentificationVerified?: boolean
    partnerPermission?: UserCreatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserCreatestaffPermissionInput | Enumerable<string>
    userPermission?: UserCreateuserPermissionInput | Enumerable<string>
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamMember?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    product?: ProductUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountInput, UserUncheckedCreateWithoutAccountInput>
  }

  export type UserUpsertWithoutAccountInput = {
    update: XOR<UserUpdateWithoutAccountInput, UserUncheckedUpdateWithoutAccountInput>
    create: XOR<UserCreateWithoutAccountInput, UserUncheckedCreateWithoutAccountInput>
  }

  export type UserUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    referral?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    isStaff?: BoolFieldUpdateOperationsInput | boolean
    isPhoneRegistered?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationRegistered?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationVerified?: BoolFieldUpdateOperationsInput | boolean
    partnerPermission?: UserUpdatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserUpdatestaffPermissionInput | Enumerable<string>
    userPermission?: UserUpdateuserPermissionInput | Enumerable<string>
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMember?: TeamMemberUpdateManyWithoutUserNestedInput
    product?: ProductUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    referral?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    isStaff?: BoolFieldUpdateOperationsInput | boolean
    isPhoneRegistered?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationRegistered?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationVerified?: BoolFieldUpdateOperationsInput | boolean
    partnerPermission?: UserUpdatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserUpdatestaffPermissionInput | Enumerable<string>
    userPermission?: UserUpdateuserPermissionInput | Enumerable<string>
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMember?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    product?: ProductUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TeamMemberCreateWithoutUserInput = {
    id?: string
    isLaunchMember: boolean
    isLaunchController: boolean
    isLaunchOwner: boolean
    launchOwnership: number
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutTeamMemberInput
  }

  export type TeamMemberUncheckedCreateWithoutUserInput = {
    id?: string
    isLaunchMember: boolean
    isLaunchController: boolean
    isLaunchOwner: boolean
    launchOwnership: number
    teamId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamMemberCreateOrConnectWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    create: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
  }

  export type TeamMemberCreateManyUserInputEnvelope = {
    data: Enumerable<TeamMemberCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    scope: string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    scope: string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: Enumerable<AccountCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutUserInput = {
    id?: string
    email?: string | null
    address?: string | null
    paid?: boolean
    completed?: boolean
    status?: string
    currentState?: ProductActivityStage
    createdAt?: Date | string
    updatedAt?: Date | string
    Team?: TeamCreateNestedManyWithoutProductInput
    service?: ServiceCreateNestedOneWithoutProductsInput
    Payment?: PaymentCreateNestedManyWithoutProductsInput
    productQA?: ProductQACreateNestedManyWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutUserInput = {
    id?: string
    email?: string | null
    address?: string | null
    paid?: boolean
    completed?: boolean
    status?: string
    currentState?: ProductActivityStage
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceId?: string | null
    Team?: TeamUncheckedCreateNestedManyWithoutProductInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutProductsInput
    productQA?: ProductQAUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductCreateOrConnectWithoutUserInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutUserInput, ProductUncheckedCreateWithoutUserInput>
  }

  export type ProductCreateManyUserInputEnvelope = {
    data: Enumerable<ProductCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type TeamMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    update: XOR<TeamMemberUpdateWithoutUserInput, TeamMemberUncheckedUpdateWithoutUserInput>
    create: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
  }

  export type TeamMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    data: XOR<TeamMemberUpdateWithoutUserInput, TeamMemberUncheckedUpdateWithoutUserInput>
  }

  export type TeamMemberUpdateManyWithWhereWithoutUserInput = {
    where: TeamMemberScalarWhereInput
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyWithoutTeamMemberInput>
  }

  export type TeamMemberScalarWhereInput = {
    AND?: Enumerable<TeamMemberScalarWhereInput>
    OR?: Enumerable<TeamMemberScalarWhereInput>
    NOT?: Enumerable<TeamMemberScalarWhereInput>
    id?: StringFilter | string
    isLaunchMember?: BoolFilter | boolean
    isLaunchController?: BoolFilter | boolean
    isLaunchOwner?: BoolFilter | boolean
    launchOwnership?: IntFilter | number
    teamId?: StringFilter | string
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutAccountInput>
  }

  export type AccountScalarWhereInput = {
    AND?: Enumerable<AccountScalarWhereInput>
    OR?: Enumerable<AccountScalarWhereInput>
    NOT?: Enumerable<AccountScalarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    type?: StringFilter | string
    provider?: StringFilter | string
    scope?: StringFilter | string
  }

  export type ProductUpsertWithWhereUniqueWithoutUserInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutUserInput, ProductUncheckedUpdateWithoutUserInput>
    create: XOR<ProductCreateWithoutUserInput, ProductUncheckedCreateWithoutUserInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutUserInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutUserInput, ProductUncheckedUpdateWithoutUserInput>
  }

  export type ProductUpdateManyWithWhereWithoutUserInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductScalarWhereInput = {
    AND?: Enumerable<ProductScalarWhereInput>
    OR?: Enumerable<ProductScalarWhereInput>
    NOT?: Enumerable<ProductScalarWhereInput>
    id?: StringFilter | string
    email?: StringNullableFilter | string | null
    address?: StringNullableFilter | string | null
    paid?: BoolFilter | boolean
    completed?: BoolFilter | boolean
    status?: StringFilter | string
    currentState?: EnumProductActivityStageFilter | ProductActivityStage
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    serviceId?: StringNullableFilter | string | null
    userId?: StringFilter | string
  }

  export type ServiceCreateWithoutCategoryInput = {
    id?: string
    name: string
    type: string
    code: string
    description: string
    country: string
    price: string
    timeline: string
    feature?: ServiceCreatefeatureInput | Enumerable<string>
    categoryForm?: ServiceCreatecategoryFormInput | Enumerable<string>
    hasShares?: boolean
    numberOfShares: string
    hasAgent?: boolean
    hasOwner?: boolean
    hasController?: boolean
    controllerIsCalled?: string | null
    OwnerIsCalled?: string | null
    agentIsCalled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutServiceInput
    templates?: ServiceTemplateCreateNestedManyWithoutServiceInput
    forms?: ServiceFormCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutCategoryInput = {
    id?: string
    name: string
    type: string
    code: string
    description: string
    country: string
    price: string
    timeline: string
    feature?: ServiceCreatefeatureInput | Enumerable<string>
    categoryForm?: ServiceCreatecategoryFormInput | Enumerable<string>
    hasShares?: boolean
    numberOfShares: string
    hasAgent?: boolean
    hasOwner?: boolean
    hasController?: boolean
    controllerIsCalled?: string | null
    OwnerIsCalled?: string | null
    agentIsCalled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutServiceInput
    templates?: ServiceTemplateUncheckedCreateNestedManyWithoutServiceInput
    forms?: ServiceFormUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutCategoryInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput>
  }

  export type ServiceCreateManyCategoryInputEnvelope = {
    data: Enumerable<ServiceCreateManyCategoryInput>
    skipDuplicates?: boolean
  }

  export type ServiceCategoryFormCreateWithoutCategoryInput = {
    id?: string
    question: string
    type: string
    options?: ServiceCategoryFormCreateoptionsInput | Enumerable<string>
    compulsory?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceCategoryFormUncheckedCreateWithoutCategoryInput = {
    id?: string
    question: string
    type: string
    options?: ServiceCategoryFormCreateoptionsInput | Enumerable<string>
    compulsory?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceCategoryFormCreateOrConnectWithoutCategoryInput = {
    where: ServiceCategoryFormWhereUniqueInput
    create: XOR<ServiceCategoryFormCreateWithoutCategoryInput, ServiceCategoryFormUncheckedCreateWithoutCategoryInput>
  }

  export type ServiceCategoryFormCreateManyCategoryInputEnvelope = {
    data: Enumerable<ServiceCategoryFormCreateManyCategoryInput>
    skipDuplicates?: boolean
  }

  export type ServiceUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutCategoryInput, ServiceUncheckedUpdateWithoutCategoryInput>
    create: XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutCategoryInput, ServiceUncheckedUpdateWithoutCategoryInput>
  }

  export type ServiceUpdateManyWithWhereWithoutCategoryInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutServicesInput>
  }

  export type ServiceScalarWhereInput = {
    AND?: Enumerable<ServiceScalarWhereInput>
    OR?: Enumerable<ServiceScalarWhereInput>
    NOT?: Enumerable<ServiceScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    type?: StringFilter | string
    code?: StringFilter | string
    description?: StringFilter | string
    country?: StringFilter | string
    price?: StringFilter | string
    timeline?: StringFilter | string
    feature?: StringNullableListFilter
    categoryForm?: StringNullableListFilter
    hasShares?: BoolFilter | boolean
    numberOfShares?: StringFilter | string
    hasAgent?: BoolFilter | boolean
    hasOwner?: BoolFilter | boolean
    hasController?: BoolFilter | boolean
    controllerIsCalled?: StringNullableFilter | string | null
    OwnerIsCalled?: StringNullableFilter | string | null
    agentIsCalled?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    serviceCategoryId?: StringFilter | string
  }

  export type ServiceCategoryFormUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ServiceCategoryFormWhereUniqueInput
    update: XOR<ServiceCategoryFormUpdateWithoutCategoryInput, ServiceCategoryFormUncheckedUpdateWithoutCategoryInput>
    create: XOR<ServiceCategoryFormCreateWithoutCategoryInput, ServiceCategoryFormUncheckedCreateWithoutCategoryInput>
  }

  export type ServiceCategoryFormUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ServiceCategoryFormWhereUniqueInput
    data: XOR<ServiceCategoryFormUpdateWithoutCategoryInput, ServiceCategoryFormUncheckedUpdateWithoutCategoryInput>
  }

  export type ServiceCategoryFormUpdateManyWithWhereWithoutCategoryInput = {
    where: ServiceCategoryFormScalarWhereInput
    data: XOR<ServiceCategoryFormUpdateManyMutationInput, ServiceCategoryFormUncheckedUpdateManyWithoutFormInput>
  }

  export type ServiceCategoryFormScalarWhereInput = {
    AND?: Enumerable<ServiceCategoryFormScalarWhereInput>
    OR?: Enumerable<ServiceCategoryFormScalarWhereInput>
    NOT?: Enumerable<ServiceCategoryFormScalarWhereInput>
    id?: StringFilter | string
    question?: StringFilter | string
    type?: StringFilter | string
    options?: StringNullableListFilter
    compulsory?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    serviceCategoryId?: StringFilter | string
  }

  export type ServiceCategoryCreateWithoutFormInput = {
    id?: string
    name: string
    description: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceCreateNestedManyWithoutCategoryInput
  }

  export type ServiceCategoryUncheckedCreateWithoutFormInput = {
    id?: string
    name: string
    description: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ServiceCategoryCreateOrConnectWithoutFormInput = {
    where: ServiceCategoryWhereUniqueInput
    create: XOR<ServiceCategoryCreateWithoutFormInput, ServiceCategoryUncheckedCreateWithoutFormInput>
  }

  export type ServiceCategoryUpsertWithoutFormInput = {
    update: XOR<ServiceCategoryUpdateWithoutFormInput, ServiceCategoryUncheckedUpdateWithoutFormInput>
    create: XOR<ServiceCategoryCreateWithoutFormInput, ServiceCategoryUncheckedCreateWithoutFormInput>
  }

  export type ServiceCategoryUpdateWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUpdateManyWithoutCategoryNestedInput
  }

  export type ServiceCategoryUncheckedUpdateWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ServiceCategoryCreateWithoutServicesInput = {
    id?: string
    name: string
    description: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    form?: ServiceCategoryFormCreateNestedManyWithoutCategoryInput
  }

  export type ServiceCategoryUncheckedCreateWithoutServicesInput = {
    id?: string
    name: string
    description: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    form?: ServiceCategoryFormUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ServiceCategoryCreateOrConnectWithoutServicesInput = {
    where: ServiceCategoryWhereUniqueInput
    create: XOR<ServiceCategoryCreateWithoutServicesInput, ServiceCategoryUncheckedCreateWithoutServicesInput>
  }

  export type ProductCreateWithoutServiceInput = {
    id?: string
    email?: string | null
    address?: string | null
    paid?: boolean
    completed?: boolean
    status?: string
    currentState?: ProductActivityStage
    createdAt?: Date | string
    updatedAt?: Date | string
    Team?: TeamCreateNestedManyWithoutProductInput
    user: UserCreateNestedOneWithoutProductInput
    Payment?: PaymentCreateNestedManyWithoutProductsInput
    productQA?: ProductQACreateNestedManyWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutServiceInput = {
    id?: string
    email?: string | null
    address?: string | null
    paid?: boolean
    completed?: boolean
    status?: string
    currentState?: ProductActivityStage
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    Team?: TeamUncheckedCreateNestedManyWithoutProductInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutProductsInput
    productQA?: ProductQAUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductCreateOrConnectWithoutServiceInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutServiceInput, ProductUncheckedCreateWithoutServiceInput>
  }

  export type ProductCreateManyServiceInputEnvelope = {
    data: Enumerable<ProductCreateManyServiceInput>
    skipDuplicates?: boolean
  }

  export type ServiceTemplateCreateWithoutServiceInput = {
    id?: string
    name: string
    type: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceTemplateUncheckedCreateWithoutServiceInput = {
    id?: string
    name: string
    type: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceTemplateCreateOrConnectWithoutServiceInput = {
    where: ServiceTemplateWhereUniqueInput
    create: XOR<ServiceTemplateCreateWithoutServiceInput, ServiceTemplateUncheckedCreateWithoutServiceInput>
  }

  export type ServiceTemplateCreateManyServiceInputEnvelope = {
    data: Enumerable<ServiceTemplateCreateManyServiceInput>
    skipDuplicates?: boolean
  }

  export type ServiceFormCreateWithoutServiceInput = {
    id?: string
    question: string
    type: string
    options?: ServiceFormCreateoptionsInput | Enumerable<string>
    compulsory?: boolean
    fileName: string
    fileDescription: string
    fileType: string
    fileLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceSubForm?: ServiceSubFormCreateNestedManyWithoutServiceFormInput
  }

  export type ServiceFormUncheckedCreateWithoutServiceInput = {
    id?: string
    question: string
    type: string
    options?: ServiceFormCreateoptionsInput | Enumerable<string>
    compulsory?: boolean
    fileName: string
    fileDescription: string
    fileType: string
    fileLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceSubForm?: ServiceSubFormUncheckedCreateNestedManyWithoutServiceFormInput
  }

  export type ServiceFormCreateOrConnectWithoutServiceInput = {
    where: ServiceFormWhereUniqueInput
    create: XOR<ServiceFormCreateWithoutServiceInput, ServiceFormUncheckedCreateWithoutServiceInput>
  }

  export type ServiceFormCreateManyServiceInputEnvelope = {
    data: Enumerable<ServiceFormCreateManyServiceInput>
    skipDuplicates?: boolean
  }

  export type ServiceCategoryUpsertWithoutServicesInput = {
    update: XOR<ServiceCategoryUpdateWithoutServicesInput, ServiceCategoryUncheckedUpdateWithoutServicesInput>
    create: XOR<ServiceCategoryCreateWithoutServicesInput, ServiceCategoryUncheckedCreateWithoutServicesInput>
  }

  export type ServiceCategoryUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: ServiceCategoryFormUpdateManyWithoutCategoryNestedInput
  }

  export type ServiceCategoryUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: ServiceCategoryFormUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ProductUpsertWithWhereUniqueWithoutServiceInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutServiceInput, ProductUncheckedUpdateWithoutServiceInput>
    create: XOR<ProductCreateWithoutServiceInput, ProductUncheckedCreateWithoutServiceInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutServiceInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutServiceInput, ProductUncheckedUpdateWithoutServiceInput>
  }

  export type ProductUpdateManyWithWhereWithoutServiceInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductsInput>
  }

  export type ServiceTemplateUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServiceTemplateWhereUniqueInput
    update: XOR<ServiceTemplateUpdateWithoutServiceInput, ServiceTemplateUncheckedUpdateWithoutServiceInput>
    create: XOR<ServiceTemplateCreateWithoutServiceInput, ServiceTemplateUncheckedCreateWithoutServiceInput>
  }

  export type ServiceTemplateUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServiceTemplateWhereUniqueInput
    data: XOR<ServiceTemplateUpdateWithoutServiceInput, ServiceTemplateUncheckedUpdateWithoutServiceInput>
  }

  export type ServiceTemplateUpdateManyWithWhereWithoutServiceInput = {
    where: ServiceTemplateScalarWhereInput
    data: XOR<ServiceTemplateUpdateManyMutationInput, ServiceTemplateUncheckedUpdateManyWithoutTemplatesInput>
  }

  export type ServiceTemplateScalarWhereInput = {
    AND?: Enumerable<ServiceTemplateScalarWhereInput>
    OR?: Enumerable<ServiceTemplateScalarWhereInput>
    NOT?: Enumerable<ServiceTemplateScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    type?: StringFilter | string
    description?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    serviceId?: StringFilter | string
  }

  export type ServiceFormUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServiceFormWhereUniqueInput
    update: XOR<ServiceFormUpdateWithoutServiceInput, ServiceFormUncheckedUpdateWithoutServiceInput>
    create: XOR<ServiceFormCreateWithoutServiceInput, ServiceFormUncheckedCreateWithoutServiceInput>
  }

  export type ServiceFormUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServiceFormWhereUniqueInput
    data: XOR<ServiceFormUpdateWithoutServiceInput, ServiceFormUncheckedUpdateWithoutServiceInput>
  }

  export type ServiceFormUpdateManyWithWhereWithoutServiceInput = {
    where: ServiceFormScalarWhereInput
    data: XOR<ServiceFormUpdateManyMutationInput, ServiceFormUncheckedUpdateManyWithoutFormsInput>
  }

  export type ServiceFormScalarWhereInput = {
    AND?: Enumerable<ServiceFormScalarWhereInput>
    OR?: Enumerable<ServiceFormScalarWhereInput>
    NOT?: Enumerable<ServiceFormScalarWhereInput>
    id?: StringFilter | string
    question?: StringFilter | string
    type?: StringFilter | string
    options?: StringNullableListFilter
    compulsory?: BoolFilter | boolean
    fileName?: StringFilter | string
    fileDescription?: StringFilter | string
    fileType?: StringFilter | string
    fileLink?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    serviceId?: StringFilter | string
  }

  export type ServiceCreateWithoutTemplatesInput = {
    id?: string
    name: string
    type: string
    code: string
    description: string
    country: string
    price: string
    timeline: string
    feature?: ServiceCreatefeatureInput | Enumerable<string>
    categoryForm?: ServiceCreatecategoryFormInput | Enumerable<string>
    hasShares?: boolean
    numberOfShares: string
    hasAgent?: boolean
    hasOwner?: boolean
    hasController?: boolean
    controllerIsCalled?: string | null
    OwnerIsCalled?: string | null
    agentIsCalled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category: ServiceCategoryCreateNestedOneWithoutServicesInput
    products?: ProductCreateNestedManyWithoutServiceInput
    forms?: ServiceFormCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutTemplatesInput = {
    id?: string
    name: string
    type: string
    code: string
    description: string
    country: string
    price: string
    timeline: string
    feature?: ServiceCreatefeatureInput | Enumerable<string>
    categoryForm?: ServiceCreatecategoryFormInput | Enumerable<string>
    hasShares?: boolean
    numberOfShares: string
    hasAgent?: boolean
    hasOwner?: boolean
    hasController?: boolean
    controllerIsCalled?: string | null
    OwnerIsCalled?: string | null
    agentIsCalled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceCategoryId: string
    products?: ProductUncheckedCreateNestedManyWithoutServiceInput
    forms?: ServiceFormUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutTemplatesInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutTemplatesInput, ServiceUncheckedCreateWithoutTemplatesInput>
  }

  export type ServiceUpsertWithoutTemplatesInput = {
    update: XOR<ServiceUpdateWithoutTemplatesInput, ServiceUncheckedUpdateWithoutTemplatesInput>
    create: XOR<ServiceCreateWithoutTemplatesInput, ServiceUncheckedCreateWithoutTemplatesInput>
  }

  export type ServiceUpdateWithoutTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    timeline?: StringFieldUpdateOperationsInput | string
    feature?: ServiceUpdatefeatureInput | Enumerable<string>
    categoryForm?: ServiceUpdatecategoryFormInput | Enumerable<string>
    hasShares?: BoolFieldUpdateOperationsInput | boolean
    numberOfShares?: StringFieldUpdateOperationsInput | string
    hasAgent?: BoolFieldUpdateOperationsInput | boolean
    hasOwner?: BoolFieldUpdateOperationsInput | boolean
    hasController?: BoolFieldUpdateOperationsInput | boolean
    controllerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    agentIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ServiceCategoryUpdateOneRequiredWithoutServicesNestedInput
    products?: ProductUpdateManyWithoutServiceNestedInput
    forms?: ServiceFormUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    timeline?: StringFieldUpdateOperationsInput | string
    feature?: ServiceUpdatefeatureInput | Enumerable<string>
    categoryForm?: ServiceUpdatecategoryFormInput | Enumerable<string>
    hasShares?: BoolFieldUpdateOperationsInput | boolean
    numberOfShares?: StringFieldUpdateOperationsInput | string
    hasAgent?: BoolFieldUpdateOperationsInput | boolean
    hasOwner?: BoolFieldUpdateOperationsInput | boolean
    hasController?: BoolFieldUpdateOperationsInput | boolean
    controllerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    agentIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceCategoryId?: StringFieldUpdateOperationsInput | string
    products?: ProductUncheckedUpdateManyWithoutServiceNestedInput
    forms?: ServiceFormUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateWithoutFormsInput = {
    id?: string
    name: string
    type: string
    code: string
    description: string
    country: string
    price: string
    timeline: string
    feature?: ServiceCreatefeatureInput | Enumerable<string>
    categoryForm?: ServiceCreatecategoryFormInput | Enumerable<string>
    hasShares?: boolean
    numberOfShares: string
    hasAgent?: boolean
    hasOwner?: boolean
    hasController?: boolean
    controllerIsCalled?: string | null
    OwnerIsCalled?: string | null
    agentIsCalled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category: ServiceCategoryCreateNestedOneWithoutServicesInput
    products?: ProductCreateNestedManyWithoutServiceInput
    templates?: ServiceTemplateCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutFormsInput = {
    id?: string
    name: string
    type: string
    code: string
    description: string
    country: string
    price: string
    timeline: string
    feature?: ServiceCreatefeatureInput | Enumerable<string>
    categoryForm?: ServiceCreatecategoryFormInput | Enumerable<string>
    hasShares?: boolean
    numberOfShares: string
    hasAgent?: boolean
    hasOwner?: boolean
    hasController?: boolean
    controllerIsCalled?: string | null
    OwnerIsCalled?: string | null
    agentIsCalled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceCategoryId: string
    products?: ProductUncheckedCreateNestedManyWithoutServiceInput
    templates?: ServiceTemplateUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutFormsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutFormsInput, ServiceUncheckedCreateWithoutFormsInput>
  }

  export type ServiceSubFormCreateWithoutServiceFormInput = {
    id?: string
    question: string
    options?: ServiceSubFormCreateoptionsInput | Enumerable<string>
    type: string
    compulsory?: boolean
    fileName: string
    fileDescription: string
    fileType: string
    fileLink: string
  }

  export type ServiceSubFormUncheckedCreateWithoutServiceFormInput = {
    id?: string
    question: string
    options?: ServiceSubFormCreateoptionsInput | Enumerable<string>
    type: string
    compulsory?: boolean
    fileName: string
    fileDescription: string
    fileType: string
    fileLink: string
  }

  export type ServiceSubFormCreateOrConnectWithoutServiceFormInput = {
    where: ServiceSubFormWhereUniqueInput
    create: XOR<ServiceSubFormCreateWithoutServiceFormInput, ServiceSubFormUncheckedCreateWithoutServiceFormInput>
  }

  export type ServiceSubFormCreateManyServiceFormInputEnvelope = {
    data: Enumerable<ServiceSubFormCreateManyServiceFormInput>
    skipDuplicates?: boolean
  }

  export type ServiceUpsertWithoutFormsInput = {
    update: XOR<ServiceUpdateWithoutFormsInput, ServiceUncheckedUpdateWithoutFormsInput>
    create: XOR<ServiceCreateWithoutFormsInput, ServiceUncheckedCreateWithoutFormsInput>
  }

  export type ServiceUpdateWithoutFormsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    timeline?: StringFieldUpdateOperationsInput | string
    feature?: ServiceUpdatefeatureInput | Enumerable<string>
    categoryForm?: ServiceUpdatecategoryFormInput | Enumerable<string>
    hasShares?: BoolFieldUpdateOperationsInput | boolean
    numberOfShares?: StringFieldUpdateOperationsInput | string
    hasAgent?: BoolFieldUpdateOperationsInput | boolean
    hasOwner?: BoolFieldUpdateOperationsInput | boolean
    hasController?: BoolFieldUpdateOperationsInput | boolean
    controllerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    agentIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ServiceCategoryUpdateOneRequiredWithoutServicesNestedInput
    products?: ProductUpdateManyWithoutServiceNestedInput
    templates?: ServiceTemplateUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutFormsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    timeline?: StringFieldUpdateOperationsInput | string
    feature?: ServiceUpdatefeatureInput | Enumerable<string>
    categoryForm?: ServiceUpdatecategoryFormInput | Enumerable<string>
    hasShares?: BoolFieldUpdateOperationsInput | boolean
    numberOfShares?: StringFieldUpdateOperationsInput | string
    hasAgent?: BoolFieldUpdateOperationsInput | boolean
    hasOwner?: BoolFieldUpdateOperationsInput | boolean
    hasController?: BoolFieldUpdateOperationsInput | boolean
    controllerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    agentIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceCategoryId?: StringFieldUpdateOperationsInput | string
    products?: ProductUncheckedUpdateManyWithoutServiceNestedInput
    templates?: ServiceTemplateUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceSubFormUpsertWithWhereUniqueWithoutServiceFormInput = {
    where: ServiceSubFormWhereUniqueInput
    update: XOR<ServiceSubFormUpdateWithoutServiceFormInput, ServiceSubFormUncheckedUpdateWithoutServiceFormInput>
    create: XOR<ServiceSubFormCreateWithoutServiceFormInput, ServiceSubFormUncheckedCreateWithoutServiceFormInput>
  }

  export type ServiceSubFormUpdateWithWhereUniqueWithoutServiceFormInput = {
    where: ServiceSubFormWhereUniqueInput
    data: XOR<ServiceSubFormUpdateWithoutServiceFormInput, ServiceSubFormUncheckedUpdateWithoutServiceFormInput>
  }

  export type ServiceSubFormUpdateManyWithWhereWithoutServiceFormInput = {
    where: ServiceSubFormScalarWhereInput
    data: XOR<ServiceSubFormUpdateManyMutationInput, ServiceSubFormUncheckedUpdateManyWithoutServiceSubFormInput>
  }

  export type ServiceSubFormScalarWhereInput = {
    AND?: Enumerable<ServiceSubFormScalarWhereInput>
    OR?: Enumerable<ServiceSubFormScalarWhereInput>
    NOT?: Enumerable<ServiceSubFormScalarWhereInput>
    id?: StringFilter | string
    question?: StringFilter | string
    options?: StringNullableListFilter
    type?: StringFilter | string
    compulsory?: BoolFilter | boolean
    fileName?: StringFilter | string
    fileDescription?: StringFilter | string
    fileType?: StringFilter | string
    fileLink?: StringFilter | string
    serviceFormId?: StringFilter | string
  }

  export type ServiceFormCreateWithoutServiceSubFormInput = {
    id?: string
    question: string
    type: string
    options?: ServiceFormCreateoptionsInput | Enumerable<string>
    compulsory?: boolean
    fileName: string
    fileDescription: string
    fileType: string
    fileLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
    service: ServiceCreateNestedOneWithoutFormsInput
  }

  export type ServiceFormUncheckedCreateWithoutServiceSubFormInput = {
    id?: string
    question: string
    type: string
    options?: ServiceFormCreateoptionsInput | Enumerable<string>
    compulsory?: boolean
    fileName: string
    fileDescription: string
    fileType: string
    fileLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceId: string
  }

  export type ServiceFormCreateOrConnectWithoutServiceSubFormInput = {
    where: ServiceFormWhereUniqueInput
    create: XOR<ServiceFormCreateWithoutServiceSubFormInput, ServiceFormUncheckedCreateWithoutServiceSubFormInput>
  }

  export type ServiceFormUpsertWithoutServiceSubFormInput = {
    update: XOR<ServiceFormUpdateWithoutServiceSubFormInput, ServiceFormUncheckedUpdateWithoutServiceSubFormInput>
    create: XOR<ServiceFormCreateWithoutServiceSubFormInput, ServiceFormUncheckedCreateWithoutServiceSubFormInput>
  }

  export type ServiceFormUpdateWithoutServiceSubFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: ServiceFormUpdateoptionsInput | Enumerable<string>
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    fileName?: StringFieldUpdateOperationsInput | string
    fileDescription?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutFormsNestedInput
  }

  export type ServiceFormUncheckedUpdateWithoutServiceSubFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: ServiceFormUpdateoptionsInput | Enumerable<string>
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    fileName?: StringFieldUpdateOperationsInput | string
    fileDescription?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type TeamCreateWithoutProductInput = {
    id?: string
    name: string
    slug: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    invitation?: InvitationCreateNestedManyWithoutTeamInput
    teamMember?: TeamMemberCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutProductInput = {
    id?: string
    name: string
    slug: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    invitation?: InvitationUncheckedCreateNestedManyWithoutTeamInput
    teamMember?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutProductInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutProductInput, TeamUncheckedCreateWithoutProductInput>
  }

  export type TeamCreateManyProductInputEnvelope = {
    data: Enumerable<TeamCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type ServiceCreateWithoutProductsInput = {
    id?: string
    name: string
    type: string
    code: string
    description: string
    country: string
    price: string
    timeline: string
    feature?: ServiceCreatefeatureInput | Enumerable<string>
    categoryForm?: ServiceCreatecategoryFormInput | Enumerable<string>
    hasShares?: boolean
    numberOfShares: string
    hasAgent?: boolean
    hasOwner?: boolean
    hasController?: boolean
    controllerIsCalled?: string | null
    OwnerIsCalled?: string | null
    agentIsCalled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category: ServiceCategoryCreateNestedOneWithoutServicesInput
    templates?: ServiceTemplateCreateNestedManyWithoutServiceInput
    forms?: ServiceFormCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    type: string
    code: string
    description: string
    country: string
    price: string
    timeline: string
    feature?: ServiceCreatefeatureInput | Enumerable<string>
    categoryForm?: ServiceCreatecategoryFormInput | Enumerable<string>
    hasShares?: boolean
    numberOfShares: string
    hasAgent?: boolean
    hasOwner?: boolean
    hasController?: boolean
    controllerIsCalled?: string | null
    OwnerIsCalled?: string | null
    agentIsCalled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceCategoryId: string
    templates?: ServiceTemplateUncheckedCreateNestedManyWithoutServiceInput
    forms?: ServiceFormUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutProductsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutProductsInput, ServiceUncheckedCreateWithoutProductsInput>
  }

  export type UserCreateWithoutProductInput = {
    id?: string
    fullName: string
    username?: string | null
    email: string
    password: string
    phone?: string | null
    picture?: string | null
    isVerified?: boolean
    referral: string
    country?: string | null
    resetToken?: string | null
    isPartner?: boolean
    isStaff?: boolean
    isPhoneRegistered?: boolean
    isPhoneVerified?: boolean
    isIdentificationRegistered?: boolean
    isIdentificationVerified?: boolean
    partnerPermission?: UserCreatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserCreatestaffPermissionInput | Enumerable<string>
    userPermission?: UserCreateuserPermissionInput | Enumerable<string>
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamMember?: TeamMemberCreateNestedManyWithoutUserInput
    account?: AccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProductInput = {
    id?: string
    fullName: string
    username?: string | null
    email: string
    password: string
    phone?: string | null
    picture?: string | null
    isVerified?: boolean
    referral: string
    country?: string | null
    resetToken?: string | null
    isPartner?: boolean
    isStaff?: boolean
    isPhoneRegistered?: boolean
    isPhoneVerified?: boolean
    isIdentificationRegistered?: boolean
    isIdentificationVerified?: boolean
    partnerPermission?: UserCreatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserCreatestaffPermissionInput | Enumerable<string>
    userPermission?: UserCreateuserPermissionInput | Enumerable<string>
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamMember?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    account?: AccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProductInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProductInput, UserUncheckedCreateWithoutProductInput>
  }

  export type PaymentCreateWithoutProductsInput = {
    id?: string
    provider: string
    transactionId: string
    status: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUncheckedCreateWithoutProductsInput = {
    id?: string
    provider: string
    transactionId: string
    status: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutProductsInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutProductsInput, PaymentUncheckedCreateWithoutProductsInput>
  }

  export type PaymentCreateManyProductsInputEnvelope = {
    data: Enumerable<PaymentCreateManyProductsInput>
    skipDuplicates?: boolean
  }

  export type ProductQACreateWithoutProductsInput = {
    id?: string
    question: string
    answer?: ProductQACreateanswerInput | Enumerable<string>
    type: string
    compulsory?: boolean
    isGeneral?: boolean
    fileName: string
    fileDescription: string
    fileType: string
    fileLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
    productSubForm?: ProductQASubFormCreateNestedManyWithoutProductQAInput
  }

  export type ProductQAUncheckedCreateWithoutProductsInput = {
    id?: string
    question: string
    answer?: ProductQACreateanswerInput | Enumerable<string>
    type: string
    compulsory?: boolean
    isGeneral?: boolean
    fileName: string
    fileDescription: string
    fileType: string
    fileLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
    productSubForm?: ProductQASubFormUncheckedCreateNestedManyWithoutProductQAInput
  }

  export type ProductQACreateOrConnectWithoutProductsInput = {
    where: ProductQAWhereUniqueInput
    create: XOR<ProductQACreateWithoutProductsInput, ProductQAUncheckedCreateWithoutProductsInput>
  }

  export type ProductQACreateManyProductsInputEnvelope = {
    data: Enumerable<ProductQACreateManyProductsInput>
    skipDuplicates?: boolean
  }

  export type TeamUpsertWithWhereUniqueWithoutProductInput = {
    where: TeamWhereUniqueInput
    update: XOR<TeamUpdateWithoutProductInput, TeamUncheckedUpdateWithoutProductInput>
    create: XOR<TeamCreateWithoutProductInput, TeamUncheckedCreateWithoutProductInput>
  }

  export type TeamUpdateWithWhereUniqueWithoutProductInput = {
    where: TeamWhereUniqueInput
    data: XOR<TeamUpdateWithoutProductInput, TeamUncheckedUpdateWithoutProductInput>
  }

  export type TeamUpdateManyWithWhereWithoutProductInput = {
    where: TeamScalarWhereInput
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyWithoutTeamInput>
  }

  export type TeamScalarWhereInput = {
    AND?: Enumerable<TeamScalarWhereInput>
    OR?: Enumerable<TeamScalarWhereInput>
    NOT?: Enumerable<TeamScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    slug?: StringFilter | string
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    productId?: StringFilter | string
  }

  export type ServiceUpsertWithoutProductsInput = {
    update: XOR<ServiceUpdateWithoutProductsInput, ServiceUncheckedUpdateWithoutProductsInput>
    create: XOR<ServiceCreateWithoutProductsInput, ServiceUncheckedCreateWithoutProductsInput>
  }

  export type ServiceUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    timeline?: StringFieldUpdateOperationsInput | string
    feature?: ServiceUpdatefeatureInput | Enumerable<string>
    categoryForm?: ServiceUpdatecategoryFormInput | Enumerable<string>
    hasShares?: BoolFieldUpdateOperationsInput | boolean
    numberOfShares?: StringFieldUpdateOperationsInput | string
    hasAgent?: BoolFieldUpdateOperationsInput | boolean
    hasOwner?: BoolFieldUpdateOperationsInput | boolean
    hasController?: BoolFieldUpdateOperationsInput | boolean
    controllerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    agentIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ServiceCategoryUpdateOneRequiredWithoutServicesNestedInput
    templates?: ServiceTemplateUpdateManyWithoutServiceNestedInput
    forms?: ServiceFormUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    timeline?: StringFieldUpdateOperationsInput | string
    feature?: ServiceUpdatefeatureInput | Enumerable<string>
    categoryForm?: ServiceUpdatecategoryFormInput | Enumerable<string>
    hasShares?: BoolFieldUpdateOperationsInput | boolean
    numberOfShares?: StringFieldUpdateOperationsInput | string
    hasAgent?: BoolFieldUpdateOperationsInput | boolean
    hasOwner?: BoolFieldUpdateOperationsInput | boolean
    hasController?: BoolFieldUpdateOperationsInput | boolean
    controllerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    agentIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceCategoryId?: StringFieldUpdateOperationsInput | string
    templates?: ServiceTemplateUncheckedUpdateManyWithoutServiceNestedInput
    forms?: ServiceFormUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type UserUpsertWithoutProductInput = {
    update: XOR<UserUpdateWithoutProductInput, UserUncheckedUpdateWithoutProductInput>
    create: XOR<UserCreateWithoutProductInput, UserUncheckedCreateWithoutProductInput>
  }

  export type UserUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    referral?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    isStaff?: BoolFieldUpdateOperationsInput | boolean
    isPhoneRegistered?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationRegistered?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationVerified?: BoolFieldUpdateOperationsInput | boolean
    partnerPermission?: UserUpdatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserUpdatestaffPermissionInput | Enumerable<string>
    userPermission?: UserUpdateuserPermissionInput | Enumerable<string>
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMember?: TeamMemberUpdateManyWithoutUserNestedInput
    account?: AccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    referral?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    isStaff?: BoolFieldUpdateOperationsInput | boolean
    isPhoneRegistered?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationRegistered?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationVerified?: BoolFieldUpdateOperationsInput | boolean
    partnerPermission?: UserUpdatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserUpdatestaffPermissionInput | Enumerable<string>
    userPermission?: UserUpdateuserPermissionInput | Enumerable<string>
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMember?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    account?: AccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PaymentUpsertWithWhereUniqueWithoutProductsInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutProductsInput, PaymentUncheckedUpdateWithoutProductsInput>
    create: XOR<PaymentCreateWithoutProductsInput, PaymentUncheckedCreateWithoutProductsInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutProductsInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutProductsInput, PaymentUncheckedUpdateWithoutProductsInput>
  }

  export type PaymentUpdateManyWithWhereWithoutProductsInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutPaymentInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: Enumerable<PaymentScalarWhereInput>
    OR?: Enumerable<PaymentScalarWhereInput>
    NOT?: Enumerable<PaymentScalarWhereInput>
    id?: StringFilter | string
    provider?: StringFilter | string
    transactionId?: StringFilter | string
    status?: StringFilter | string
    email?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    productId?: StringFilter | string
  }

  export type ProductQAUpsertWithWhereUniqueWithoutProductsInput = {
    where: ProductQAWhereUniqueInput
    update: XOR<ProductQAUpdateWithoutProductsInput, ProductQAUncheckedUpdateWithoutProductsInput>
    create: XOR<ProductQACreateWithoutProductsInput, ProductQAUncheckedCreateWithoutProductsInput>
  }

  export type ProductQAUpdateWithWhereUniqueWithoutProductsInput = {
    where: ProductQAWhereUniqueInput
    data: XOR<ProductQAUpdateWithoutProductsInput, ProductQAUncheckedUpdateWithoutProductsInput>
  }

  export type ProductQAUpdateManyWithWhereWithoutProductsInput = {
    where: ProductQAScalarWhereInput
    data: XOR<ProductQAUpdateManyMutationInput, ProductQAUncheckedUpdateManyWithoutProductQAInput>
  }

  export type ProductQAScalarWhereInput = {
    AND?: Enumerable<ProductQAScalarWhereInput>
    OR?: Enumerable<ProductQAScalarWhereInput>
    NOT?: Enumerable<ProductQAScalarWhereInput>
    id?: StringFilter | string
    question?: StringFilter | string
    answer?: StringNullableListFilter
    type?: StringFilter | string
    compulsory?: BoolFilter | boolean
    isGeneral?: BoolFilter | boolean
    fileName?: StringFilter | string
    fileDescription?: StringFilter | string
    fileType?: StringFilter | string
    fileLink?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    productId?: StringFilter | string
  }

  export type ProductCreateWithoutProductQAInput = {
    id?: string
    email?: string | null
    address?: string | null
    paid?: boolean
    completed?: boolean
    status?: string
    currentState?: ProductActivityStage
    createdAt?: Date | string
    updatedAt?: Date | string
    Team?: TeamCreateNestedManyWithoutProductInput
    service?: ServiceCreateNestedOneWithoutProductsInput
    user: UserCreateNestedOneWithoutProductInput
    Payment?: PaymentCreateNestedManyWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutProductQAInput = {
    id?: string
    email?: string | null
    address?: string | null
    paid?: boolean
    completed?: boolean
    status?: string
    currentState?: ProductActivityStage
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceId?: string | null
    userId: string
    Team?: TeamUncheckedCreateNestedManyWithoutProductInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductCreateOrConnectWithoutProductQAInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductQAInput, ProductUncheckedCreateWithoutProductQAInput>
  }

  export type ProductQASubFormCreateWithoutProductQAInput = {
    id?: string
    question: string
    answer?: ProductQASubFormCreateanswerInput | Enumerable<string>
    type: string
    compulsory?: boolean
  }

  export type ProductQASubFormUncheckedCreateWithoutProductQAInput = {
    id?: string
    question: string
    answer?: ProductQASubFormCreateanswerInput | Enumerable<string>
    type: string
    compulsory?: boolean
  }

  export type ProductQASubFormCreateOrConnectWithoutProductQAInput = {
    where: ProductQASubFormWhereUniqueInput
    create: XOR<ProductQASubFormCreateWithoutProductQAInput, ProductQASubFormUncheckedCreateWithoutProductQAInput>
  }

  export type ProductQASubFormCreateManyProductQAInputEnvelope = {
    data: Enumerable<ProductQASubFormCreateManyProductQAInput>
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithoutProductQAInput = {
    update: XOR<ProductUpdateWithoutProductQAInput, ProductUncheckedUpdateWithoutProductQAInput>
    create: XOR<ProductCreateWithoutProductQAInput, ProductUncheckedCreateWithoutProductQAInput>
  }

  export type ProductUpdateWithoutProductQAInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    currentState?: EnumProductActivityStageFieldUpdateOperationsInput | ProductActivityStage
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Team?: TeamUpdateManyWithoutProductNestedInput
    service?: ServiceUpdateOneWithoutProductsNestedInput
    user?: UserUpdateOneRequiredWithoutProductNestedInput
    Payment?: PaymentUpdateManyWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductQAInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    currentState?: EnumProductActivityStageFieldUpdateOperationsInput | ProductActivityStage
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    Team?: TeamUncheckedUpdateManyWithoutProductNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type ProductQASubFormUpsertWithWhereUniqueWithoutProductQAInput = {
    where: ProductQASubFormWhereUniqueInput
    update: XOR<ProductQASubFormUpdateWithoutProductQAInput, ProductQASubFormUncheckedUpdateWithoutProductQAInput>
    create: XOR<ProductQASubFormCreateWithoutProductQAInput, ProductQASubFormUncheckedCreateWithoutProductQAInput>
  }

  export type ProductQASubFormUpdateWithWhereUniqueWithoutProductQAInput = {
    where: ProductQASubFormWhereUniqueInput
    data: XOR<ProductQASubFormUpdateWithoutProductQAInput, ProductQASubFormUncheckedUpdateWithoutProductQAInput>
  }

  export type ProductQASubFormUpdateManyWithWhereWithoutProductQAInput = {
    where: ProductQASubFormScalarWhereInput
    data: XOR<ProductQASubFormUpdateManyMutationInput, ProductQASubFormUncheckedUpdateManyWithoutProductSubFormInput>
  }

  export type ProductQASubFormScalarWhereInput = {
    AND?: Enumerable<ProductQASubFormScalarWhereInput>
    OR?: Enumerable<ProductQASubFormScalarWhereInput>
    NOT?: Enumerable<ProductQASubFormScalarWhereInput>
    id?: StringFilter | string
    question?: StringFilter | string
    answer?: StringNullableListFilter
    type?: StringFilter | string
    compulsory?: BoolFilter | boolean
    productQAId?: StringFilter | string
  }

  export type ProductQACreateWithoutProductSubFormInput = {
    id?: string
    question: string
    answer?: ProductQACreateanswerInput | Enumerable<string>
    type: string
    compulsory?: boolean
    isGeneral?: boolean
    fileName: string
    fileDescription: string
    fileType: string
    fileLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products: ProductCreateNestedOneWithoutProductQAInput
  }

  export type ProductQAUncheckedCreateWithoutProductSubFormInput = {
    id?: string
    question: string
    answer?: ProductQACreateanswerInput | Enumerable<string>
    type: string
    compulsory?: boolean
    isGeneral?: boolean
    fileName: string
    fileDescription: string
    fileType: string
    fileLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
    productId: string
  }

  export type ProductQACreateOrConnectWithoutProductSubFormInput = {
    where: ProductQAWhereUniqueInput
    create: XOR<ProductQACreateWithoutProductSubFormInput, ProductQAUncheckedCreateWithoutProductSubFormInput>
  }

  export type ProductQAUpsertWithoutProductSubFormInput = {
    update: XOR<ProductQAUpdateWithoutProductSubFormInput, ProductQAUncheckedUpdateWithoutProductSubFormInput>
    create: XOR<ProductQACreateWithoutProductSubFormInput, ProductQAUncheckedCreateWithoutProductSubFormInput>
  }

  export type ProductQAUpdateWithoutProductSubFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: ProductQAUpdateanswerInput | Enumerable<string>
    type?: StringFieldUpdateOperationsInput | string
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    isGeneral?: BoolFieldUpdateOperationsInput | boolean
    fileName?: StringFieldUpdateOperationsInput | string
    fileDescription?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateOneRequiredWithoutProductQANestedInput
  }

  export type ProductQAUncheckedUpdateWithoutProductSubFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: ProductQAUpdateanswerInput | Enumerable<string>
    type?: StringFieldUpdateOperationsInput | string
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    isGeneral?: BoolFieldUpdateOperationsInput | boolean
    fileName?: StringFieldUpdateOperationsInput | string
    fileDescription?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductCreateWithoutTeamInput = {
    id?: string
    email?: string | null
    address?: string | null
    paid?: boolean
    completed?: boolean
    status?: string
    currentState?: ProductActivityStage
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutProductsInput
    user: UserCreateNestedOneWithoutProductInput
    Payment?: PaymentCreateNestedManyWithoutProductsInput
    productQA?: ProductQACreateNestedManyWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutTeamInput = {
    id?: string
    email?: string | null
    address?: string | null
    paid?: boolean
    completed?: boolean
    status?: string
    currentState?: ProductActivityStage
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceId?: string | null
    userId: string
    Payment?: PaymentUncheckedCreateNestedManyWithoutProductsInput
    productQA?: ProductQAUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductCreateOrConnectWithoutTeamInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutTeamInput, ProductUncheckedCreateWithoutTeamInput>
  }

  export type InvitationCreateWithoutTeamInput = {
    id?: string
    email: string
    token: string
    expireIn: Date | string
    invitedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvitationUncheckedCreateWithoutTeamInput = {
    id?: string
    email: string
    token: string
    expireIn: Date | string
    invitedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvitationCreateOrConnectWithoutTeamInput = {
    where: InvitationWhereUniqueInput
    create: XOR<InvitationCreateWithoutTeamInput, InvitationUncheckedCreateWithoutTeamInput>
  }

  export type InvitationCreateManyTeamInputEnvelope = {
    data: Enumerable<InvitationCreateManyTeamInput>
    skipDuplicates?: boolean
  }

  export type TeamMemberCreateWithoutTeamInput = {
    id?: string
    isLaunchMember: boolean
    isLaunchController: boolean
    isLaunchOwner: boolean
    launchOwnership: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTeamMemberInput
  }

  export type TeamMemberUncheckedCreateWithoutTeamInput = {
    id?: string
    isLaunchMember: boolean
    isLaunchController: boolean
    isLaunchOwner: boolean
    launchOwnership: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamMemberCreateOrConnectWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    create: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
  }

  export type TeamMemberCreateManyTeamInputEnvelope = {
    data: Enumerable<TeamMemberCreateManyTeamInput>
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithoutTeamInput = {
    update: XOR<ProductUpdateWithoutTeamInput, ProductUncheckedUpdateWithoutTeamInput>
    create: XOR<ProductCreateWithoutTeamInput, ProductUncheckedCreateWithoutTeamInput>
  }

  export type ProductUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    currentState?: EnumProductActivityStageFieldUpdateOperationsInput | ProductActivityStage
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutProductsNestedInput
    user?: UserUpdateOneRequiredWithoutProductNestedInput
    Payment?: PaymentUpdateManyWithoutProductsNestedInput
    productQA?: ProductQAUpdateManyWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    currentState?: EnumProductActivityStageFieldUpdateOperationsInput | ProductActivityStage
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    Payment?: PaymentUncheckedUpdateManyWithoutProductsNestedInput
    productQA?: ProductQAUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type InvitationUpsertWithWhereUniqueWithoutTeamInput = {
    where: InvitationWhereUniqueInput
    update: XOR<InvitationUpdateWithoutTeamInput, InvitationUncheckedUpdateWithoutTeamInput>
    create: XOR<InvitationCreateWithoutTeamInput, InvitationUncheckedCreateWithoutTeamInput>
  }

  export type InvitationUpdateWithWhereUniqueWithoutTeamInput = {
    where: InvitationWhereUniqueInput
    data: XOR<InvitationUpdateWithoutTeamInput, InvitationUncheckedUpdateWithoutTeamInput>
  }

  export type InvitationUpdateManyWithWhereWithoutTeamInput = {
    where: InvitationScalarWhereInput
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyWithoutInvitationInput>
  }

  export type InvitationScalarWhereInput = {
    AND?: Enumerable<InvitationScalarWhereInput>
    OR?: Enumerable<InvitationScalarWhereInput>
    NOT?: Enumerable<InvitationScalarWhereInput>
    id?: StringFilter | string
    teamId?: StringFilter | string
    email?: StringFilter | string
    token?: StringFilter | string
    expireIn?: DateTimeFilter | Date | string
    invitedBy?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TeamMemberUpsertWithWhereUniqueWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    update: XOR<TeamMemberUpdateWithoutTeamInput, TeamMemberUncheckedUpdateWithoutTeamInput>
    create: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
  }

  export type TeamMemberUpdateWithWhereUniqueWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    data: XOR<TeamMemberUpdateWithoutTeamInput, TeamMemberUncheckedUpdateWithoutTeamInput>
  }

  export type TeamMemberUpdateManyWithWhereWithoutTeamInput = {
    where: TeamMemberScalarWhereInput
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyWithoutTeamMemberInput>
  }

  export type TeamCreateWithoutTeamMemberInput = {
    id?: string
    name: string
    slug: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutTeamInput
    invitation?: InvitationCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutTeamMemberInput = {
    id?: string
    name: string
    slug: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    productId: string
    invitation?: InvitationUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutTeamMemberInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutTeamMemberInput, TeamUncheckedCreateWithoutTeamMemberInput>
  }

  export type UserCreateWithoutTeamMemberInput = {
    id?: string
    fullName: string
    username?: string | null
    email: string
    password: string
    phone?: string | null
    picture?: string | null
    isVerified?: boolean
    referral: string
    country?: string | null
    resetToken?: string | null
    isPartner?: boolean
    isStaff?: boolean
    isPhoneRegistered?: boolean
    isPhoneVerified?: boolean
    isIdentificationRegistered?: boolean
    isIdentificationVerified?: boolean
    partnerPermission?: UserCreatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserCreatestaffPermissionInput | Enumerable<string>
    userPermission?: UserCreateuserPermissionInput | Enumerable<string>
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    account?: AccountCreateNestedManyWithoutUserInput
    product?: ProductCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTeamMemberInput = {
    id?: string
    fullName: string
    username?: string | null
    email: string
    password: string
    phone?: string | null
    picture?: string | null
    isVerified?: boolean
    referral: string
    country?: string | null
    resetToken?: string | null
    isPartner?: boolean
    isStaff?: boolean
    isPhoneRegistered?: boolean
    isPhoneVerified?: boolean
    isIdentificationRegistered?: boolean
    isIdentificationVerified?: boolean
    partnerPermission?: UserCreatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserCreatestaffPermissionInput | Enumerable<string>
    userPermission?: UserCreateuserPermissionInput | Enumerable<string>
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    account?: AccountUncheckedCreateNestedManyWithoutUserInput
    product?: ProductUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTeamMemberInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeamMemberInput, UserUncheckedCreateWithoutTeamMemberInput>
  }

  export type TeamUpsertWithoutTeamMemberInput = {
    update: XOR<TeamUpdateWithoutTeamMemberInput, TeamUncheckedUpdateWithoutTeamMemberInput>
    create: XOR<TeamCreateWithoutTeamMemberInput, TeamUncheckedCreateWithoutTeamMemberInput>
  }

  export type TeamUpdateWithoutTeamMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutTeamNestedInput
    invitation?: InvitationUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutTeamMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: StringFieldUpdateOperationsInput | string
    invitation?: InvitationUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type UserUpsertWithoutTeamMemberInput = {
    update: XOR<UserUpdateWithoutTeamMemberInput, UserUncheckedUpdateWithoutTeamMemberInput>
    create: XOR<UserCreateWithoutTeamMemberInput, UserUncheckedCreateWithoutTeamMemberInput>
  }

  export type UserUpdateWithoutTeamMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    referral?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    isStaff?: BoolFieldUpdateOperationsInput | boolean
    isPhoneRegistered?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationRegistered?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationVerified?: BoolFieldUpdateOperationsInput | boolean
    partnerPermission?: UserUpdatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserUpdatestaffPermissionInput | Enumerable<string>
    userPermission?: UserUpdateuserPermissionInput | Enumerable<string>
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateManyWithoutUserNestedInput
    product?: ProductUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTeamMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    referral?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    isPartner?: BoolFieldUpdateOperationsInput | boolean
    isStaff?: BoolFieldUpdateOperationsInput | boolean
    isPhoneRegistered?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationRegistered?: BoolFieldUpdateOperationsInput | boolean
    isIdentificationVerified?: BoolFieldUpdateOperationsInput | boolean
    partnerPermission?: UserUpdatepartnerPermissionInput | Enumerable<string>
    staffPermission?: UserUpdatestaffPermissionInput | Enumerable<string>
    userPermission?: UserUpdateuserPermissionInput | Enumerable<string>
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUncheckedUpdateManyWithoutUserNestedInput
    product?: ProductUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TeamCreateWithoutInvitationInput = {
    id?: string
    name: string
    slug: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutTeamInput
    teamMember?: TeamMemberCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutInvitationInput = {
    id?: string
    name: string
    slug: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    productId: string
    teamMember?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutInvitationInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutInvitationInput, TeamUncheckedCreateWithoutInvitationInput>
  }

  export type TeamUpsertWithoutInvitationInput = {
    update: XOR<TeamUpdateWithoutInvitationInput, TeamUncheckedUpdateWithoutInvitationInput>
    create: XOR<TeamCreateWithoutInvitationInput, TeamUncheckedCreateWithoutInvitationInput>
  }

  export type TeamUpdateWithoutInvitationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutTeamNestedInput
    teamMember?: TeamMemberUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutInvitationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: StringFieldUpdateOperationsInput | string
    teamMember?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type ProductCreateWithoutPaymentInput = {
    id?: string
    email?: string | null
    address?: string | null
    paid?: boolean
    completed?: boolean
    status?: string
    currentState?: ProductActivityStage
    createdAt?: Date | string
    updatedAt?: Date | string
    Team?: TeamCreateNestedManyWithoutProductInput
    service?: ServiceCreateNestedOneWithoutProductsInput
    user: UserCreateNestedOneWithoutProductInput
    productQA?: ProductQACreateNestedManyWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutPaymentInput = {
    id?: string
    email?: string | null
    address?: string | null
    paid?: boolean
    completed?: boolean
    status?: string
    currentState?: ProductActivityStage
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceId?: string | null
    userId: string
    Team?: TeamUncheckedCreateNestedManyWithoutProductInput
    productQA?: ProductQAUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductCreateOrConnectWithoutPaymentInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPaymentInput, ProductUncheckedCreateWithoutPaymentInput>
  }

  export type ProductUpsertWithoutPaymentInput = {
    update: XOR<ProductUpdateWithoutPaymentInput, ProductUncheckedUpdateWithoutPaymentInput>
    create: XOR<ProductCreateWithoutPaymentInput, ProductUncheckedCreateWithoutPaymentInput>
  }

  export type ProductUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    currentState?: EnumProductActivityStageFieldUpdateOperationsInput | ProductActivityStage
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Team?: TeamUpdateManyWithoutProductNestedInput
    service?: ServiceUpdateOneWithoutProductsNestedInput
    user?: UserUpdateOneRequiredWithoutProductNestedInput
    productQA?: ProductQAUpdateManyWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    currentState?: EnumProductActivityStageFieldUpdateOperationsInput | ProductActivityStage
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    Team?: TeamUncheckedUpdateManyWithoutProductNestedInput
    productQA?: ProductQAUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type CollaboratorDocumentCreateManyCollaboratorInput = {
    id?: string
    name: string
    type: string
    description: string
    isDeprecated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CollaboratorDocumentUpdateWithoutCollaboratorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollaboratorDocumentUncheckedUpdateWithoutCollaboratorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollaboratorDocumentUncheckedUpdateManyWithoutCollaboratorDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberCreateManyUserInput = {
    id?: string
    isLaunchMember: boolean
    isLaunchController: boolean
    isLaunchOwner: boolean
    launchOwnership: number
    teamId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    scope: string
  }

  export type ProductCreateManyUserInput = {
    id?: string
    email?: string | null
    address?: string | null
    paid?: boolean
    completed?: boolean
    status?: string
    currentState?: ProductActivityStage
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceId?: string | null
  }

  export type TeamMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isLaunchMember?: BoolFieldUpdateOperationsInput | boolean
    isLaunchController?: BoolFieldUpdateOperationsInput | boolean
    isLaunchOwner?: BoolFieldUpdateOperationsInput | boolean
    launchOwnership?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutTeamMemberNestedInput
  }

  export type TeamMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isLaunchMember?: BoolFieldUpdateOperationsInput | boolean
    isLaunchController?: BoolFieldUpdateOperationsInput | boolean
    isLaunchOwner?: BoolFieldUpdateOperationsInput | boolean
    launchOwnership?: IntFieldUpdateOperationsInput | number
    teamId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUncheckedUpdateManyWithoutTeamMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    isLaunchMember?: BoolFieldUpdateOperationsInput | boolean
    isLaunchController?: BoolFieldUpdateOperationsInput | boolean
    isLaunchOwner?: BoolFieldUpdateOperationsInput | boolean
    launchOwnership?: IntFieldUpdateOperationsInput | number
    teamId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
  }

  export type AccountUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
  }

  export type ProductUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    currentState?: EnumProductActivityStageFieldUpdateOperationsInput | ProductActivityStage
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Team?: TeamUpdateManyWithoutProductNestedInput
    service?: ServiceUpdateOneWithoutProductsNestedInput
    Payment?: PaymentUpdateManyWithoutProductsNestedInput
    productQA?: ProductQAUpdateManyWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    currentState?: EnumProductActivityStageFieldUpdateOperationsInput | ProductActivityStage
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    Team?: TeamUncheckedUpdateManyWithoutProductNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutProductsNestedInput
    productQA?: ProductQAUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    currentState?: EnumProductActivityStageFieldUpdateOperationsInput | ProductActivityStage
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceCreateManyCategoryInput = {
    id?: string
    name: string
    type: string
    code: string
    description: string
    country: string
    price: string
    timeline: string
    feature?: ServiceCreatefeatureInput | Enumerable<string>
    categoryForm?: ServiceCreatecategoryFormInput | Enumerable<string>
    hasShares?: boolean
    numberOfShares: string
    hasAgent?: boolean
    hasOwner?: boolean
    hasController?: boolean
    controllerIsCalled?: string | null
    OwnerIsCalled?: string | null
    agentIsCalled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceCategoryFormCreateManyCategoryInput = {
    id?: string
    question: string
    type: string
    options?: ServiceCategoryFormCreateoptionsInput | Enumerable<string>
    compulsory?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    timeline?: StringFieldUpdateOperationsInput | string
    feature?: ServiceUpdatefeatureInput | Enumerable<string>
    categoryForm?: ServiceUpdatecategoryFormInput | Enumerable<string>
    hasShares?: BoolFieldUpdateOperationsInput | boolean
    numberOfShares?: StringFieldUpdateOperationsInput | string
    hasAgent?: BoolFieldUpdateOperationsInput | boolean
    hasOwner?: BoolFieldUpdateOperationsInput | boolean
    hasController?: BoolFieldUpdateOperationsInput | boolean
    controllerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    agentIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutServiceNestedInput
    templates?: ServiceTemplateUpdateManyWithoutServiceNestedInput
    forms?: ServiceFormUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    timeline?: StringFieldUpdateOperationsInput | string
    feature?: ServiceUpdatefeatureInput | Enumerable<string>
    categoryForm?: ServiceUpdatecategoryFormInput | Enumerable<string>
    hasShares?: BoolFieldUpdateOperationsInput | boolean
    numberOfShares?: StringFieldUpdateOperationsInput | string
    hasAgent?: BoolFieldUpdateOperationsInput | boolean
    hasOwner?: BoolFieldUpdateOperationsInput | boolean
    hasController?: BoolFieldUpdateOperationsInput | boolean
    controllerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    agentIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutServiceNestedInput
    templates?: ServiceTemplateUncheckedUpdateManyWithoutServiceNestedInput
    forms?: ServiceFormUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    timeline?: StringFieldUpdateOperationsInput | string
    feature?: ServiceUpdatefeatureInput | Enumerable<string>
    categoryForm?: ServiceUpdatecategoryFormInput | Enumerable<string>
    hasShares?: BoolFieldUpdateOperationsInput | boolean
    numberOfShares?: StringFieldUpdateOperationsInput | string
    hasAgent?: BoolFieldUpdateOperationsInput | boolean
    hasOwner?: BoolFieldUpdateOperationsInput | boolean
    hasController?: BoolFieldUpdateOperationsInput | boolean
    controllerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    OwnerIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    agentIsCalled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCategoryFormUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: ServiceCategoryFormUpdateoptionsInput | Enumerable<string>
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCategoryFormUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: ServiceCategoryFormUpdateoptionsInput | Enumerable<string>
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCategoryFormUncheckedUpdateManyWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: ServiceCategoryFormUpdateoptionsInput | Enumerable<string>
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyServiceInput = {
    id?: string
    email?: string | null
    address?: string | null
    paid?: boolean
    completed?: boolean
    status?: string
    currentState?: ProductActivityStage
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type ServiceTemplateCreateManyServiceInput = {
    id?: string
    name: string
    type: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceFormCreateManyServiceInput = {
    id?: string
    question: string
    type: string
    options?: ServiceFormCreateoptionsInput | Enumerable<string>
    compulsory?: boolean
    fileName: string
    fileDescription: string
    fileType: string
    fileLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    currentState?: EnumProductActivityStageFieldUpdateOperationsInput | ProductActivityStage
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Team?: TeamUpdateManyWithoutProductNestedInput
    user?: UserUpdateOneRequiredWithoutProductNestedInput
    Payment?: PaymentUpdateManyWithoutProductsNestedInput
    productQA?: ProductQAUpdateManyWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    currentState?: EnumProductActivityStageFieldUpdateOperationsInput | ProductActivityStage
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    Team?: TeamUncheckedUpdateManyWithoutProductNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutProductsNestedInput
    productQA?: ProductQAUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    currentState?: EnumProductActivityStageFieldUpdateOperationsInput | ProductActivityStage
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceTemplateUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceTemplateUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceTemplateUncheckedUpdateManyWithoutTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceFormUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: ServiceFormUpdateoptionsInput | Enumerable<string>
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    fileName?: StringFieldUpdateOperationsInput | string
    fileDescription?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceSubForm?: ServiceSubFormUpdateManyWithoutServiceFormNestedInput
  }

  export type ServiceFormUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: ServiceFormUpdateoptionsInput | Enumerable<string>
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    fileName?: StringFieldUpdateOperationsInput | string
    fileDescription?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceSubForm?: ServiceSubFormUncheckedUpdateManyWithoutServiceFormNestedInput
  }

  export type ServiceFormUncheckedUpdateManyWithoutFormsInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: ServiceFormUpdateoptionsInput | Enumerable<string>
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    fileName?: StringFieldUpdateOperationsInput | string
    fileDescription?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceSubFormCreateManyServiceFormInput = {
    id?: string
    question: string
    options?: ServiceSubFormCreateoptionsInput | Enumerable<string>
    type: string
    compulsory?: boolean
    fileName: string
    fileDescription: string
    fileType: string
    fileLink: string
  }

  export type ServiceSubFormUpdateWithoutServiceFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: ServiceSubFormUpdateoptionsInput | Enumerable<string>
    type?: StringFieldUpdateOperationsInput | string
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    fileName?: StringFieldUpdateOperationsInput | string
    fileDescription?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileLink?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceSubFormUncheckedUpdateWithoutServiceFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: ServiceSubFormUpdateoptionsInput | Enumerable<string>
    type?: StringFieldUpdateOperationsInput | string
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    fileName?: StringFieldUpdateOperationsInput | string
    fileDescription?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileLink?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceSubFormUncheckedUpdateManyWithoutServiceSubFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: ServiceSubFormUpdateoptionsInput | Enumerable<string>
    type?: StringFieldUpdateOperationsInput | string
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    fileName?: StringFieldUpdateOperationsInput | string
    fileDescription?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileLink?: StringFieldUpdateOperationsInput | string
  }

  export type TeamCreateManyProductInput = {
    id?: string
    name: string
    slug: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyProductsInput = {
    id?: string
    provider: string
    transactionId: string
    status: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductQACreateManyProductsInput = {
    id?: string
    question: string
    answer?: ProductQACreateanswerInput | Enumerable<string>
    type: string
    compulsory?: boolean
    isGeneral?: boolean
    fileName: string
    fileDescription: string
    fileType: string
    fileLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitation?: InvitationUpdateManyWithoutTeamNestedInput
    teamMember?: TeamMemberUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitation?: InvitationUncheckedUpdateManyWithoutTeamNestedInput
    teamMember?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductQAUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: ProductQAUpdateanswerInput | Enumerable<string>
    type?: StringFieldUpdateOperationsInput | string
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    isGeneral?: BoolFieldUpdateOperationsInput | boolean
    fileName?: StringFieldUpdateOperationsInput | string
    fileDescription?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productSubForm?: ProductQASubFormUpdateManyWithoutProductQANestedInput
  }

  export type ProductQAUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: ProductQAUpdateanswerInput | Enumerable<string>
    type?: StringFieldUpdateOperationsInput | string
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    isGeneral?: BoolFieldUpdateOperationsInput | boolean
    fileName?: StringFieldUpdateOperationsInput | string
    fileDescription?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productSubForm?: ProductQASubFormUncheckedUpdateManyWithoutProductQANestedInput
  }

  export type ProductQAUncheckedUpdateManyWithoutProductQAInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: ProductQAUpdateanswerInput | Enumerable<string>
    type?: StringFieldUpdateOperationsInput | string
    compulsory?: BoolFieldUpdateOperationsInput | boolean
    isGeneral?: BoolFieldUpdateOperationsInput | boolean
    fileName?: StringFieldUpdateOperationsInput | string
    fileDescription?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductQASubFormCreateManyProductQAInput = {
    id?: string
    question: string
    answer?: ProductQASubFormCreateanswerInput | Enumerable<string>
    type: string
    compulsory?: boolean
  }

  export type ProductQASubFormUpdateWithoutProductQAInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: ProductQASubFormUpdateanswerInput | Enumerable<string>
    type?: StringFieldUpdateOperationsInput | string
    compulsory?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductQASubFormUncheckedUpdateWithoutProductQAInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: ProductQASubFormUpdateanswerInput | Enumerable<string>
    type?: StringFieldUpdateOperationsInput | string
    compulsory?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductQASubFormUncheckedUpdateManyWithoutProductSubFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: ProductQASubFormUpdateanswerInput | Enumerable<string>
    type?: StringFieldUpdateOperationsInput | string
    compulsory?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvitationCreateManyTeamInput = {
    id?: string
    email: string
    token: string
    expireIn: Date | string
    invitedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamMemberCreateManyTeamInput = {
    id?: string
    isLaunchMember: boolean
    isLaunchController: boolean
    isLaunchOwner: boolean
    launchOwnership: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvitationUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expireIn?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expireIn?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationUncheckedUpdateManyWithoutInvitationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expireIn?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    isLaunchMember?: BoolFieldUpdateOperationsInput | boolean
    isLaunchController?: BoolFieldUpdateOperationsInput | boolean
    isLaunchOwner?: BoolFieldUpdateOperationsInput | boolean
    launchOwnership?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeamMemberNestedInput
  }

  export type TeamMemberUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    isLaunchMember?: BoolFieldUpdateOperationsInput | boolean
    isLaunchController?: BoolFieldUpdateOperationsInput | boolean
    isLaunchOwner?: BoolFieldUpdateOperationsInput | boolean
    launchOwnership?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}